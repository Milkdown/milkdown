# @milkdown/transformer

> **Note**: This package is not intended to be used directly.

For every moment of a milkdown editor, it will have an editor state,
this state can both render a UI and be transformed into markdown string.
For any changes to the editor, it won't change UI directly, but create a new editor state and render a new UI by that state.

-   Markdown AST and editor state are two tree structure that can be transformed into each other.
-   When users edit the editor, the change will be passed into editor state.
-   When developers change the markdown content, the editor will sync its editor state with the new markdown AST.

This package defines a transformer to transform markdown AST to editor state and vice versa.
It includes a parser and a serializer.

## Parser

Parser is used to transform from markdown string to UI elements.

### Transform Steps

The transformation will have following steps:

1. The markdown string will be given to [remark-parse](https://github.com/remarkjs/remark/tree/main/packages/remark-parse) to compile into AST.
2. The remark AST will be traversed by milkdown parser. The milkdown parser is generated by the parser property of nodes and marks and generate a prosemirror node tree as the result.
3. The prosemirror node will rendered by prosemirror and generate the UI elements.

### Example

For every node/mark, there will be a parser specification which has the following structure:

```typescript
import { createNode } from '@milkdown/utils';

const myNode = createNode(() => ({
    schema: () => ({
        // other props...
        parseMarkdown: {
            match: (node) => node.type === 'my-node',
            runner: (state, node, type) => {
                state.openNode(type).next(node.children).closeNode();
            },
        },
    }),
}));
```

### Parser Specification

The parser specification has 2 props:

-   _match_: match the target remark node that need to be handled by this runner.

-   _runner_: the function that transform the remark into prosemirror node, it has 3 parameters:

    -   _state_: tools used to generate the prosemirror node.
    -   _node_: the remark node that need to be handled.
    -   _type_: the prosemirror _[nodeType](https://prosemirror.net/docs/ref/#model.NodeType)_ or _[markType](https://prosemirror.net/docs/ref/#model.MarkType)_ of current node,
        defined by `schema` property of current node/mark.

### Parser State

The parser state is used to generate the prosemirror node/mark,
it provides several useful methods to make the transformation pretty simple.

First of all, we should keep in mind that the tree we need to handle has following structure:

```typescript
interface NodeTree {
    type: string;
    children: NodeTree[];
    [x: string]: unknown;
}
```

Then, it's easy to understand our state API.

#### openNode & closeNode

`openNode` method will open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.

You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.

You can pass the node's attributes as the second parameter for `openNode`.

#### addNode

`addNode` means just add a node without open or close it. It's useful for nodes which don't have children, or you want to handle children yourself.

You can pass the node's attributes as the second parameter.

#### next

`next` give the node or node list back to the state and the state will find a proper runner (by checking the `match` property of each node/mark) to handle it.

#### openMark & closeMark

These two APIs are pretty like `openNode` and `closeNode`, but just for prosemirror marks.

You can pass the marks's attributes as the second parameter for `openMark`.

## Serializer

Serializer is used to transform from UI elements to markdown string.

### Transform Steps

The transformation steps are almost opposite to the steps in parser.

1. For the current UI status, there will be a prosemirror node tree to represent it.
2. The prosemirror node tree will be traversed by milkdown serializer. The milkdown serializer is generated by the serializer property of nodes and marks and generate a remark AST as the result.
3. The remark AST will by transformed into markdown string through [remark-stringify](https://github.com/remarkjs/remark/tree/main/packages/remark-stringify).

### Example

For every node, there will be a serializer specification which has the following structure:

```typescript
import { createNode } from '@milkdown/utils';

const MyNode = createNode(() => ({
    schema: () => ({
        // other props...
        toMarkdown: {
            match: (node) => node.type.name === 'my-node',
            runner: (state, node) => {
                state.openNode('my-node').next(node.content).closeNode();
            },
        },
    }),
}));
```

### Serializer Specification

The serializer specification has 2 props:

-   _match_: match the target prosemirror node that need to be handled by this runner.

-   _runner_:

    -   Node runner:
        the function that transform the prosemirror node into remark AST, it has 2 parameters:

        -   _state_: tools used to generate the remark AST.
        -   _node_: the prosemirror node that need to be handled.

    -   Mark runner:
        the function that transform the prosemirror mark into remark AST, it has 3 parameters:

        -   _state_: tools used to generate the remark AST.
        -   _mark_: the prosemirror mark that need to be handled.
        -   _node_: current mark's prosemirror node.

        > If runner for mark return `true` instead of `undefined` or `null`,
        > the mark's node will not be handled by serializer.

### Serializer State

The serializer state is used to generate the remark AST,
it provides several useful methods to make the transformation pretty simple.

#### openNode & closeNode

`openNode` method will open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.

You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.

Parameters:

-   _type_: the type of the AST.
-   _value_: the value of the remark AST.
-   _props_: the properties of the AST.

The props will be spread, for example:

```typescript
openNode('my-node', undefined, { foo: true, bar: 0 });
// will generate:
const generatedCode = {
    type: 'my-node',
    foo: true,
    bar: 0,
    children: [
        /* some children */
    ],
};
```

#### addNode

`addNode` means just add a node without open or close it. It's useful for nodes which don't have content.

Parameters:

-   _type_: the type of the AST.
-   _value_: the value of the remark AST.
-   _props_: the properties of the AST.
-   _children_: a markdown node list as the children of the AST.

#### next

`next` give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.

#### withMark

`withMark` is used when current node has marks, the serializer will auto combine marks nearby.

Parameters:

-   _mark_: the mark of current node.
-   _type_: the type of the AST.
-   _value_: the value of the remark AST.
-   _props_: the properties of the AST.
