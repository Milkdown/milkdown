{"version":3,"file":"index.es.js","sources":["../src/__internal__/with-meta.ts","../src/mark/strike-through.ts","../src/node/table/schema.ts","../src/node/table/utils.ts","../src/node/table/command.ts","../src/node/table/input.ts","../src/node/footnote/definition.ts","../src/node/footnote/reference.ts","../src/node/task-list-item.ts","../src/composed/keymap.ts","../src/composed/inputrules.ts","../src/plugin/auto-insert-span-plugin.ts","../src/plugin/column-resizing-plugin.ts","../src/plugin/table-editing-plugin.ts","../src/plugin/remark-gfm-plugin.ts","../src/plugin/keep-table-align-plugin.ts","../src/composed/plugins.ts","../src/composed/schema.ts","../src/composed/commands.ts","../src/index.ts"],"sourcesContent":["import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n","import { commandsCtx } from '@milkdown/core'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { markRule } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', (ctx) => ({\n  parseDOM: [\n    { tag: 'del' },\n    {\n      style: 'text-decoration',\n      getAttrs: (value) => (value === 'line-through') as false,\n    },\n  ],\n  toDOM: (mark) => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command(\n  'ToggleStrikeThrough',\n  (ctx) => () => {\n    return toggleMark(strikethroughSchema.type(ctx))\n  }\n)\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Input rule to create the strikethrough mark.\nexport const strikethroughInputRule = $inputRule((ctx) => {\n  return markRule(/~([^~]+)~$/, strikethroughSchema.type(ctx))\n})\n\nwithMeta(strikethroughInputRule, {\n  displayName: 'InputRule<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n","import { tableNodes } from '@milkdown/prose/tables'\nimport { $nodeSchema } from '@milkdown/utils'\nimport type { MarkdownNode } from '@milkdown/transformer'\nimport type { NodeType } from '@milkdown/prose/model'\nimport { withMeta } from '../../__internal__'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: (dom) => dom.style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  content: 'table_header_row table_row+',\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine) return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table header row node.\nexport const tableHeaderRowSchema = $nodeSchema('table_header_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_header)*',\n  parseDOM: [{ tag: 'tr[data-is-header]' }],\n  toDOM() {\n    return ['tr', { 'data-is-header': true }, 0]\n  },\n  parseMarkdown: {\n    match: (node) => Boolean(node.type === 'tableRow' && node.isHeader),\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_header_row',\n    runner: (state, node) => {\n      state.openNode('tableRow', undefined, { isHeader: true })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderRowSchema.node, {\n  displayName: 'NodeSchema<tableHeaderRow>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeaderRow>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_cell)*',\n  parseMarkdown: {\n    match: (node) => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_row',\n    runner: (state, node) => {\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: (node) => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n","import type { ContentNodeWithPos } from '@milkdown/prose'\nimport { cloneTr, findParentNodeClosestToPos } from '@milkdown/prose'\nimport type { Node, ResolvedPos } from '@milkdown/prose/model'\nimport type { Selection, Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\nimport type { Ctx } from '@milkdown/ctx'\nimport {\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from './schema'\n\n/// @internal\nexport interface CellPos {\n  pos: number\n  start: number\n  node: Node\n}\n\n/// @internal\nexport function createTable(ctx: Ctx, rowsCount = 3, colsCount = 3): Node {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type(ctx).createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type(ctx).createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) =>\n      i === 0\n        ? tableHeaderRowSchema.type(ctx).create(null, headerCells)\n        : tableRowSchema.type(ctx).create(null, cells)\n    )\n\n  return tableSchema.type(ctx).create(null, rows)\n}\n\n/// Find the table node with position information for target pos.\nexport function findTable($pos: ResolvedPos) {\n  return findParentNodeClosestToPos(\n    (node) => node.type.spec.tableRole === 'table'\n  )($pos)\n}\n\n/// Get cells in a column of a table.\nexport function getCellsInCol(\n  columnIndex: number,\n  selection: Selection\n): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table) return undefined\n  const map = TableMap.get(table.node)\n  if (columnIndex < 0 || columnIndex >= map.width) return undefined\n\n  return map\n    .cellsInRect({\n      left: columnIndex,\n      right: columnIndex + 1,\n      top: 0,\n      bottom: map.height,\n    })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node) return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get cells in a row of a table.\nexport function getCellsInRow(\n  rowIndex: number,\n  selection: Selection\n): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table) return undefined\n  const map = TableMap.get(table.node)\n  if (rowIndex < 0 || rowIndex >= map.height) return undefined\n\n  return map\n    .cellsInRect({\n      left: 0,\n      right: map.width,\n      top: rowIndex,\n      bottom: rowIndex + 1,\n    })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node) return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get all cells in a table.\nexport function getAllCellsInTable(selection: Selection) {\n  const table = findTable(selection.$from)\n  if (!table) return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n\n/// Select a possible table in current selection.\nexport function selectTable(tr: Transaction) {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n\n/// @internal\nexport function addRowWithAlignment(\n  ctx: Ctx,\n  tr: Transaction,\n  { map, tableStart, table }: TableRect,\n  row: number\n) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema\n        .type(ctx)\n        .createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type(ctx).create(null, cells))\n  return tr\n}\n\n/// @internal\nexport function selectLine(type: 'row' | 'col') {\n  return (index: number, pos?: number) => (tr: Transaction) => {\n    pos = pos ?? tr.selection.from\n    const $pos = tr.doc.resolve(pos)\n    const $node = findParentNodeClosestToPos(\n      (node) => node.type.name === 'table'\n    )($pos)\n    const table = $node\n      ? {\n          node: $node.node,\n          from: $node.start,\n        }\n      : undefined\n\n    const isRowSelection = type === 'row'\n    if (table) {\n      const map = TableMap.get(table.node)\n\n      // Check if the index is valid\n      if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n        const lastCell = map.positionAt(\n          isRowSelection ? index : map.height - 1,\n          isRowSelection ? map.width - 1 : index,\n          table.node\n        )\n        const $lastCell = tr.doc.resolve(table.from + lastCell)\n\n        const createCellSelection = isRowSelection\n          ? CellSelection.rowSelection\n          : CellSelection.colSelection\n\n        const firstCell = map.positionAt(\n          isRowSelection ? index : 0,\n          isRowSelection ? 0 : index,\n          table.node\n        )\n        const $firstCell = tr.doc.resolve(table.from + firstCell)\n        return cloneTr(\n          tr.setSelection(\n            createCellSelection($lastCell, $firstCell) as unknown as Selection\n          )\n        )\n      }\n    }\n    return tr\n  }\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n\nfunction transpose<T>(array: T[][]) {\n  return array[0]!.map((_, i) => {\n    return array.map((column) => column[i])\n  }) as T[][]\n}\n\nfunction convertArrayOfRowsToTableNode(\n  tableNode: Node,\n  arrayOfNodes: (Node | null)[][]\n) {\n  const rowsPM = []\n  const map = TableMap.get(tableNode)\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex)\n    const rowCells = []\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex]![colIndex]) continue\n\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n\n      const cell = arrayOfNodes[rowIndex]![colIndex]!\n      const oldCell = tableNode.nodeAt(cellPos)!\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks\n      )\n      rowCells.push(newCell)\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks))\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks\n  )\n\n  return newTable\n}\n\nfunction convertTableNodeToArrayOfRows(tableNode: Node) {\n  const map = TableMap.get(tableNode)\n  const rows: (Node | null)[][] = []\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells: (Node | null)[] = []\n    const seen: Record<number, boolean> = {}\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n      const cell = tableNode.nodeAt(cellPos)\n      const rect = map.findCell(cellPos)\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null)\n        continue\n      }\n      seen[cellPos] = true\n\n      rowCells.push(cell)\n    }\n\n    rows.push(rowCells)\n  }\n\n  return rows\n}\n\nfunction moveRowInArrayOfRows(\n  rows: (Node | null)[][],\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  directionOverride: -1 | 1 | 0\n) {\n  const direction = indexesOrigin[0]! > indexesTarget[0]! ? -1 : 1\n\n  const rowsExtracted = rows.splice(indexesOrigin[0]!, indexesOrigin.length)\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0\n  let target: number\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0]! - 1\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1]! - positionOffset + 1\n  } else {\n    target =\n      direction === -1\n        ? indexesTarget[0]!\n        : indexesTarget[indexesTarget.length - 1]! - positionOffset\n  }\n\n  rows.splice(target, 0, ...rowsExtracted)\n  return rows\n}\n\nfunction moveTableColumn(\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0\n) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node))\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n  rows = transpose(rows)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction moveTableRow(\n  table: ContentNodeWithPos,\n  indexesOrigin: number[],\n  indexesTarget: number[],\n  direction: -1 | 1 | 0\n) {\n  let rows = convertTableNodeToArrayOfRows(table.node)\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction getSelectionRangeInColumn(columnIndex: number, tr: Transaction) {\n  let startIndex = columnIndex\n  let endIndex = columnIndex\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (maybeEndIndex >= startIndex) startIndex = i\n\n        if (maybeEndIndex > endIndex) endIndex = maybeEndIndex\n      })\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInCol(i, tr.selection)\n    if (maybeCells && maybeCells.length) indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedColumnCells = getCellsInCol(startIndex, tr.selection)!\n  const firstRowCells = getCellsInRow(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1]!.pos\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInCol(i, tr.selection)\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j]!.pos === columnCells[0]!.pos) {\n          headCell = columnCells[0]\n          break\n        }\n      }\n      if (headCell) break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nfunction getSelectionRangeInRow(rowIndex: number, tr: Transaction) {\n  let startIndex = rowIndex\n  let endIndex = rowIndex\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (maybeEndIndex >= startIndex) startIndex = i\n\n      if (maybeEndIndex > endIndex) endIndex = maybeEndIndex\n    })\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection)\n    if (maybeCells && maybeCells.length) indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection)!\n  const firstColumnCells = getCellsInCol(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedRowCells[firstSelectedRowCells.length - 1]!.pos\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection)\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j]!.pos === rowCells[0]!.pos) {\n          headCell = rowCells[0]!\n          break\n        }\n      }\n      if (headCell) break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nexport interface MoveColParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the columns at `origin` to `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved column.\nexport function moveCol(moveColParams: MoveColParams) {\n  const { tr, origin, target, select = true, pos } = moveColParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table) return tr\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(origin, tr)\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(target, tr)\n\n  if (indexesOriginColumn.includes(target)) return tr\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  )\n\n  if (!select) return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(map.height - 1, index, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.colSelection\n\n  const firstCell = map.positionAt(0, index, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n\nexport interface MoveRowParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the rows at `origin` and `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved row.\nexport function moveRow(moveRowParams: MoveRowParams) {\n  const { tr, origin, target, select = true, pos } = moveRowParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table) return tr\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(origin, tr)\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(target, tr)\n\n  if (indexesOriginRow.includes(target)) return tr\n\n  const newTable = moveTableRow(table, indexesOriginRow, indexesTargetRow, 0)\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  )\n\n  if (!select) return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(index, map.width - 1, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.rowSelection\n\n  const firstCell = map.positionAt(index, 0, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n","import { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { Selection } from '@milkdown/prose/state'\nimport {\n  CellSelection,\n  addColumnAfter,\n  addColumnBefore,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  goToNextCell,\n  isInTable,\n  selectedRect,\n  setCellAttr,\n} from '@milkdown/prose/tables'\nimport { $command } from '@milkdown/utils'\nimport { findParentNodeType } from '@milkdown/prose'\nimport { withMeta } from '../../__internal__'\nimport {\n  addRowWithAlignment,\n  createTable,\n  moveCol,\n  moveRow,\n  selectCol,\n  selectRow,\n  selectTable,\n} from './utils'\nimport { tableSchema } from './schema'\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command(\n  'GoToPrevTableCell',\n  () => () => goToNextCell(-1)\n)\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command(\n  'GoToNextTableCell',\n  () => () => goToNextCell(1)\n)\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for quitting current table and insert a new paragraph node.\nexport const exitTable = $command(\n  'ExitTable',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n\n    const { $head } = state.selection\n    const table = findParentNodeType($head, tableSchema.type(ctx))\n    if (!table) return false\n\n    const { to } = table\n\n    const tr = state.tr.replaceWith(\n      to,\n      to,\n      paragraphSchema.type(ctx).createAndFill()!\n    )\n\n    tr.setSelection(Selection.near(tr.doc.resolve(to), 1)).scrollIntoView()\n    dispatch?.(tr)\n    return true\n  }\n)\n\nwithMeta(exitTable, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command(\n  'InsertTable',\n  (ctx) =>\n    ({ row, col }: { row?: number; col?: number } = {}) =>\n    (state, dispatch) => {\n      const { selection, tr } = state\n      const { from } = selection\n      const table = createTable(ctx, row, col)\n      const _tr = tr.replaceSelectionWith(table)\n      const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n      if (sel) _tr.setSelection(sel)\n\n      dispatch?.(_tr)\n\n      return true\n    }\n)\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command(\n  'MoveRow',\n  () =>\n    ({ from, to, pos }: { from?: number; to?: number; pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(\n        moveRow({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true })\n      )\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command(\n  'MoveCol',\n  () =>\n    ({ from, to, pos }: { from?: number; to?: number; pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(\n        moveCol({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true })\n      )\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<\n  { index: number; pos?: number },\n  'SelectRow'\n>(\n  'SelectRow',\n  () =>\n    (payload: { index: number; pos?: number } = { index: 0 }) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(selectRow(payload.index, payload.pos)(tr))\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<\n  { index: number; pos?: number },\n  'SelectCol'\n>(\n  'SelectCol',\n  () =>\n    (payload: { index: number; pos?: number } = { index: 0 }) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(selectCol(payload.index, payload.pos)(tr))\n\n      return Boolean(result)\n    }\n)\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command(\n  'SelectTable',\n  () => () => (state, dispatch) => {\n    const { tr } = state\n    const result = dispatch?.(selectTable(tr))\n\n    return Boolean(result)\n  }\n)\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command(\n  'DeleteSelectedCells',\n  () => () => (state, dispatch) => {\n    const { selection } = state\n    if (!(selection instanceof CellSelection)) return false\n\n    const isRow = selection.isRowSelection()\n    const isCol = selection.isColSelection()\n\n    if (isRow && isCol) return deleteTable(state, dispatch)\n\n    if (isCol) return deleteColumn(state, dispatch)\n    else return deleteRow(state, dispatch)\n  }\n)\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command(\n  'AddColBefore',\n  () => () => addColumnBefore\n)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command(\n  'AddColAfter',\n  () => () => addColumnAfter\n)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command(\n  'AddRowBefore',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      const rect = selectedRect(state)\n      dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.top))\n    }\n    return true\n  }\n)\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command(\n  'AddRowAfter',\n  (ctx) => () => (state, dispatch) => {\n    if (!isInTable(state)) return false\n    if (dispatch) {\n      const rect = selectedRect(state)\n      dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.bottom))\n    }\n    return true\n  }\n)\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<\n  'left' | 'center' | 'right',\n  'SetAlign'\n>(\n  'SetAlign',\n  () =>\n    (alignment = 'left') =>\n      setCellAttr('alignment', alignment)\n)\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { TextSelection } from '@milkdown/prose/state'\nimport { $inputRule, $useKeymap } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\nimport { createTable } from './utils'\nimport { tableSchema } from './schema'\nimport {\n  exitTable,\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n} from './command'\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(\n  (ctx) =>\n    new InputRule(\n      /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/,\n      (state, match, start, end) => {\n        const $start = state.doc.resolve(start)\n        if (\n          !$start\n            .node(-1)\n            .canReplaceWith(\n              $start.index(-1),\n              $start.indexAfter(-1),\n              tableSchema.type(ctx)\n            )\n        )\n          return null\n\n        const tableNode = createTable(\n          ctx,\n          Number(match.groups?.row),\n          Number(match.groups?.col)\n        )\n        const tr = state.tr.replaceRangeWith(start, end, tableNode)\n        return tr\n          .setSelection(TextSelection.create(tr.doc, start + 3))\n          .scrollIntoView()\n      }\n    )\n)\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(exitTable.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema(\n  'footnote_definition',\n  () => ({\n    group: 'block',\n    content: 'block+',\n    defining: true,\n    attrs: {\n      label: {\n        default: '',\n      },\n    },\n    parseDOM: [\n      {\n        tag: `dl[data-type=\"${id}\"]`,\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            label: dom.dataset.label,\n          }\n        },\n        contentElement: 'dd',\n      },\n    ],\n    toDOM: (node) => {\n      const label = node.attrs.label\n\n      return [\n        'dl',\n        {\n          // TODO: add a prosemirror plugin to sync label on change\n          'data-label': label,\n          'data-type': id,\n        },\n        ['dt', label],\n        ['dd', 0],\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === markdownId,\n      runner: (state, node, type) => {\n        state\n          .openNode(type, {\n            label: node.label as string,\n          })\n          .next(node.children)\n          .closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === id,\n      runner: (state, node) => {\n        state\n          .openNode(markdownId, undefined, {\n            label: node.attrs.label,\n            identifier: node.attrs.label,\n          })\n          .next(node.content)\n          .closeNode()\n      },\n    },\n  })\n)\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema(\n  'footnote_reference',\n  () => ({\n    group: 'inline',\n    inline: true,\n    atom: true,\n    attrs: {\n      label: {\n        default: '',\n      },\n    },\n    parseDOM: [\n      {\n        tag: `sup[data-type=\"${id}\"]`,\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            label: dom.dataset.label,\n          }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      const label = node.attrs.label\n      return [\n        'sup',\n        {\n          // TODO: add a prosemirror plugin to sync label on change\n          'data-label': label,\n          'data-type': id,\n        },\n        label,\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'footnoteReference',\n      runner: (state, node, type) => {\n        state.addNode(type, {\n          label: node.label as string,\n        })\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === id,\n      runner: (state, node) => {\n        state.addNode('footnoteReference', undefined, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n      },\n    },\n  })\n)\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema(\n  (prev) => {\n    return (ctx) => {\n      const baseSchema = prev(ctx)\n      return {\n        ...baseSchema,\n        attrs: {\n          ...baseSchema.attrs,\n          checked: {\n            default: null,\n          },\n        },\n        parseDOM: [\n          {\n            tag: 'li[data-item-type=\"task\"]',\n            getAttrs: (dom) => {\n              if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n              return {\n                label: dom.dataset.label,\n                listType: dom.dataset.listType,\n                spread: dom.dataset.spread,\n                checked: dom.dataset.checked\n                  ? dom.dataset.checked === 'true'\n                  : null,\n              }\n            },\n          },\n          ...(baseSchema?.parseDOM || []),\n        ],\n        toDOM: (node) => {\n          if (baseSchema.toDOM && node.attrs.checked == null)\n            return baseSchema.toDOM(node)\n\n          return [\n            'li',\n            {\n              'data-item-type': 'task',\n              'data-label': node.attrs.label,\n              'data-list-type': node.attrs.listType,\n              'data-spread': node.attrs.spread,\n              'data-checked': node.attrs.checked,\n            },\n            0,\n          ]\n        },\n        parseMarkdown: {\n          match: ({ type }) => type === 'listItem',\n          runner: (state, node, type) => {\n            if (node.checked == null) {\n              baseSchema.parseMarkdown.runner(state, node, type)\n              return\n            }\n\n            const label = node.label != null ? `${node.label}.` : '•'\n            const checked = node.checked != null ? Boolean(node.checked) : null\n            const listType = node.label != null ? 'ordered' : 'bullet'\n            const spread = node.spread != null ? `${node.spread}` : 'true'\n\n            state.openNode(type, { label, listType, spread, checked })\n            state.next(node.children)\n            state.closeNode()\n          },\n        },\n        toMarkdown: {\n          match: (node) => node.type.name === 'list_item',\n          runner: (state, node) => {\n            if (node.attrs.checked == null) {\n              baseSchema.toMarkdown.runner(state, node)\n              return\n            }\n\n            const label = node.attrs.label\n            const listType = node.attrs.listType\n            const spread = node.attrs.spread === 'true'\n            const checked = node.attrs.checked\n\n            state.openNode('listItem', undefined, {\n              label,\n              listType,\n              spread,\n              checked,\n            })\n            state.next(node.content)\n            state.closeNode()\n          },\n        },\n      }\n    }\n  }\n)\n\nwithMeta(extendListItemSchemaForTask, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(\n    /^\\[(?<checked>\\s|x)\\]\\s$/,\n    (state, match, start, end) => {\n      const pos = state.doc.resolve(start)\n      let depth = 0\n      let node = pos.node(depth)\n      while (node && node.type.name !== 'list_item') {\n        depth--\n        node = pos.node(depth)\n      }\n\n      if (!node || node.attrs.checked != null) return null\n\n      const checked = Boolean(match.groups?.checked === 'x')\n\n      const finPos = pos.before(depth)\n      const tr = state.tr\n\n      tr.deleteRange(start, end).setNodeMarkup(finPos, undefined, {\n        ...node.attrs,\n        checked,\n      })\n\n      return tr\n    }\n  )\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\nimport { strikethroughInputRule } from '../mark'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n\nexport const markInputRules: MilkdownPlugin[] = [strikethroughInputRule]\n","import { $prose } from '@milkdown/utils'\nimport { imeSpan } from 'prosemirror-safari-ime-span'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertSpanPlugin = $prose(() => imeSpan)\n\nwithMeta(autoInsertSpanPlugin, {\n  displayName: 'Prose<autoInsertSpanPlugin>',\n  group: 'Prose',\n})\n","import { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n","import { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() =>\n  tableEditing({ allowTableNodeSelection: true })\n)\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n","import type { $Remark } from '@milkdown/utils'\nimport { $remark } from '@milkdown/utils'\nimport type { Options } from 'remark-gfm'\nimport remarkGFM from 'remark-gfm'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin: $Remark<'remarkGFM', Options | null | undefined> =\n  $remark('remarkGFM', () => remarkGFM)\n\nwithMeta(remarkGFMPlugin.plugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkGFMPlugin.options, {\n  displayName: 'RemarkConfig<remarkGFMPlugin>',\n  group: 'Remark',\n})\n","import type { Transaction } from '@milkdown/prose/state'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { Node } from '@milkdown/prose/model'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\nconst pluginKey = new PluginKey('MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN')\n\nfunction getChildIndex(node: Node, parent: Node) {\n  let index = 0\n  parent.forEach((child, _offset, i) => {\n    if (child === node) index = i\n  })\n  return index\n}\n\nexport const keepTableAlignPlugin = $prose(() => {\n  return new Plugin({\n    key: pluginKey,\n    appendTransaction: (_tr, oldState, state) => {\n      let tr: Transaction | undefined\n      const check = (node: Node, pos: number) => {\n        if (!tr) tr = state.tr\n\n        if (node.type.name !== 'table_cell') return\n\n        const $pos = state.doc.resolve(pos)\n        const tableRow = $pos.node($pos.depth)\n        const table = $pos.node($pos.depth - 1)\n        const tableHeaderRow = table.firstChild\n        // TODO: maybe consider add a header row\n        if (!tableHeaderRow) return\n\n        const index = getChildIndex(node, tableRow)\n        const headerCell = tableHeaderRow.maybeChild(index)\n        if (!headerCell) return\n        const align = headerCell.attrs.alignment\n        const currentAlign = node.attrs.alignment\n        if (align === currentAlign) return\n\n        tr.setNodeMarkup(pos, undefined, { ...node.attrs, alignment: align })\n      }\n      if (oldState.doc !== state.doc) state.doc.descendants(check)\n\n      return tr\n    },\n  })\n})\n\nwithMeta(keepTableAlignPlugin, {\n  displayName: 'Prose<keepTableAlignPlugin>',\n  group: 'Prose',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  autoInsertSpanPlugin,\n  keepTableAlignPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  keepTableAlignPlugin,\n  autoInsertSpanPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport {\n  extendListItemSchemaForTask,\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableHeaderRowSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n","import { toggleStrikethroughCommand } from '../mark'\nimport {\n  addColAfterCommand,\n  addColBeforeCommand,\n  addRowAfterCommand,\n  addRowBeforeCommand,\n  deleteSelectedCellsCommand,\n  exitTable,\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  insertTableCommand,\n  moveColCommand,\n  moveRowCommand,\n  selectColCommand,\n  selectRowCommand,\n  selectTableCommand,\n  setAlignCommand,\n} from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  exitTable,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n","import {\n  commands,\n  inputRules,\n  keymap,\n  markInputRules,\n  plugins,\n  schema,\n} from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [\n  schema,\n  inputRules,\n  markInputRules,\n  keymap,\n  commands,\n  plugins,\n].flat()\n"],"names":["withMeta","plugin","meta","strikethroughAttr","$markAttr","strikethroughSchema","$markSchema","ctx","value","mark","node","state","markType","toggleStrikethroughCommand","$command","toggleMark","strikethroughInputRule","$inputRule","markRule","strikethroughKeymap","$useKeymap","commands","commandsCtx","originalSchema","tableNodes","dom","attrs","tableSchema","$nodeSchema","type","align","children","x","i","firstLine","_a","cell","tableHeaderRowSchema","tableRowSchema","tableCellSchema","tableHeaderSchema","createTable","rowsCount","colsCount","cells","headerCells","rows","_","findTable","$pos","findParentNodeClosestToPos","getCellsInCol","columnIndex","selection","table","map","TableMap","pos","start","getCellsInRow","rowIndex","getAllCellsInTable","nodePos","selectTable","tr","$firstCell","last","$lastCell","cloneTr","CellSelection","addRowWithAlignment","tableStart","row","rowPos","acc","col","headerCol","selectLine","index","$node","isRowSelection","lastCell","createCellSelection","firstCell","selectRow","selectCol","transpose","array","column","convertArrayOfRowsToTableNode","tableNode","arrayOfNodes","rowsPM","rowCells","colIndex","cellPos","newCell","convertTableNodeToArrayOfRows","seen","rect","moveRowInArrayOfRows","indexesOrigin","indexesTarget","directionOverride","direction","rowsExtracted","positionOffset","target","moveTableColumn","moveTableRow","getSelectionRangeInColumn","startIndex","endIndex","maybeEndIndex","indexes","maybeCells","firstSelectedColumnCells","firstRowCells","$anchor","headCell","columnCells","j","$head","getSelectionRangeInRow","firstSelectedRowCells","firstColumnCells","moveCol","moveColParams","origin","select","indexesOriginColumn","indexesTargetColumn","newTable","_tr","moveRow","moveRowParams","indexesOriginRow","indexesTargetRow","goToPrevTableCellCommand","goToNextCell","goToNextTableCellCommand","exitTable","dispatch","isInTable","findParentNodeType","to","paragraphSchema","Selection","insertTableCommand","from","sel","moveRowCommand","moveColCommand","selectRowCommand","payload","selectColCommand","selectTableCommand","deleteSelectedCellsCommand","isRow","isCol","deleteTable","deleteColumn","deleteRow","addColBeforeCommand","addColumnBefore","addColAfterCommand","addColumnAfter","addRowBeforeCommand","selectedRect","addRowAfterCommand","setAlignCommand","alignment","setCellAttr","insertTableInputRule","InputRule","match","end","$start","_b","TextSelection","tableKeymap","id","markdownId","footnoteDefinitionSchema","expectDomTypeError","label","footnoteReferenceSchema","extendListItemSchemaForTask","listItemSchema","prev","baseSchema","checked","listType","spread","wrapInTaskListInputRule","depth","finPos","keymap","inputRules","markInputRules","autoInsertSpanPlugin","$prose","imeSpan","columnResizingPlugin","columnResizing","tableEditingPlugin","tableEditing","remarkGFMPlugin","$remark","remarkGFM","pluginKey","PluginKey","getChildIndex","parent","child","_offset","keepTableAlignPlugin","Plugin","oldState","check","tableRow","tableHeaderRow","headerCell","currentAlign","plugins","schema","gfm"],"mappings":";;;;;;;;;;;AAEgB,SAAAA,EACdC,GACAC,GACG;AACH,gBAAO,OAAOD,GAAQ;AAAA,IACpB,MAAM;AAAA,MACJ,SAAS;AAAA,MACT,GAAGC;AAAA,IAAA;AAAA,EACL,CACD,GAEMD;AACT;ACDa,MAAAE,IAAoBC,GAAU,gBAAgB;AAE3DJ,EAASG,GAAmB;AAAA,EAC1B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAME,IAAsBC,GAAY,kBAAkB,CAACC,OAAS;AAAA,EACzE,UAAU;AAAA,IACR,EAAE,KAAK,MAAM;AAAA,IACb;AAAA,MACE,OAAO;AAAA,MACP,UAAU,CAACC,MAAWA,MAAU;AAAA,IAAA;AAAA,EAEpC;AAAA,EACA,OAAO,CAACC,MAAS,CAAC,OAAOF,EAAI,IAAIJ,EAAkB,GAAG,EAAEM,CAAI,CAAC;AAAA,EAC7D,eAAe;AAAA,IACb,OAAO,CAACC,MAASA,EAAK,SAAS;AAAA,IAC/B,QAAQ,CAACC,GAAOD,GAAME,MAAa;AACjC,MAAAD,EAAM,SAASC,CAAQ,GACjBD,EAAA,KAAKD,EAAK,QAAQ,GACxBC,EAAM,UAAUC,CAAQ;AAAA,IAAA;AAAA,EAE5B;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAACH,MAASA,EAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAACE,GAAOF,MAAS;AACjB,MAAAE,EAAA,SAASF,GAAM,QAAQ;AAAA,IAAA;AAAA,EAC/B;AAEJ,EAAE;AAEFT,EAASK,EAAoB,MAAM;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDL,EAASK,EAAoB,KAAK;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAMQ,IAA6BC;AAAA,EACxC;AAAA,EACA,CAACP,MAAQ,MACAQ,GAAWV,EAAoB,KAAKE,CAAG,CAAC;AAEnD;AAEAP,EAASa,GAA4B;AAAA,EACnC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAAG,KAAyBC,EAAW,CAACV,MACzCW,GAAS,cAAcb,EAAoB,KAAKE,CAAG,CAAC,CAC5D;AAEDP,EAASgB,IAAwB;AAAA,EAC/B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIY,MAAAG,IAAsBC,GAAW,uBAAuB;AAAA,EACnE,qBAAqB;AAAA,IACnB,WAAW;AAAA,IACX,SAAS,CAACb,MAAQ;AACV,YAAAc,IAAWd,EAAI,IAAIe,CAAW;AACpC,aAAO,MAAMD,EAAS,KAAKR,EAA2B,GAAG;AAAA,IAAA;AAAA,EAC3D;AAEJ,CAAC;AAEDb,EAASmB,EAAoB,KAAK;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDnB,EAASmB,EAAoB,WAAW;AAAA,EACtC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC7FD,MAAMI,IAAiBC,GAAW;AAAA,EAChC,YAAY;AAAA,EACZ,aAAa;AAAA,EACb,gBAAgB;AAAA,IACd,WAAW;AAAA,MACT,SAAS;AAAA,MACT,YAAY,CAACC,MAAQA,EAAI,MAAM,aAAa;AAAA,MAC5C,YAAY,CAACjB,GAAOkB,MAAU;AACtB,QAAAA,EAAA,QAAQ,eAAelB,KAAS,MAAM;AAAA,MAAA;AAAA,IAC9C;AAAA,EACF;AAEJ,CAAC,GAGYmB,IAAcC,EAAY,SAAS,OAAO;AAAA,EACrD,GAAGL,EAAe;AAAA,EAClB,SAAS;AAAA,EACT,mBAAmB;AAAA,EACnB,eAAe;AAAA,IACb,OAAO,CAACb,MAASA,EAAK,SAAS;AAAA,IAC/B,QAAQ,CAACC,GAAOD,GAAMmB,MAAS;AAC7B,YAAMC,IAAQpB,EAAK,OACbqB,IAAYrB,EAAK,SAA4B,IAAI,CAACsB,GAAGC,OAAO;AAAA,QAChE,GAAGD;AAAA,QACH,OAAAF;AAAA,QACA,UAAUG,MAAM;AAAA,MAAA,EAChB;AACF,MAAAtB,EAAM,SAASkB,CAAI,GACnBlB,EAAM,KAAKoB,CAAQ,GACnBpB,EAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAACD,MAASA,EAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAACC,GAAOD,MAAS;;AACjB,YAAAwB,KAAYC,IAAAzB,EAAK,QAAQ,eAAb,gBAAAyB,EAAyB;AAC3C,UAAI,CAACD,EAAW;AAEhB,YAAMJ,IAA2B,CAAC;AACxB,MAAAI,EAAA,QAAQ,CAACE,MAAS;AACpB,QAAAN,EAAA,KAAKM,EAAK,MAAM,SAAS;AAAA,MAAA,CAChC,GACDzB,EAAM,SAAS,SAAS,QAAW,EAAE,OAAAmB,GAAO,GACtCnB,EAAA,KAAKD,EAAK,OAAO,GACvBC,EAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEFX,EAAS2B,EAAY,MAAM;AAAA,EACzB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED3B,EAAS2B,EAAY,KAAK;AAAA,EACxB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAAU,IAAuBT,EAAY,oBAAoB,OAAO;AAAA,EACzE,GAAGL,EAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,SAAS;AAAA,EACT,UAAU,CAAC,EAAE,KAAK,sBAAsB;AAAA,EACxC,QAAQ;AACN,WAAO,CAAC,MAAM,EAAE,kBAAkB,GAAA,GAAQ,CAAC;AAAA,EAC7C;AAAA,EACA,eAAe;AAAA,IACb,OAAO,CAACb,MAAS,GAAQA,EAAK,SAAS,cAAcA,EAAK;AAAA,IAC1D,QAAQ,CAACC,GAAOD,GAAMmB,MAAS;AAC7B,YAAMC,IAAQpB,EAAK,OACbqB,IAAYrB,EAAK,SAA4B,IAAI,CAACsB,GAAGC,OAAO;AAAA,QAChE,GAAGD;AAAA,QACH,OAAOF,EAAMG,CAAC;AAAA,QACd,UAAUvB,EAAK;AAAA,MAAA,EACf;AACF,MAAAC,EAAM,SAASkB,CAAI,GACnBlB,EAAM,KAAKoB,CAAQ,GACnBpB,EAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAACD,MAASA,EAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAACC,GAAOD,MAAS;AACvB,MAAAC,EAAM,SAAS,YAAY,QAAW,EAAE,UAAU,IAAM,GAClDA,EAAA,KAAKD,EAAK,OAAO,GACvBC,EAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEFX,EAASqC,EAAqB,MAAM;AAAA,EAClC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDrC,EAASqC,EAAqB,KAAK;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAAC,IAAiBV,EAAY,aAAa,OAAO;AAAA,EAC5D,GAAGL,EAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,SAAS;AAAA,EACT,eAAe;AAAA,IACb,OAAO,CAACb,MAASA,EAAK,SAAS;AAAA,IAC/B,QAAQ,CAACC,GAAOD,GAAMmB,MAAS;AAC7B,YAAMC,IAAQpB,EAAK,OACbqB,IAAYrB,EAAK,SAA4B,IAAI,CAACsB,GAAGC,OAAO;AAAA,QAChE,GAAGD;AAAA,QACH,OAAOF,EAAMG,CAAC;AAAA,MAAA,EACd;AACF,MAAAtB,EAAM,SAASkB,CAAI,GACnBlB,EAAM,KAAKoB,CAAQ,GACnBpB,EAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAACD,MAASA,EAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAACC,GAAOD,MAAS;AACvB,MAAAC,EAAM,SAAS,UAAU,GACnBA,EAAA,KAAKD,EAAK,OAAO,GACvBC,EAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEFX,EAASsC,EAAe,MAAM;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDtC,EAASsC,EAAe,KAAK;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAAC,IAAkBX,EAAY,cAAc,OAAO;AAAA,EAC9D,GAAGL,EAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,eAAe;AAAA,IACb,OAAO,CAACb,MAASA,EAAK,SAAS,eAAe,CAACA,EAAK;AAAA,IACpD,QAAQ,CAACC,GAAOD,GAAMmB,MAAS;AAC7B,YAAMC,IAAQpB,EAAK;AACnB,MAAAC,EACG,SAASkB,GAAM,EAAE,WAAWC,EAAO,CAAA,EACnC,SAASnB,EAAM,OAAO,MAAM,SAAqB,EACjD,KAAKD,EAAK,QAAQ,EAClB,YACA,UAAU;AAAA,IAAA;AAAA,EAEjB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAACA,MAASA,EAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAACC,GAAOD,MAAS;AACvB,MAAAC,EAAM,SAAS,WAAW,EAAE,KAAKD,EAAK,OAAO,EAAE,UAAU;AAAA,IAAA;AAAA,EAC3D;AAEJ,EAAE;AAEFV,EAASuC,EAAgB,MAAM;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDvC,EAASuC,EAAgB,KAAK;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGY,MAAAC,IAAoBZ,EAAY,gBAAgB,OAAO;AAAA,EAClE,GAAGL,EAAe;AAAA,EAClB,mBAAmB;AAAA,EACnB,eAAe;AAAA,IACb,OAAO,CAACb,MAASA,EAAK,SAAS,eAAe,CAAC,CAACA,EAAK;AAAA,IACrD,QAAQ,CAACC,GAAOD,GAAMmB,MAAS;AAC7B,YAAMC,IAAQpB,EAAK;AACnB,MAAAC,EAAM,SAASkB,GAAM,EAAE,WAAWC,GAAO,GACzCnB,EAAM,SAASA,EAAM,OAAO,MAAM,SAAqB,GACjDA,EAAA,KAAKD,EAAK,QAAQ,GACxBC,EAAM,UAAU,GAChBA,EAAM,UAAU;AAAA,IAAA;AAAA,EAEpB;AAAA,EACA,YAAY;AAAA,IACV,OAAO,CAACD,MAASA,EAAK,KAAK,SAAS;AAAA,IACpC,QAAQ,CAACC,GAAOD,MAAS;AACvB,MAAAC,EAAM,SAAS,WAAW,GACpBA,EAAA,KAAKD,EAAK,OAAO,GACvBC,EAAM,UAAU;AAAA,IAAA;AAAA,EAClB;AAEJ,EAAE;AAEFX,EAASwC,EAAkB,MAAM;AAAA,EAC/B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDxC,EAASwC,EAAkB,KAAK;AAAA,EAC9B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC9LM,SAASC,GAAYlC,GAAUmC,IAAY,GAAGC,IAAY,GAAS;AACxE,QAAMC,IAAQ,MAAMD,CAAS,EAC1B,KAAK,CAAC,EACN,IAAI,MAAMJ,EAAgB,KAAKhC,CAAG,EAAE,eAAgB,GAEjDsC,IAAc,MAAMF,CAAS,EAChC,KAAK,CAAC,EACN,IAAI,MAAMH,EAAkB,KAAKjC,CAAG,EAAE,eAAgB,GAEnDuC,IAAO,MAAMJ,CAAS,EACzB,KAAK,CAAC,EACN;AAAA,IAAI,CAACK,GAAGd,MACPA,MAAM,IACFI,EAAqB,KAAK9B,CAAG,EAAE,OAAO,MAAMsC,CAAW,IACvDP,EAAe,KAAK/B,CAAG,EAAE,OAAO,MAAMqC,CAAK;AAAA,EACjD;AAEF,SAAOjB,EAAY,KAAKpB,CAAG,EAAE,OAAO,MAAMuC,CAAI;AAChD;AAGO,SAASE,EAAUC,GAAmB;AACpC,SAAAC;AAAA,IACL,CAACxC,MAASA,EAAK,KAAK,KAAK,cAAc;AAAA,IACvCuC,CAAI;AACR;AAGgB,SAAAE,EACdC,GACAC,GACuB;AACjB,QAAAC,IAAQN,EAAUK,EAAU,KAAK;AACnC,MAAA,CAACC,EAAc;AACnB,QAAMC,IAAMC,EAAS,IAAIF,EAAM,IAAI;AACnC,MAAI,EAAAF,IAAc,KAAKA,KAAeG,EAAI;AAE1C,WAAOA,EACJ,YAAY;AAAA,MACX,MAAMH;AAAA,MACN,OAAOA,IAAc;AAAA,MACrB,KAAK;AAAA,MACL,QAAQG,EAAI;AAAA,IAAA,CACb,EACA,IAAI,CAACE,MAAQ;AACZ,YAAM/C,IAAO4C,EAAM,KAAK,OAAOG,CAAG;AAC9B,UAAA,CAAC/C,EAAa;AACZ,YAAAgD,IAAQD,IAAMH,EAAM;AACnB,aAAA;AAAA,QACL,KAAKI;AAAA,QACL,OAAOA,IAAQ;AAAA,QACf,MAAAhD;AAAA,MACF;AAAA,IACD,CAAA,EACA,OAAO,CAACsB,MAAoBA,KAAK,IAAI;AAC1C;AAGgB,SAAA2B,EACdC,GACAP,GACuB;AACjB,QAAAC,IAAQN,EAAUK,EAAU,KAAK;AACnC,MAAA,CAACC,EAAc;AACnB,QAAMC,IAAMC,EAAS,IAAIF,EAAM,IAAI;AACnC,MAAI,EAAAM,IAAW,KAAKA,KAAYL,EAAI;AAEpC,WAAOA,EACJ,YAAY;AAAA,MACX,MAAM;AAAA,MACN,OAAOA,EAAI;AAAA,MACX,KAAKK;AAAA,MACL,QAAQA,IAAW;AAAA,IAAA,CACpB,EACA,IAAI,CAACH,MAAQ;AACZ,YAAM/C,IAAO4C,EAAM,KAAK,OAAOG,CAAG;AAC9B,UAAA,CAAC/C,EAAa;AACZ,YAAAgD,IAAQD,IAAMH,EAAM;AACnB,aAAA;AAAA,QACL,KAAKI;AAAA,QACL,OAAOA,IAAQ;AAAA,QACf,MAAAhD;AAAA,MACF;AAAA,IACD,CAAA,EACA,OAAO,CAACsB,MAAoBA,KAAK,IAAI;AAC1C;AAGO,SAAS6B,GAAmBR,GAAsB;AACjD,QAAAC,IAAQN,EAAUK,EAAU,KAAK;AACvC,MAAI,CAACC,EAAO;AAEZ,QAAMC,IAAMC,EAAS,IAAIF,EAAM,IAAI;AAO5B,SANOC,EAAI,YAAY;AAAA,IAC5B,MAAM;AAAA,IACN,OAAOA,EAAI;AAAA,IACX,KAAK;AAAA,IACL,QAAQA,EAAI;AAAA,EAAA,CACb,EACY,IAAI,CAACO,MAAY;AAC5B,UAAMpD,IAAO4C,EAAM,KAAK,OAAOQ,CAAO,GAChCL,IAAMK,IAAUR,EAAM;AAC5B,WAAO,EAAE,KAAAG,GAAK,OAAOA,IAAM,GAAG,MAAA/C,EAAK;AAAA,EAAA,CACpC;AACH;AAGO,SAASqD,GAAYC,GAAiB;AACrC,QAAApB,IAAQiB,GAAmBG,EAAG,SAAS;AACzC,MAAApB,KAASA,EAAM,CAAC,GAAG;AACrB,UAAMqB,IAAaD,EAAG,IAAI,QAAQpB,EAAM,CAAC,EAAE,GAAG,GACxCsB,IAAOtB,EAAMA,EAAM,SAAS,CAAC;AACnC,QAAIsB,GAAM;AACR,YAAMC,IAAYH,EAAG,IAAI,QAAQE,EAAK,GAAG;AAClC,aAAAE,EAAQJ,EAAG,aAAa,IAAIK,EAAcF,GAAWF,CAAU,CAAC,CAAC;AAAA,IAAA;AAAA,EAC1E;AAEK,SAAAD;AACT;AAGgB,SAAAM,GACd/D,GACAyD,GACA,EAAE,KAAAT,GAAK,YAAAgB,GAAY,OAAAjB,KACnBkB,GACA;AACM,QAAAC,IAAS,MAAMD,CAAG,EACrB,KAAK,CAAC,EACN,OAAO,CAACE,GAAK3B,GAAGd,MACRyC,IAAMpB,EAAM,MAAMrB,CAAC,EAAE,UAC3BsC,CAAU,GAET3B,IAAQ,MAAMW,EAAI,KAAK,EAC1B,KAAK,CAAC,EACN,IAAI,CAACR,GAAG4B,MAAQ;AACf,UAAMC,IAAYtB,EAAM,OAAOC,EAAI,IAAIoB,CAAG,CAAW;AAC9C,WAAApC,EACJ,KAAKhC,CAAG,EACR,cAAc,EAAE,WAAWqE,KAAA,gBAAAA,EAAW,MAAM,WAAW;AAAA,EAAA,CAC3D;AAEA,SAAAZ,EAAA,OAAOS,GAAQnC,EAAe,KAAK/B,CAAG,EAAE,OAAO,MAAMqC,CAAK,CAAC,GACvDoB;AACT;AAGO,SAASa,GAAWhD,GAAqB;AAC9C,SAAO,CAACiD,GAAerB,MAAiB,CAACO,MAAoB;AACrD,IAAAP,IAAAA,KAAOO,EAAG,UAAU;AAC1B,UAAMf,IAAOe,EAAG,IAAI,QAAQP,CAAG,GACzBsB,IAAQ7B;AAAA,MACZ,CAACxC,MAASA,EAAK,KAAK,SAAS;AAAA,MAC7BuC,CAAI,GACAK,IAAQyB,IACV;AAAA,MACE,MAAMA,EAAM;AAAA,MACZ,MAAMA,EAAM;AAAA,IAEd,IAAA,QAEEC,IAAiBnD,MAAS;AAChC,QAAIyB,GAAO;AACT,YAAMC,IAAMC,EAAS,IAAIF,EAAM,IAAI;AAGnC,UAAIwB,KAAS,KAAKA,KAASE,IAAiBzB,EAAI,SAASA,EAAI,QAAQ;AACnE,cAAM0B,IAAW1B,EAAI;AAAA,UACnByB,IAAiBF,IAAQvB,EAAI,SAAS;AAAA,UACtCyB,IAAiBzB,EAAI,QAAQ,IAAIuB;AAAA,UACjCxB,EAAM;AAAA,QACR,GACMa,IAAYH,EAAG,IAAI,QAAQV,EAAM,OAAO2B,CAAQ,GAEhDC,IAAsBF,IACxBX,EAAc,eACdA,EAAc,cAEZc,IAAY5B,EAAI;AAAA,UACpByB,IAAiBF,IAAQ;AAAA,UACzBE,IAAiB,IAAIF;AAAA,UACrBxB,EAAM;AAAA,QACR,GACMW,IAAaD,EAAG,IAAI,QAAQV,EAAM,OAAO6B,CAAS;AACjD,eAAAf;AAAA,UACLJ,EAAG;AAAA,YACDkB,EAAoBf,GAAWF,CAAU;AAAA,UAAA;AAAA,QAE7C;AAAA,MAAA;AAAA,IACF;AAEK,WAAAD;AAAA,EACT;AACF;AAIa,MAAAoB,KAAYP,GAAW,KAAK,GAI5BQ,KAAYR,GAAW,KAAK;AAEzC,SAASS,EAAaC,GAAc;AAClC,SAAOA,EAAM,CAAC,EAAG,IAAI,CAACxC,GAAGd,MAChBsD,EAAM,IAAI,CAACC,MAAWA,EAAOvD,CAAC,CAAC,CACvC;AACH;AAEA,SAASwD,GACPC,GACAC,GACA;AACA,QAAMC,IAAS,CAAC,GACVrC,IAAMC,EAAS,IAAIkC,CAAS;AAClC,WAAS9B,IAAW,GAAGA,IAAWL,EAAI,QAAQK,KAAY;AAClD,UAAAY,IAAMkB,EAAU,MAAM9B,CAAQ,GAC9BiC,IAAW,CAAC;AAElB,aAASC,IAAW,GAAGA,IAAWvC,EAAI,OAAOuC,KAAY;AACvD,UAAI,CAACH,EAAa/B,CAAQ,EAAGkC,CAAQ,EAAG;AAExC,YAAMC,IAAUxC,EAAI,IAAIK,IAAWL,EAAI,QAAQuC,CAAQ,GAEjD1D,IAAOuD,EAAa/B,CAAQ,EAAGkC,CAAQ,GAEvCE,IADUN,EAAU,OAAOK,CAAO,EAChB,KAAK;AAAA,QAC3B,OAAO,OAAO,IAAI3D,EAAK,KAAK;AAAA,QAC5BA,EAAK;AAAA,QACLA,EAAK;AAAA,MACP;AACA,MAAAyD,EAAS,KAAKG,CAAO;AAAA,IAAA;AAGhB,IAAAJ,EAAA,KAAKpB,EAAI,KAAK,cAAcA,EAAI,OAAOqB,GAAUrB,EAAI,KAAK,CAAC;AAAA,EAAA;AAS7D,SANUkB,EAAU,KAAK;AAAA,IAC9BA,EAAU;AAAA,IACVE;AAAA,IACAF,EAAU;AAAA,EACZ;AAGF;AAEA,SAASO,GAA8BP,GAAiB;AAChD,QAAAnC,IAAMC,EAAS,IAAIkC,CAAS,GAC5B5C,IAA0B,CAAC;AACjC,WAASc,IAAW,GAAGA,IAAWL,EAAI,QAAQK,KAAY;AACxD,UAAMiC,IAA4B,CAAC,GAC7BK,IAAgC,CAAC;AAEvC,aAASJ,IAAW,GAAGA,IAAWvC,EAAI,OAAOuC,KAAY;AACvD,YAAMC,IAAUxC,EAAI,IAAIK,IAAWL,EAAI,QAAQuC,CAAQ,GACjD1D,IAAOsD,EAAU,OAAOK,CAAO,GAC/BI,IAAO5C,EAAI,SAASwC,CAAO;AACjC,UAAIG,EAAKH,CAAO,KAAKI,EAAK,QAAQvC,GAAU;AAC1C,QAAAiC,EAAS,KAAK,IAAI;AAClB;AAAA,MAAA;AAEF,MAAAK,EAAKH,CAAO,IAAI,IAEhBF,EAAS,KAAKzD,CAAI;AAAA,IAAA;AAGpB,IAAAU,EAAK,KAAK+C,CAAQ;AAAA,EAAA;AAGb,SAAA/C;AACT;AAEA,SAASsD,GACPtD,GACAuD,GACAC,GACAC,GACA;AACA,QAAMC,IAAYH,EAAc,CAAC,IAAKC,EAAc,CAAC,IAAK,KAAK,GAEzDG,IAAgB3D,EAAK,OAAOuD,EAAc,CAAC,GAAIA,EAAc,MAAM,GACnEK,IAAiBD,EAAc,SAAS,MAAM,IAAI,IAAI;AACxD,MAAAE;AAQA,SAAAA,IAAAH,MAAc,KACVF,EAAc,CAAC,IACfA,EAAcA,EAAc,SAAS,CAAC,IAAKI,GAGnD5D,EAAK,OAAO6D,GAAQ,GAAG,GAAGF,CAAa,GAChC3D;AACT;AAEA,SAAS8D,GACPtD,GACA+C,GACAC,GACAE,GACA;AACA,MAAI1D,IAAOwC,EAAUW,GAA8B3C,EAAM,IAAI,CAAC;AAE9D,SAAAR,IAAOsD,GAAqBtD,GAAMuD,GAAeC,CAAwB,GACzExD,IAAOwC,EAAUxC,CAAI,GAEd2C,GAA8BnC,EAAM,MAAMR,CAAI;AACvD;AAEA,SAAS+D,GACPvD,GACA+C,GACAC,GACAE,GACA;AACI,MAAA1D,IAAOmD,GAA8B3C,EAAM,IAAI;AAEnD,SAAAR,IAAOsD,GAAqBtD,GAAMuD,GAAeC,CAAwB,GAElEb,GAA8BnC,EAAM,MAAMR,CAAI;AACvD;AAEA,SAASgE,GAA0B1D,GAAqBY,GAAiB;AACvE,MAAI+C,IAAa3D,GACb4D,IAAW5D;AAGf,WAASnB,IAAImB,GAAanB,KAAK,GAAGA,KAAK;AACrC,UAAMW,IAAQO,EAAclB,GAAG+B,EAAG,SAAS;AAC3C,IAAIpB,KACIA,EAAA,QAAQ,CAACR,MAAS;AACtB,YAAM6E,IAAgB7E,EAAK,KAAK,MAAM,UAAUH,IAAI;AAChD,MAAAgF,KAAiBF,MAAyBA,IAAA9E,IAE1CgF,IAAgBD,MAAqBA,IAAAC;AAAA,IAAA,CAC1C;AAAA,EACH;AAGF,WAAShF,IAAImB,GAAanB,KAAK+E,GAAU/E,KAAK;AAC5C,UAAMW,IAAQO,EAAclB,GAAG+B,EAAG,SAAS;AAC3C,IAAIpB,KACIA,EAAA,QAAQ,CAACR,MAAS;AACtB,YAAM6E,IAAgB7E,EAAK,KAAK,MAAM,UAAUH,IAAI;AACpD,MAAIG,EAAK,KAAK,MAAM,UAAU,KAAK6E,IAAgBD,MACtCA,IAAAC;AAAA,IAAA,CACd;AAAA,EACH;AAIF,QAAMC,IAAU,CAAC;AACjB,WAASjF,IAAI8E,GAAY9E,KAAK+E,GAAU/E,KAAK;AAC3C,UAAMkF,IAAahE,EAAclB,GAAG+B,EAAG,SAAS;AAChD,IAAImD,KAAcA,EAAW,UAAQD,EAAQ,KAAKjF,CAAC;AAAA,EAAA;AAErD,EAAA8E,IAAaG,EAAQ,CAAC,GACXF,IAAAE,EAAQA,EAAQ,SAAS,CAAC;AAErC,QAAME,IAA2BjE,EAAc4D,GAAY/C,EAAG,SAAS,GACjEqD,IAAgB1D,EAAc,GAAGK,EAAG,SAAS,GAC7CsD,IAAUtD,EAAG,IAAI;AAAA,IACrBoD,EAAyBA,EAAyB,SAAS,CAAC,EAAG;AAAA,EACjE;AAEI,MAAAG;AACJ,WAAStF,IAAI+E,GAAU/E,KAAK8E,GAAY9E,KAAK;AAC3C,UAAMuF,IAAcrE,EAAclB,GAAG+B,EAAG,SAAS;AAC7C,QAAAwD,KAAeA,EAAY,QAAQ;AACrC,eAASC,IAAIJ,EAAc,SAAS,GAAGI,KAAK,GAAGA;AAC7C,YAAIJ,EAAcI,CAAC,EAAG,QAAQD,EAAY,CAAC,EAAG,KAAK;AACjD,UAAAD,IAAWC,EAAY,CAAC;AACxB;AAAA,QAAA;AAGJ,UAAID,EAAU;AAAA,IAAA;AAAA,EAChB;AAGF,QAAMG,IAAQ1D,EAAG,IAAI,QAAQuD,EAAU,GAAG;AACnC,SAAA,EAAE,SAAAD,GAAS,OAAAI,GAAO,SAAAR,EAAQ;AACnC;AAEA,SAASS,GAAuB/D,GAAkBI,GAAiB;AACjE,MAAI+C,IAAanD,GACboD,IAAWpD;AAEf,WAAS3B,IAAI2B,GAAU3B,KAAK,GAAGA;AAEtB,IADO0B,EAAc1B,GAAG+B,EAAG,SAAS,EACpC,QAAQ,CAAC5B,MAAS;AACvB,YAAM6E,IAAgB7E,EAAK,KAAK,MAAM,UAAUH,IAAI;AAChD,MAAAgF,KAAiBF,MAAyBA,IAAA9E,IAE1CgF,IAAgBD,MAAqBA,IAAAC;AAAA,IAAA,CAC1C;AAGH,WAAShF,IAAI2B,GAAU3B,KAAK+E,GAAU/E;AAE7B,IADO0B,EAAc1B,GAAG+B,EAAG,SAAS,EACpC,QAAQ,CAAC5B,MAAS;AACvB,YAAM6E,IAAgB7E,EAAK,KAAK,MAAM,UAAUH,IAAI;AACpD,MAAIG,EAAK,KAAK,MAAM,UAAU,KAAK6E,IAAgBD,MACtCA,IAAAC;AAAA,IAAA,CACd;AAIH,QAAMC,IAAU,CAAC;AACjB,WAASjF,IAAI8E,GAAY9E,KAAK+E,GAAU/E,KAAK;AAC3C,UAAMkF,IAAaxD,EAAc1B,GAAG+B,EAAG,SAAS;AAChD,IAAImD,KAAcA,EAAW,UAAQD,EAAQ,KAAKjF,CAAC;AAAA,EAAA;AAErD,EAAA8E,IAAaG,EAAQ,CAAC,GACXF,IAAAE,EAAQA,EAAQ,SAAS,CAAC;AAErC,QAAMU,IAAwBjE,EAAcoD,GAAY/C,EAAG,SAAS,GAC9D6D,IAAmB1E,EAAc,GAAGa,EAAG,SAAS,GAChDsD,IAAUtD,EAAG,IAAI;AAAA,IACrB4D,EAAsBA,EAAsB,SAAS,CAAC,EAAG;AAAA,EAC3D;AAEI,MAAAL;AACJ,WAAStF,IAAI+E,GAAU/E,KAAK8E,GAAY9E,KAAK;AAC3C,UAAM4D,IAAWlC,EAAc1B,GAAG+B,EAAG,SAAS;AAC1C,QAAA6B,KAAYA,EAAS,QAAQ;AAC/B,eAAS4B,IAAII,EAAiB,SAAS,GAAGJ,KAAK,GAAGA;AAChD,YAAII,EAAiBJ,CAAC,EAAG,QAAQ5B,EAAS,CAAC,EAAG,KAAK;AACjD,UAAA0B,IAAW1B,EAAS,CAAC;AACrB;AAAA,QAAA;AAGJ,UAAI0B,EAAU;AAAA,IAAA;AAAA,EAChB;AAGF,QAAMG,IAAQ1D,EAAG,IAAI,QAAQuD,EAAU,GAAG;AACnC,SAAA,EAAE,SAAAD,GAAS,OAAAI,GAAO,SAAAR,EAAQ;AACnC;AAaO,SAASY,GAAQC,GAA8B;AACpD,QAAM,EAAE,IAAA/D,GAAI,QAAAgE,GAAQ,QAAArB,GAAQ,QAAAsB,IAAS,IAAM,KAAAxE,MAAQsE,GAC7C9E,IAAOQ,KAAO,OAAOO,EAAG,IAAI,QAAQP,CAAG,IAAIO,EAAG,UAAU,OACxDV,IAAQN,EAAUC,CAAI;AACxB,MAAA,CAACK,EAAc,QAAAU;AAEnB,QAAM,EAAE,SAASkE,EAAA,IAAwBpB,GAA0BkB,GAAQhE,CAAE,GACvE,EAAE,SAASmE,EAAA,IAAwBrB,GAA0BH,GAAQ3C,CAAE;AAE7E,MAAIkE,EAAoB,SAASvB,CAAM,EAAU,QAAA3C;AAEjD,QAAMoE,IAAWxB;AAAA,IACftD;AAAA,IACA4E;AAAA,IACAC;AAAA,EAEF,GAEME,IAAMjE,EAAQJ,CAAE,EAAE;AAAA,IACtBV,EAAM;AAAA,IACNA,EAAM,MAAMA,EAAM,KAAK;AAAA,IACvB8E;AAAA,EACF;AAEI,MAAA,CAACH,EAAe,QAAAI;AAEd,QAAA9E,IAAMC,EAAS,IAAI4E,CAAQ,GAC3B1E,IAAQJ,EAAM,OACdwB,IAAQ6B,GACR1B,IAAW1B,EAAI,WAAWA,EAAI,SAAS,GAAGuB,GAAOsD,CAAQ,GACzDjE,IAAYkE,EAAI,IAAI,QAAQ3E,IAAQuB,CAAQ,GAE5CC,IAAsBb,EAAc,cAEpCc,IAAY5B,EAAI,WAAW,GAAGuB,GAAOsD,CAAQ,GAC7CnE,IAAaoE,EAAI,IAAI,QAAQ3E,IAAQyB,CAAS;AAEpD,SAAOkD,EAAI,aAAanD,EAAoBf,GAAWF,CAAU,CAAC;AACpE;AAaO,SAASqE,GAAQC,GAA8B;AACpD,QAAM,EAAE,IAAAvE,GAAI,QAAAgE,GAAQ,QAAArB,GAAQ,QAAAsB,IAAS,IAAM,KAAAxE,MAAQ8E,GAC7CtF,IAAOQ,KAAO,OAAOO,EAAG,IAAI,QAAQP,CAAG,IAAIO,EAAG,UAAU,OACxDV,IAAQN,EAAUC,CAAI;AACxB,MAAA,CAACK,EAAc,QAAAU;AAEnB,QAAM,EAAE,SAASwE,EAAA,IAAqBb,GAAuBK,GAAQhE,CAAE,GACjE,EAAE,SAASyE,EAAA,IAAqBd,GAAuBhB,GAAQ3C,CAAE;AAEvE,MAAIwE,EAAiB,SAAS7B,CAAM,EAAU,QAAA3C;AAE9C,QAAMoE,IAAWvB,GAAavD,GAAOkF,GAAkBC,CAAmB,GAEpEJ,IAAMjE,EAAQJ,CAAE,EAAE;AAAA,IACtBV,EAAM;AAAA,IACNA,EAAM,MAAMA,EAAM,KAAK;AAAA,IACvB8E;AAAA,EACF;AAEI,MAAA,CAACH,EAAe,QAAAI;AAEd,QAAA9E,IAAMC,EAAS,IAAI4E,CAAQ,GAC3B1E,IAAQJ,EAAM,OACdwB,IAAQ6B,GACR1B,IAAW1B,EAAI,WAAWuB,GAAOvB,EAAI,QAAQ,GAAG6E,CAAQ,GACxDjE,IAAYkE,EAAI,IAAI,QAAQ3E,IAAQuB,CAAQ,GAE5CC,IAAsBb,EAAc,cAEpCc,IAAY5B,EAAI,WAAWuB,GAAO,GAAGsD,CAAQ,GAC7CnE,IAAaoE,EAAI,IAAI,QAAQ3E,IAAQyB,CAAS;AAEpD,SAAOkD,EAAI,aAAanD,EAAoBf,GAAWF,CAAU,CAAC;AACpE;ACrhBO,MAAMyE,IAA2B5H;AAAA,EACtC;AAAA,EACA,MAAM,MAAM6H,GAAa,EAAE;AAC7B;AAEA3I,EAAS0I,GAA0B;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAME,IAA2B9H;AAAA,EACtC;AAAA,EACA,MAAM,MAAM6H,GAAa,CAAC;AAC5B;AAEA3I,EAAS4I,GAA0B;AAAA,EACjC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAMC,IAAY/H;AAAA,EACvB;AAAA,EACA,CAACP,MAAQ,MAAM,CAACI,GAAOmI,MAAa;AAClC,QAAI,CAACC,EAAUpI,CAAK,EAAU,QAAA;AAExB,UAAA,EAAE,OAAA+G,MAAU/G,EAAM,WAClB2C,IAAQ0F,GAAmBtB,GAAO/F,EAAY,KAAKpB,CAAG,CAAC;AACzD,QAAA,CAAC+C,EAAc,QAAA;AAEb,UAAA,EAAE,IAAA2F,MAAO3F,GAETU,IAAKrD,EAAM,GAAG;AAAA,MAClBsI;AAAA,MACAA;AAAA,MACAC,GAAgB,KAAK3I,CAAG,EAAE,cAAc;AAAA,IAC1C;AAEG,WAAAyD,EAAA,aAAamF,GAAU,KAAKnF,EAAG,IAAI,QAAQiF,CAAE,GAAG,CAAC,CAAC,EAAE,eAAe,GACtEH,KAAA,QAAAA,EAAW9E,IACJ;AAAA,EAAA;AAEX;AAEAhE,EAAS6I,GAAW;AAAA,EAClB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAKM,MAAMO,KAAqBtI;AAAA,EAChC;AAAA,EACA,CAACP,MACC,CAAC,EAAE,KAAAiE,GAAK,KAAAG,EAAI,IAAoC,OAChD,CAAChE,GAAOmI,MAAa;AACb,UAAA,EAAE,WAAAzF,GAAW,IAAAW,EAAA,IAAOrD,GACpB,EAAE,MAAA0I,MAAShG,GACXC,IAAQb,GAAYlC,GAAKiE,GAAKG,CAAG,GACjC0D,IAAMrE,EAAG,qBAAqBV,CAAK,GACnCgG,IAAMH,GAAU,SAASd,EAAI,IAAI,QAAQgB,CAAI,GAAG,GAAG,EAAI;AACzD,WAAAC,KAASjB,EAAA,aAAaiB,CAAG,GAE7BR,KAAA,QAAAA,EAAWT,IAEJ;AAAA,EAAA;AAEb;AAEArI,EAASoJ,IAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIM,MAAMG,KAAiBzI;AAAA,EAC5B;AAAA,EACA,MACE,CAAC,EAAE,MAAAuI,GAAM,IAAAJ,GAAI,KAAAxF,EAAI,IAAkD,OACnE,CAAC9C,GAAOmI,MAAa;AACb,UAAA,EAAE,IAAA9E,MAAOrD;AAKf,WAAO,GAJQmI,KAAA,gBAAAA;AAAA,MACbR,GAAQ,EAAE,IAAAtE,GAAI,QAAQqF,KAAQ,GAAG,QAAQJ,KAAM,GAAG,KAAAxF,GAAK,QAAQ,GAAM,CAAA;AAAA;AAAA,EAGlD;AAE3B;AAEAzD,EAASuJ,IAAgB;AAAA,EACvB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIM,MAAMC,KAAiB1I;AAAA,EAC5B;AAAA,EACA,MACE,CAAC,EAAE,MAAAuI,GAAM,IAAAJ,GAAI,KAAAxF,EAAI,IAAkD,OACnE,CAAC9C,GAAOmI,MAAa;AACb,UAAA,EAAE,IAAA9E,MAAOrD;AAKf,WAAO,GAJQmI,KAAA,gBAAAA;AAAA,MACbhB,GAAQ,EAAE,IAAA9D,GAAI,QAAQqF,KAAQ,GAAG,QAAQJ,KAAM,GAAG,KAAAxF,GAAK,QAAQ,GAAM,CAAA;AAAA;AAAA,EAGlD;AAE3B;AAEAzD,EAASwJ,IAAgB;AAAA,EACvB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAMC,KAAmB3I;AAAA,EAI9B;AAAA,EACA,MACE,CAAC4I,IAA2C,EAAE,OAAO,EAAE,MACvD,CAAC/I,GAAOmI,MAAa;AACb,UAAA,EAAE,IAAA9E,MAAOrD;AAGf,WAAO,GAFQmI,KAAA,gBAAAA,EAAW1D,GAAUsE,EAAQ,OAAOA,EAAQ,GAAG,EAAE1F,CAAE;AAAA,EAE7C;AAE3B;AAEAhE,EAASyJ,IAAkB;AAAA,EACzB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAME,KAAmB7I;AAAA,EAI9B;AAAA,EACA,MACE,CAAC4I,IAA2C,EAAE,OAAO,EAAE,MACvD,CAAC/I,GAAOmI,MAAa;AACb,UAAA,EAAE,IAAA9E,MAAOrD;AAGf,WAAO,GAFQmI,KAAA,gBAAAA,EAAWzD,GAAUqE,EAAQ,OAAOA,EAAQ,GAAG,EAAE1F,CAAE;AAAA,EAE7C;AAE3B;AAEAhE,EAAS2J,IAAkB;AAAA,EACzB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAMC,KAAqB9I;AAAA,EAChC;AAAA,EACA,MAAM,MAAM,CAACH,GAAOmI,MAAa;AACzB,UAAA,EAAE,IAAA9E,MAAOrD;AAGf,WAAO,GAFQmI,KAAA,gBAAAA,EAAW/E,GAAYC,CAAE;AAAA,EAEnB;AAEzB;AAEAhE,EAAS4J,IAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAKM,MAAMC,KAA6B/I;AAAA,EACxC;AAAA,EACA,MAAM,MAAM,CAACH,GAAOmI,MAAa;AACzB,UAAA,EAAE,WAAAzF,MAAc1C;AAClB,QAAA,EAAE0C,aAAqBgB,GAAuB,QAAA;AAE5C,UAAAyF,IAAQzG,EAAU,eAAe,GACjC0G,IAAQ1G,EAAU,eAAe;AAEvC,WAAIyG,KAASC,IAAcC,GAAYrJ,GAAOmI,CAAQ,IAElDiB,IAAcE,GAAatJ,GAAOmI,CAAQ,IAClCoB,GAAUvJ,GAAOmI,CAAQ;AAAA,EAAA;AAEzC;AAEA9I,EAAS6J,IAA4B;AAAA,EACnC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAMM,KAAsBrJ;AAAA,EACjC;AAAA,EACA,MAAM,MAAMsJ;AACd;AAEApK,EAASmK,IAAqB;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAME,KAAqBvJ;AAAA,EAChC;AAAA,EACA,MAAM,MAAMwJ;AACd;AAEAtK,EAASqK,IAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAME,KAAsBzJ;AAAA,EACjC;AAAA,EACA,CAACP,MAAQ,MAAM,CAACI,GAAOmI,MAAa;AAClC,QAAI,CAACC,EAAUpI,CAAK,EAAU,QAAA;AAC9B,QAAImI,GAAU;AACN,YAAA3C,IAAOqE,GAAa7J,CAAK;AAC/B,MAAAmI,EAASxE,GAAoB/D,GAAKI,EAAM,IAAIwF,GAAMA,EAAK,GAAG,CAAC;AAAA,IAAA;AAEtD,WAAA;AAAA,EAAA;AAEX;AAEAnG,EAASuK,IAAqB;AAAA,EAC5B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAGM,MAAME,KAAqB3J;AAAA,EAChC;AAAA,EACA,CAACP,MAAQ,MAAM,CAACI,GAAOmI,MAAa;AAClC,QAAI,CAACC,EAAUpI,CAAK,EAAU,QAAA;AAC9B,QAAImI,GAAU;AACN,YAAA3C,IAAOqE,GAAa7J,CAAK;AAC/B,MAAAmI,EAASxE,GAAoB/D,GAAKI,EAAM,IAAIwF,GAAMA,EAAK,MAAM,CAAC;AAAA,IAAA;AAEzD,WAAA;AAAA,EAAA;AAEX;AAEAnG,EAASyK,IAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAKM,MAAMC,KAAkB5J;AAAA,EAI7B;AAAA,EACA,MACE,CAAC6J,IAAY,WACXC,GAAY,aAAaD,CAAS;AACxC;AAEA3K,EAAS0K,IAAiB;AAAA,EACxB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AChSM,MAAMG,KAAuB5J;AAAA,EAClC,CAACV,MACC,IAAIuK;AAAA,IACF;AAAA,IACA,CAACnK,GAAOoK,GAAOrH,GAAOsH,MAAQ;;AAC5B,YAAMC,IAAStK,EAAM,IAAI,QAAQ+C,CAAK;AACtC,UACE,CAACuH,EACE,KAAK,EAAE,EACP;AAAA,QACCA,EAAO,MAAM,EAAE;AAAA,QACfA,EAAO,WAAW,EAAE;AAAA,QACpBtJ,EAAY,KAAKpB,CAAG;AAAA,MACtB;AAEK,eAAA;AAET,YAAMmF,IAAYjD;AAAA,QAChBlC;AAAA,QACA,QAAO4B,IAAA4I,EAAM,WAAN,gBAAA5I,EAAc,GAAG;AAAA,QACxB,QAAO+I,IAAAH,EAAM,WAAN,gBAAAG,EAAc,GAAG;AAAA,MAC1B,GACMlH,IAAKrD,EAAM,GAAG,iBAAiB+C,GAAOsH,GAAKtF,CAAS;AACnD,aAAA1B,EACJ,aAAamH,GAAc,OAAOnH,EAAG,KAAKN,IAAQ,CAAC,CAAC,EACpD,eAAe;AAAA,IAAA;AAAA,EACpB;AAEN;AAEA1D,EAAS6K,IAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAMY,MAAAO,IAAchK,GAAW,eAAe;AAAA,EACnD,UAAU;AAAA,IACR,WAAW,CAAC,SAAS,KAAK;AAAA,IAC1B,SAAS,CAACb,MAAQ;AACV,YAAAc,IAAWd,EAAI,IAAIe,CAAW;AAEpC,aAAO,MAAMD,EAAS,KAAKuH,EAAyB,GAAG;AAAA,IAAA;AAAA,EAE3D;AAAA,EACA,UAAU;AAAA,IACR,WAAW,CAAC,SAAS,WAAW;AAAA,IAChC,SAAS,CAACrI,MAAQ;AACV,YAAAc,IAAWd,EAAI,IAAIe,CAAW;AAEpC,aAAO,MAAMD,EAAS,KAAKqH,EAAyB,GAAG;AAAA,IAAA;AAAA,EAE3D;AAAA,EACA,WAAW;AAAA,IACT,WAAW,CAAC,WAAW;AAAA,IACvB,SAAS,CAACnI,MAAQ;AACV,YAAAc,IAAWd,EAAI,IAAIe,CAAW;AAEpC,aAAO,MAAMD,EAAS,KAAKwH,EAAU,GAAG;AAAA,IAAA;AAAA,EAC1C;AAEJ,CAAC;AAED7I,EAASoL,EAAY,KAAK;AAAA,EACxB,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDpL,EAASoL,EAAY,WAAW;AAAA,EAC9B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACrFD,MAAMC,IAAK,uBACLC,KAAa,sBAGNC,IAA2B3J;AAAA,EACtC;AAAA,EACA,OAAO;AAAA,IACL,OAAO;AAAA,IACP,SAAS;AAAA,IACT,UAAU;AAAA,IACV,OAAO;AAAA,MACL,OAAO;AAAA,QACL,SAAS;AAAA,MAAA;AAAA,IAEb;AAAA,IACA,UAAU;AAAA,MACR;AAAA,QACE,KAAK,iBAAiByJ,CAAE;AAAA,QACxB,UAAU,CAAC5J,MAAQ;AACjB,cAAI,EAAEA,aAAe,aAAc,OAAM+J,EAAmB/J,CAAG;AAExD,iBAAA;AAAA,YACL,OAAOA,EAAI,QAAQ;AAAA,UACrB;AAAA,QACF;AAAA,QACA,gBAAgB;AAAA,MAAA;AAAA,IAEpB;AAAA,IACA,OAAO,CAACf,MAAS;AACT,YAAA+K,IAAQ/K,EAAK,MAAM;AAElB,aAAA;AAAA,QACL;AAAA,QACA;AAAA;AAAA,UAEE,cAAc+K;AAAA,UACd,aAAaJ;AAAAA,QACf;AAAA,QACA,CAAC,MAAMI,CAAK;AAAA,QACZ,CAAC,MAAM,CAAC;AAAA,MACV;AAAA,IACF;AAAA,IACA,eAAe;AAAA,MACb,OAAO,CAAC,EAAE,MAAA5J,QAAWA,MAASyJ;AAAA,MAC9B,QAAQ,CAAC3K,GAAOD,GAAMmB,MAAS;AAC7B,QAAAlB,EACG,SAASkB,GAAM;AAAA,UACd,OAAOnB,EAAK;AAAA,QACb,CAAA,EACA,KAAKA,EAAK,QAAQ,EAClB,UAAU;AAAA,MAAA;AAAA,IAEjB;AAAA,IACA,YAAY;AAAA,MACV,OAAO,CAACA,MAASA,EAAK,KAAK,SAAS2K;AAAAA,MACpC,QAAQ,CAAC1K,GAAOD,MAAS;AAEpB,QAAAC,EAAA,SAAS2K,IAAY,QAAW;AAAA,UAC/B,OAAO5K,EAAK,MAAM;AAAA,UAClB,YAAYA,EAAK,MAAM;AAAA,QACxB,CAAA,EACA,KAAKA,EAAK,OAAO,EACjB,UAAU;AAAA,MAAA;AAAA,IACf;AAAA,EAEJ;AACF;AAEAV,EAASuL,EAAyB,KAAK;AAAA,EACrC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAEDvL,EAASuL,EAAyB,MAAM;AAAA,EACtC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC5ED,MAAMF,IAAK,sBAGEK,IAA0B9J;AAAA,EACrC;AAAA,EACA,OAAO;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,OAAO;AAAA,MACL,OAAO;AAAA,QACL,SAAS;AAAA,MAAA;AAAA,IAEb;AAAA,IACA,UAAU;AAAA,MACR;AAAA,QACE,KAAK,kBAAkByJ,CAAE;AAAA,QACzB,UAAU,CAAC5J,MAAQ;AACjB,cAAI,EAAEA,aAAe,aAAc,OAAM+J,EAAmB/J,CAAG;AAExD,iBAAA;AAAA,YACL,OAAOA,EAAI,QAAQ;AAAA,UACrB;AAAA,QAAA;AAAA,MACF;AAAA,IAEJ;AAAA,IACA,OAAO,CAACf,MAAS;AACT,YAAA+K,IAAQ/K,EAAK,MAAM;AAClB,aAAA;AAAA,QACL;AAAA,QACA;AAAA;AAAA,UAEE,cAAc+K;AAAA,UACd,aAAaJ;AAAA,QACf;AAAA,QACAI;AAAA,MACF;AAAA,IACF;AAAA,IACA,eAAe;AAAA,MACb,OAAO,CAAC,EAAE,MAAA5J,QAAWA,MAAS;AAAA,MAC9B,QAAQ,CAAClB,GAAOD,GAAMmB,MAAS;AAC7B,QAAAlB,EAAM,QAAQkB,GAAM;AAAA,UAClB,OAAOnB,EAAK;AAAA,QAAA,CACb;AAAA,MAAA;AAAA,IAEL;AAAA,IACA,YAAY;AAAA,MACV,OAAO,CAACA,MAASA,EAAK,KAAK,SAAS2K;AAAA,MACpC,QAAQ,CAAC1K,GAAOD,MAAS;AACjB,QAAAC,EAAA,QAAQ,qBAAqB,QAAW,QAAW;AAAA,UACvD,OAAOD,EAAK,MAAM;AAAA,UAClB,YAAYA,EAAK,MAAM;AAAA,QAAA,CACxB;AAAA,MAAA;AAAA,IACH;AAAA,EAEJ;AACF;AAEAV,EAAS0L,EAAwB,KAAK;AAAA,EACpC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED1L,EAAS0L,EAAwB,MAAM;AAAA,EACrC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC/DM,MAAMC,KAA8BC,GAAe;AAAA,EACxD,CAACC,MACQ,CAACtL,MAAQ;AACR,UAAAuL,IAAaD,EAAKtL,CAAG;AACpB,WAAA;AAAA,MACL,GAAGuL;AAAA,MACH,OAAO;AAAA,QACL,GAAGA,EAAW;AAAA,QACd,SAAS;AAAA,UACP,SAAS;AAAA,QAAA;AAAA,MAEb;AAAA,MACA,UAAU;AAAA,QACR;AAAA,UACE,KAAK;AAAA,UACL,UAAU,CAACrK,MAAQ;AACjB,gBAAI,EAAEA,aAAe,aAAc,OAAM+J,EAAmB/J,CAAG;AAExD,mBAAA;AAAA,cACL,OAAOA,EAAI,QAAQ;AAAA,cACnB,UAAUA,EAAI,QAAQ;AAAA,cACtB,QAAQA,EAAI,QAAQ;AAAA,cACpB,SAASA,EAAI,QAAQ,UACjBA,EAAI,QAAQ,YAAY,SACxB;AAAA,YACN;AAAA,UAAA;AAAA,QAEJ;AAAA,QACA,IAAIqK,KAAA,gBAAAA,EAAY,aAAY,CAAA;AAAA,MAC9B;AAAA,MACA,OAAO,CAACpL,MACFoL,EAAW,SAASpL,EAAK,MAAM,WAAW,OACrCoL,EAAW,MAAMpL,CAAI,IAEvB;AAAA,QACL;AAAA,QACA;AAAA,UACE,kBAAkB;AAAA,UAClB,cAAcA,EAAK,MAAM;AAAA,UACzB,kBAAkBA,EAAK,MAAM;AAAA,UAC7B,eAAeA,EAAK,MAAM;AAAA,UAC1B,gBAAgBA,EAAK,MAAM;AAAA,QAC7B;AAAA,QACA;AAAA,MACF;AAAA,MAEF,eAAe;AAAA,QACb,OAAO,CAAC,EAAE,MAAAmB,QAAWA,MAAS;AAAA,QAC9B,QAAQ,CAAClB,GAAOD,GAAMmB,MAAS;AACzB,cAAAnB,EAAK,WAAW,MAAM;AACxB,YAAAoL,EAAW,cAAc,OAAOnL,GAAOD,GAAMmB,CAAI;AACjD;AAAA,UAAA;AAGF,gBAAM4J,IAAQ/K,EAAK,SAAS,OAAO,GAAGA,EAAK,KAAK,MAAM,KAChDqL,IAAUrL,EAAK,WAAW,OAAO,EAAQA,EAAK,UAAW,MACzDsL,IAAWtL,EAAK,SAAS,OAAO,YAAY,UAC5CuL,IAASvL,EAAK,UAAU,OAAO,GAAGA,EAAK,MAAM,KAAK;AAExD,UAAAC,EAAM,SAASkB,GAAM,EAAE,OAAA4J,GAAO,UAAAO,GAAU,QAAAC,GAAQ,SAAAF,GAAS,GACnDpL,EAAA,KAAKD,EAAK,QAAQ,GACxBC,EAAM,UAAU;AAAA,QAAA;AAAA,MAEpB;AAAA,MACA,YAAY;AAAA,QACV,OAAO,CAACD,MAASA,EAAK,KAAK,SAAS;AAAA,QACpC,QAAQ,CAACC,GAAOD,MAAS;AACnB,cAAAA,EAAK,MAAM,WAAW,MAAM;AACnB,YAAAoL,EAAA,WAAW,OAAOnL,GAAOD,CAAI;AACxC;AAAA,UAAA;AAGI,gBAAA+K,IAAQ/K,EAAK,MAAM,OACnBsL,IAAWtL,EAAK,MAAM,UACtBuL,IAASvL,EAAK,MAAM,WAAW,QAC/BqL,IAAUrL,EAAK,MAAM;AAErB,UAAAC,EAAA,SAAS,YAAY,QAAW;AAAA,YACpC,OAAA8K;AAAA,YACA,UAAAO;AAAA,YACA,QAAAC;AAAA,YACA,SAAAF;AAAA,UAAA,CACD,GACKpL,EAAA,KAAKD,EAAK,OAAO,GACvBC,EAAM,UAAU;AAAA,QAAA;AAAA,MAClB;AAAA,IAEJ;AAAA,EACF;AAEJ;AAEAX,EAAS2L,IAA6B;AAAA,EACpC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAIY,MAAAO,KAA0BjL,EAAW,MACzC,IAAI6J;AAAA,EACT;AAAA,EACA,CAACnK,GAAOoK,GAAOrH,GAAOsH,MAAQ;;AAC5B,UAAMvH,IAAM9C,EAAM,IAAI,QAAQ+C,CAAK;AACnC,QAAIyI,IAAQ,GACRzL,IAAO+C,EAAI,KAAK0I,CAAK;AACzB,WAAOzL,KAAQA,EAAK,KAAK,SAAS;AAChC,MAAAyL,KACOzL,IAAA+C,EAAI,KAAK0I,CAAK;AAGvB,QAAI,CAACzL,KAAQA,EAAK,MAAM,WAAW,KAAa,QAAA;AAEhD,UAAMqL,MAAkB5J,IAAA4I,EAAM,WAAN,gBAAA5I,EAAc,aAAY,KAE5CiK,IAAS3I,EAAI,OAAO0I,CAAK,GACzBnI,IAAKrD,EAAM;AAEjB,WAAAqD,EAAG,YAAYN,GAAOsH,CAAG,EAAE,cAAcoB,GAAQ,QAAW;AAAA,MAC1D,GAAG1L,EAAK;AAAA,MACR,SAAAqL;AAAA,IAAA,CACD,GAEM/H;AAAA,EAAA;AAEX,CACD;AAEDhE,EAASkM,IAAyB;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACrIM,MAAMG,KAA2B;AAAA,EACtClL;AAAA,EACAiK;AACF,EAAE,KAAK,GCHMkB,KAA+B;AAAA,EAC1CzB;AAAA,EACAqB;AACF,GAEaK,KAAmC,CAACvL,EAAsB,GCJ1DwL,KAAuBC,EAAO,MAAMC,EAAO;AAExD1M,EAASwM,IAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACNM,MAAMG,KAAuBF,EAAO,MAAMG,GAAe,EAAE,CAAC;AAEnE5M,EAAS2M,IAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACLM,MAAME,KAAqBJ;AAAA,EAAO,MACvCK,GAAa,EAAE,yBAAyB,GAAM,CAAA;AAChD;AAEA9M,EAAS6M,IAAoB;AAAA,EAC3B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACLM,MAAME,IACXC,GAAQ,aAAa,MAAMC,EAAS;AAEtCjN,EAAS+M,EAAgB,QAAQ;AAAA,EAC/B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AAED/M,EAAS+M,EAAgB,SAAS;AAAA,EAChC,aAAa;AAAA,EACb,OAAO;AACT,CAAC;ACZD,MAAMG,KAAY,IAAIC,GAAU,kCAAkC;AAElE,SAASC,GAAc1M,GAAY2M,GAAc;AAC/C,MAAIvI,IAAQ;AACZ,SAAAuI,EAAO,QAAQ,CAACC,GAAOC,GAAStL,MAAM;AAChC,IAAAqL,MAAU5M,MAAcoE,IAAA7C;AAAA,EAAA,CAC7B,GACM6C;AACT;AAEa,MAAA0I,KAAuBf,EAAO,MAClC,IAAIgB,GAAO;AAAA,EAChB,KAAKP;AAAA,EACL,mBAAmB,CAAC7E,GAAKqF,GAAU/M,MAAU;AACvC,QAAAqD;AACE,UAAA2J,IAAQ,CAACjN,GAAY+C,MAAgB;AAGrC,UAFCO,MAAIA,IAAKrD,EAAM,KAEhBD,EAAK,KAAK,SAAS,aAAc;AAErC,YAAMuC,IAAOtC,EAAM,IAAI,QAAQ8C,CAAG,GAC5BmK,IAAW3K,EAAK,KAAKA,EAAK,KAAK,GAE/B4K,IADQ5K,EAAK,KAAKA,EAAK,QAAQ,CAAC,EACT;AAE7B,UAAI,CAAC4K,EAAgB;AAEf,YAAA/I,IAAQsI,GAAc1M,GAAMkN,CAAQ,GACpCE,IAAaD,EAAe,WAAW/I,CAAK;AAClD,UAAI,CAACgJ,EAAY;AACX,YAAAhM,IAAQgM,EAAW,MAAM,WACzBC,IAAerN,EAAK,MAAM;AAChC,MAAIoB,MAAUiM,KAEX/J,EAAA,cAAcP,GAAK,QAAW,EAAE,GAAG/C,EAAK,OAAO,WAAWoB,GAAO;AAAA,IACtE;AACA,WAAI4L,EAAS,QAAQ/M,EAAM,OAAWA,EAAA,IAAI,YAAYgN,CAAK,GAEpD3J;AAAA,EAAA;AACT,CACD,CACF;AAEDhE,EAASwN,IAAsB;AAAA,EAC7B,aAAa;AAAA,EACb,OAAO;AACT,CAAC;AC3CM,MAAMQ,KAA4B;AAAA,EACvCR;AAAA,EACAhB;AAAA,EACAO;AAAA,EACAF;AACF,EAAE,KAAK,GCAMoB,KAA2B;AAAA,EACtCtC;AAAA,EAEAhK;AAAA,EACAU;AAAA,EACAC;AAAA,EACAE;AAAA,EACAD;AAAA,EAEAgJ;AAAA,EACAG;AAAA,EAEAvL;AAAA,EACAE;AACF,EAAE,KAAK,GCRMgB,KAAW;AAAA,EACtBuH;AAAA,EACAF;AAAA,EACAG;AAAA,EACAO;AAAA,EACAG;AAAA,EACAC;AAAA,EACAC;AAAA,EACAE;AAAA,EACAC;AAAA,EACAC;AAAA,EACAU;AAAA,EACAE;AAAA,EACAN;AAAA,EACAE;AAAA,EACAK;AAAA,EAEA7J;AACF,GCvBaqN,KAAM;AAAA,EACjBD;AAAA,EACA3B;AAAA,EACAC;AAAA,EACAF;AAAA,EACAhL;AAAA,EACA2M;AACF,EAAE,KAAK;"}