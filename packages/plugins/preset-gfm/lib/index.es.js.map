{"version":3,"file":"index.es.js","sources":["../src/__internal__/with-meta.ts","../src/mark/strike-through.ts","../src/node/table/schema.ts","../src/node/table/utils.ts","../src/node/table/command.ts","../src/node/table/input.ts","../src/node/footnote/definition.ts","../src/node/footnote/reference.ts","../src/node/task-list-item.ts","../src/composed/keymap.ts","../src/composed/inputrules.ts","../src/plugin/auto-insert-span-plugin.ts","../src/plugin/column-resizing-plugin.ts","../src/plugin/table-editing-plugin.ts","../src/plugin/remark-gfm-plugin.ts","../src/plugin/keep-table-align-plugin.ts","../src/composed/plugins.ts","../src/composed/schema.ts","../src/composed/commands.ts","../src/index.ts"],"sourcesContent":["import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(plugin: T, meta: Partial<Meta> & Pick<Meta, 'displayName'>): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n","import { commandsCtx } from '@milkdown/core'\nimport { $command, $inputRule, $markAttr, $markSchema, $useKeymap } from '@milkdown/utils'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { markRule } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', ctx => ({\n  parseDOM: [\n    { tag: 'del' },\n    { style: 'text-decoration', getAttrs: value => (value === 'line-through') as false },\n  ],\n  toDOM: mark => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: node => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: mark => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command('ToggleStrikeThrough', ctx => () => {\n  return toggleMark(strikethroughSchema.type(ctx))\n})\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Input rule to create the strikethrough mark.\nexport const strikethroughInputRule = $inputRule((ctx) => {\n  return markRule(/~([^~]+)~$/, strikethroughSchema.type(ctx))\n})\n\nwithMeta(strikethroughInputRule, {\n  displayName: 'InputRule<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n","import { tableNodes } from '@milkdown/prose/tables'\nimport { $nodeSchema } from '@milkdown/utils'\nimport type { MarkdownNode } from '@milkdown/transformer'\nimport type { NodeType } from '@milkdown/prose/model'\nimport { withMeta } from '../../__internal__'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: dom => (dom).style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  content: 'table_header_row table_row+',\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: node => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine)\n        return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table header row node.\nexport const tableHeaderRowSchema = $nodeSchema('table_header_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_header)*',\n  parseDOM: [{ tag: 'tr[data-is-header]' }],\n  toDOM() {\n    return ['tr', { 'data-is-header': true }, 0]\n  },\n  parseMarkdown: {\n    match: node => Boolean(node.type === 'tableRow' && node.isHeader),\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_header_row',\n    runner: (state, node) => {\n      state.openNode('tableRow', undefined, { isHeader: true })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderRowSchema.node, {\n  displayName: 'NodeSchema<tableHeaderRow>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeaderRow>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_cell)*',\n  parseMarkdown: {\n    match: node => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_row',\n    runner: (state, node) => {\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n","import type { ContentNodeWithPos } from '@milkdown/prose'\nimport { cloneTr, findParentNodeClosestToPos } from '@milkdown/prose'\nimport type { Node, ResolvedPos } from '@milkdown/prose/model'\nimport type { Selection, Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\nimport type { Ctx } from '@milkdown/ctx'\nimport { tableCellSchema, tableHeaderRowSchema, tableHeaderSchema, tableRowSchema, tableSchema } from './schema'\n\n/// @internal\nexport interface CellPos {\n  pos: number\n  start: number\n  node: Node\n}\n\n/// @internal\nexport function createTable(ctx: Ctx, rowsCount = 3, colsCount = 3): Node {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type(ctx).createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type(ctx).createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) => i === 0\n      ? tableHeaderRowSchema.type(ctx).create(null, headerCells)\n      : tableRowSchema.type(ctx).create(null, cells))\n\n  return tableSchema.type(ctx).create(null, rows)\n}\n\n/// Find the table node with position information for target pos.\nexport function findTable($pos: ResolvedPos) {\n  return findParentNodeClosestToPos(node => node.type.spec.tableRole === 'table')($pos)\n}\n\n/// Get cells in a column of a table.\nexport function getCellsInCol(columnIndex: number, selection: Selection): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (columnIndex < 0 || columnIndex >= map.width)\n    return undefined\n\n  return map\n    .cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map.height })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get cells in a row of a table.\nexport function getCellsInRow(rowIndex: number, selection: Selection): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (rowIndex < 0 || rowIndex >= map.height)\n    return undefined\n\n  return map\n    .cellsInRect({ left: 0, right: map.width, top: rowIndex, bottom: rowIndex + 1 })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get all cells in a table.\nexport function getAllCellsInTable(selection: Selection) {\n  const table = findTable(selection.$from)\n  if (!table)\n    return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n\n/// Select a possible table in current selection.\nexport function selectTable(tr: Transaction) {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n\n/// @internal\nexport function addRowWithAlignment(ctx: Ctx, tr: Transaction, { map, tableStart, table }: TableRect, row: number) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema.type(ctx).createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type(ctx).create(null, cells))\n  return tr\n}\n\n/// @internal\nexport function selectLine(type: 'row' | 'col') {\n  return (index: number, pos?: number) => (tr: Transaction) => {\n    pos = pos ?? tr.selection.from\n    const $pos = tr.doc.resolve(pos)\n    const $node = findParentNodeClosestToPos(node => node.type.name === 'table')($pos)\n    const table = $node\n      ? {\n          node: $node.node,\n          from: $node.start,\n        }\n      : undefined\n\n    const isRowSelection = type === 'row'\n    if (table) {\n      const map = TableMap.get(table.node)\n\n      // Check if the index is valid\n      if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n        const lastCell = map.positionAt(\n          isRowSelection ? index : map.height - 1,\n          isRowSelection ? map.width - 1 : index,\n          table.node,\n        )\n        const $lastCell = tr.doc.resolve(table.from + lastCell)\n\n        const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection\n\n        const firstCell = map.positionAt(isRowSelection ? index : 0, isRowSelection ? 0 : index, table.node)\n        const $firstCell = tr.doc.resolve(table.from + firstCell)\n        return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell) as unknown as Selection))\n      }\n    }\n    return tr\n  }\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n\nfunction transpose<T>(array: T[][]) {\n  return array[0]!.map((_, i) => {\n    return array.map(column => column[i])\n  }) as T[][]\n}\n\nfunction convertArrayOfRowsToTableNode(tableNode: Node, arrayOfNodes: (Node | null)[][]) {\n  const rowsPM = []\n  const map = TableMap.get(tableNode)\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex)\n    const rowCells = []\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex]![colIndex])\n        continue\n\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n\n      const cell = arrayOfNodes[rowIndex]![colIndex]!\n      const oldCell = tableNode.nodeAt(cellPos)!\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks,\n      )\n      rowCells.push(newCell)\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks))\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks,\n  )\n\n  return newTable\n}\n\nfunction convertTableNodeToArrayOfRows(tableNode: Node) {\n  const map = TableMap.get(tableNode)\n  const rows: (Node | null)[][] = []\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells: (Node | null)[] = []\n    const seen: Record<number, boolean> = {}\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n      const cell = tableNode.nodeAt(cellPos)\n      const rect = map.findCell(cellPos)\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null)\n        continue\n      }\n      seen[cellPos] = true\n\n      rowCells.push(cell)\n    }\n\n    rows.push(rowCells)\n  }\n\n  return rows\n}\n\nfunction moveRowInArrayOfRows(rows: (Node | null)[][], indexesOrigin: number[], indexesTarget: number[], directionOverride: -1 | 1 | 0) {\n  const direction = indexesOrigin[0]! > indexesTarget[0]! ? -1 : 1\n\n  const rowsExtracted = rows.splice(indexesOrigin[0]!, indexesOrigin.length)\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0\n  let target: number\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0]! - 1\n  }\n  else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1]! - positionOffset + 1\n  }\n  else {\n    target\n      = direction === -1\n        ? indexesTarget[0]!\n        : indexesTarget[indexesTarget.length - 1]! - positionOffset\n  }\n\n  rows.splice(target, 0, ...rowsExtracted)\n  return rows\n}\n\nfunction moveTableColumn(table: ContentNodeWithPos, indexesOrigin: number[], indexesTarget: number[], direction: -1 | 1 | 0) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node))\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n  rows = transpose(rows)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction moveTableRow(table: ContentNodeWithPos, indexesOrigin: number[], indexesTarget: number[], direction: -1 | 1 | 0) {\n  let rows = convertTableNodeToArrayOfRows(table.node)\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction getSelectionRangeInColumn(columnIndex: number, tr: Transaction) {\n  let startIndex = columnIndex\n  let endIndex = columnIndex\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (maybeEndIndex >= startIndex)\n          startIndex = i\n\n        if (maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInCol(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedColumnCells = getCellsInCol(startIndex, tr.selection)!\n  const firstRowCells = getCellsInRow(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1]!.pos,\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInCol(i, tr.selection)\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j]!.pos === columnCells[0]!.pos) {\n          headCell = columnCells[0]\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nfunction getSelectionRangeInRow(rowIndex: number, tr: Transaction) {\n  let startIndex = rowIndex\n  let endIndex = rowIndex\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (maybeEndIndex >= startIndex)\n        startIndex = i\n\n      if (maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection)!\n  const firstColumnCells = getCellsInCol(0, tr.selection)!\n  const $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1]!.pos)\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection)\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j]!.pos === rowCells[0]!.pos) {\n          headCell = rowCells[0]!\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nexport interface MoveColParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the columns at `origin` to `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved column.\nexport function moveCol(moveColParams: MoveColParams) {\n  const { tr, origin, target, select = true, pos } = moveColParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(origin, tr)\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(target, tr)\n\n  if (indexesOriginColumn.includes(target))\n    return tr\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(map.height - 1, index, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.colSelection\n\n  const firstCell = map.positionAt(0, index, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n\nexport interface MoveRowParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the rows at `origin` and `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved row.\nexport function moveRow(moveRowParams: MoveRowParams) {\n  const { tr, origin, target, select = true, pos } = moveRowParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(origin, tr)\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(target, tr)\n\n  if (indexesOriginRow.includes(target))\n    return tr\n\n  const newTable = moveTableRow(\n    table,\n    indexesOriginRow,\n    indexesTargetRow,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(index, map.width - 1, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.rowSelection\n\n  const firstCell = map.positionAt(index, 0, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n","import { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { Selection } from '@milkdown/prose/state'\nimport { CellSelection, addColumnAfter, addColumnBefore, deleteColumn, deleteRow, deleteTable, goToNextCell, isInTable, selectedRect, setCellAttr } from '@milkdown/prose/tables'\nimport { $command } from '@milkdown/utils'\nimport { findParentNodeType } from '@milkdown/prose'\nimport { withMeta } from '../../__internal__'\nimport { addRowWithAlignment, createTable, moveCol, moveRow, selectCol, selectRow, selectTable } from './utils'\nimport { tableSchema } from './schema'\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command('GoToPrevTableCell', () => () => goToNextCell(-1))\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command('GoToNextTableCell', () => () => goToNextCell(1))\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for quitting current table and insert a new paragraph node.\nexport const exitTable = $command('ExitTable', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n\n  const { $head } = state.selection\n  const table = findParentNodeType($head, tableSchema.type(ctx))\n  if (!table)\n    return false\n\n  const { to } = table\n\n  const tr = state.tr\n    .replaceWith(to, to, paragraphSchema.type(ctx).createAndFill()!)\n\n  tr.setSelection(Selection.near(tr.doc.resolve(to), 1)).scrollIntoView()\n  dispatch?.(tr)\n  return true\n})\n\nwithMeta(exitTable, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command('InsertTable', ctx => ({ row, col }: { row?: number, col?: number } = {}) => (state, dispatch) => {\n  const { selection, tr } = state\n  const { from } = selection\n  const table = createTable(ctx, row, col)\n  const _tr = tr.replaceSelectionWith(table)\n  const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n  if (sel)\n    _tr.setSelection(sel)\n\n  dispatch?.(_tr)\n\n  return true\n})\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command('MoveRow', () =>\n  ({ from, to, pos }: { from?: number, to?: number, pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(moveRow({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true }))\n\n      return Boolean(result)\n    })\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command('MoveCol', () =>\n  ({ from, to, pos }: { from?: number, to?: number, pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(moveCol({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true }))\n\n      return Boolean(result)\n    })\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<{ index: number, pos?: number }, 'SelectRow'>('SelectRow', () =>\n  (payload: { index: number, pos?: number } = { index: 0 }) => (state, dispatch) => {\n    const { tr } = state\n    const result = dispatch?.(selectRow(payload.index, payload.pos)(tr))\n\n    return Boolean(result)\n  })\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<{ index: number, pos?: number }, 'SelectCol'>('SelectCol', () =>\n  (payload: { index: number, pos?: number } = { index: 0 }) => (state, dispatch) => {\n    const { tr } = state\n    const result = dispatch?.(selectCol(payload.index, payload.pos)(tr))\n\n    return Boolean(result)\n  })\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command('SelectTable', () => () => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectTable(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command('DeleteSelectedCells', () => () => (state, dispatch) => {\n  const { selection } = state\n  if (!(selection instanceof CellSelection))\n    return false\n\n  const isRow = selection.isRowSelection()\n  const isCol = selection.isColSelection()\n\n  if (isRow && isCol)\n    return deleteTable(state, dispatch)\n\n  if (isCol)\n    return deleteColumn(state, dispatch)\n\n  else\n    return deleteRow(state, dispatch)\n})\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command('AddColBefore', () => () => addColumnBefore)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command('AddColAfter', () => () => addColumnAfter)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command('AddRowBefore', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.top))\n  }\n  return true\n})\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command('AddRowAfter', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.bottom))\n  }\n  return true\n})\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<'left' | 'center' | 'right', 'SetAlign'>('SetAlign', () => (alignment = 'left') => setCellAttr('alignment', alignment))\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { TextSelection } from '@milkdown/prose/state'\nimport { $inputRule, $useKeymap } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\nimport { createTable } from './utils'\nimport { tableSchema } from './schema'\nimport { exitTable, goToNextTableCellCommand, goToPrevTableCellCommand } from './command'\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(ctx => new InputRule(\n  /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/,\n  (state, match, start, end) => {\n    const $start = state.doc.resolve(start)\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), tableSchema.type(ctx)))\n      return null\n\n    const tableNode = createTable(\n      ctx,\n      Number(match.groups?.row),\n      Number(match.groups?.col),\n    )\n    const tr = state.tr.replaceRangeWith(start, end, tableNode)\n    return tr.setSelection(TextSelection.create(tr.doc, start + 3)).scrollIntoView()\n  },\n))\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(exitTable.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema('footnote_definition', () => ({\n  group: 'block',\n  content: 'block+',\n  defining: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `dl[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n      contentElement: 'dd',\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n\n    return [\n      'dl',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      ['dt', label],\n      ['dd', 0],\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === markdownId,\n    runner: (state, node, type) => {\n      state\n        .openNode(type, {\n          label: node.label as string,\n        })\n        .next(node.children)\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state\n        .openNode(markdownId, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n        .next(node.content)\n        .closeNode()\n    },\n  },\n}))\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema('footnote_reference', () => ({\n  group: 'inline',\n  inline: true,\n  atom: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `sup[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n    return [\n      'sup',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      label,\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === 'footnoteReference',\n    runner: (state, node, type) => {\n      state.addNode(type, {\n        label: node.label as string,\n      })\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state.addNode('footnoteReference', undefined, undefined, {\n        label: node.attrs.label,\n        identifier: node.attrs.label,\n      })\n    },\n  },\n}))\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema((prev) => {\n  return (ctx) => {\n    const baseSchema = prev(ctx)\n    return {\n      ...baseSchema,\n      attrs: {\n        ...baseSchema.attrs,\n        checked: {\n          default: null,\n        },\n      },\n      parseDOM: [\n        {\n          tag: 'li[data-item-type=\"task\"]',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return {\n              label: dom.dataset.label,\n              listType: dom.dataset.listType,\n              spread: dom.dataset.spread,\n              checked: dom.dataset.checked ? dom.dataset.checked === 'true' : null,\n            }\n          },\n        },\n        ...baseSchema?.parseDOM || [],\n      ],\n      toDOM: (node) => {\n        if (baseSchema.toDOM && node.attrs.checked == null)\n          return baseSchema.toDOM(node)\n\n        return [\n          'li',\n          {\n            'data-item-type': 'task',\n            'data-label': node.attrs.label,\n            'data-list-type': node.attrs.listType,\n            'data-spread': node.attrs.spread,\n            'data-checked': node.attrs.checked,\n          },\n          0,\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type }) => type === 'listItem',\n        runner: (state, node, type) => {\n          if (node.checked == null) {\n            baseSchema.parseMarkdown.runner(state, node, type)\n            return\n          }\n\n          const label = node.label != null ? `${node.label}.` : 'â€¢'\n          const checked = node.checked != null ? Boolean(node.checked) : null\n          const listType = node.label != null ? 'ordered' : 'bullet'\n          const spread = node.spread != null ? `${node.spread}` : 'true'\n\n          state.openNode(type, { label, listType, spread, checked })\n          state.next(node.children)\n          state.closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'list_item',\n        runner: (state, node) => {\n          if (node.attrs.checked == null) {\n            baseSchema.toMarkdown.runner(state, node)\n            return\n          }\n\n          const label = node.attrs.label\n          const listType = node.attrs.listType\n          const spread = node.attrs.spread === 'true'\n          const checked = node.attrs.checked\n\n          state.openNode('listItem', undefined, { label, listType, spread, checked })\n          state.next(node.content)\n          state.closeNode()\n        },\n      },\n    }\n  }\n})\n\nwithMeta(extendListItemSchemaForTask, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(/^\\[(?<checked>\\s|x)\\]\\s$/, (state, match, start, end) => {\n    const pos = state.doc.resolve(start)\n    let depth = 0\n    let node = pos.node(depth)\n    while (node && node.type.name !== 'list_item') {\n      depth--\n      node = pos.node(depth)\n    }\n\n    if (!node || node.attrs.checked != null)\n      return null\n\n    const checked = Boolean(match.groups?.checked === 'x')\n\n    const finPos = pos.before(depth)\n    const tr = state.tr\n\n    tr.deleteRange(start, end)\n      .setNodeMarkup(finPos, undefined, { ...node.attrs, checked })\n\n    return tr\n  })\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\nimport { strikethroughInputRule } from '../mark'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n\nexport const markInputRules: MilkdownPlugin[] = [\n  strikethroughInputRule,\n]\n","import { $prose } from '@milkdown/utils'\nimport { imeSpan } from 'prosemirror-safari-ime-span'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertSpanPlugin = $prose(() => imeSpan)\n\nwithMeta(autoInsertSpanPlugin, {\n  displayName: 'Prose<autoInsertSpanPlugin>',\n  group: 'Prose',\n})\n","import { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n","import { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() => tableEditing({ allowTableNodeSelection: true }))\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n","import type { $Remark } from '@milkdown/utils'\nimport { $remark } from '@milkdown/utils'\nimport type { Options } from 'remark-gfm'\nimport remarkGFM from 'remark-gfm'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin: $Remark<'remarkGFM', Options | null | undefined> = $remark('remarkGFM', () => remarkGFM)\n\nwithMeta(remarkGFMPlugin.plugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkGFMPlugin.options, {\n  displayName: 'RemarkConfig<remarkGFMPlugin>',\n  group: 'Remark',\n})\n","import type { Transaction } from '@milkdown/prose/state'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { Node } from '@milkdown/prose/model'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\nconst pluginKey = new PluginKey('MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN')\n\nfunction getChildIndex(node: Node, parent: Node) {\n  let index = 0\n  parent.forEach((child, _offset, i) => {\n    if (child === node)\n      index = i\n  })\n  return index\n}\n\nexport const keepTableAlignPlugin = $prose(() => {\n  return new Plugin({\n    key: pluginKey,\n    appendTransaction: (_tr, oldState, state) => {\n      let tr: Transaction | undefined\n      const check = (node: Node, pos: number) => {\n        if (!tr)\n          tr = state.tr\n\n        if (node.type.name !== 'table_cell')\n          return\n\n        const $pos = state.doc.resolve(pos)\n        const tableRow = $pos.node($pos.depth)\n        const table = $pos.node($pos.depth - 1)\n        const tableHeaderRow = table.firstChild\n        // TODO: maybe consider add a header row\n        if (!tableHeaderRow)\n          return\n\n        const index = getChildIndex(node, tableRow)\n        const headerCell = tableHeaderRow.maybeChild(index)\n        if (!headerCell)\n          return\n        const align = headerCell.attrs.alignment\n        const currentAlign = node.attrs.alignment\n        if (align === currentAlign)\n          return\n\n        tr.setNodeMarkup(pos, undefined, { ...node.attrs, alignment: align })\n      }\n      if (oldState.doc !== state.doc)\n        state.doc.descendants(check)\n\n      return tr\n    },\n  })\n})\n\nwithMeta(keepTableAlignPlugin, {\n  displayName: 'Prose<keepTableAlignPlugin>',\n  group: 'Prose',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  autoInsertSpanPlugin,\n  keepTableAlignPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  keepTableAlignPlugin,\n  autoInsertSpanPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport {\n  extendListItemSchemaForTask,\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableHeaderRowSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n","import { toggleStrikethroughCommand } from '../mark'\nimport { addColAfterCommand, addColBeforeCommand, addRowAfterCommand, addRowBeforeCommand, deleteSelectedCellsCommand, exitTable, goToNextTableCellCommand, goToPrevTableCellCommand, insertTableCommand, moveColCommand, moveRowCommand, selectColCommand, selectRowCommand, selectTableCommand, setAlignCommand } from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  exitTable,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n","import { commands, inputRules, keymap, markInputRules, plugins, schema } from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [schema, inputRules, markInputRules, keymap, commands, plugins].flat()\n"],"names":["withMeta","plugin","meta","strikethroughAttr","$markAttr","strikethroughSchema","$markSchema","ctx","value","mark","node","state","markType","toggleStrikethroughCommand","$command","toggleMark","strikethroughInputRule","$inputRule","markRule","strikethroughKeymap","$useKeymap","commands","commandsCtx","originalSchema","tableNodes","dom","attrs","tableSchema","$nodeSchema","type","align","children","x","i","firstLine","_a","cell","tableHeaderRowSchema","tableRowSchema","tableCellSchema","tableHeaderSchema","createTable","rowsCount","colsCount","cells","headerCells","rows","_","findTable","$pos","findParentNodeClosestToPos","getCellsInCol","columnIndex","selection","table","map","TableMap","pos","start","getCellsInRow","rowIndex","getAllCellsInTable","nodePos","selectTable","tr","$firstCell","last","$lastCell","cloneTr","CellSelection","addRowWithAlignment","tableStart","row","rowPos","acc","col","headerCol","selectLine","index","$node","isRowSelection","lastCell","createCellSelection","firstCell","selectRow","selectCol","transpose","array","column","convertArrayOfRowsToTableNode","tableNode","arrayOfNodes","rowsPM","rowCells","colIndex","cellPos","newCell","convertTableNodeToArrayOfRows","seen","rect","moveRowInArrayOfRows","indexesOrigin","indexesTarget","directionOverride","direction","rowsExtracted","positionOffset","target","moveTableColumn","moveTableRow","getSelectionRangeInColumn","startIndex","endIndex","maybeEndIndex","indexes","maybeCells","firstSelectedColumnCells","firstRowCells","$anchor","headCell","columnCells","j","$head","getSelectionRangeInRow","firstSelectedRowCells","firstColumnCells","moveCol","moveColParams","origin","select","indexesOriginColumn","indexesTargetColumn","newTable","_tr","moveRow","moveRowParams","indexesOriginRow","indexesTargetRow","goToPrevTableCellCommand","goToNextCell","goToNextTableCellCommand","exitTable","dispatch","isInTable","findParentNodeType","to","paragraphSchema","Selection","insertTableCommand","from","sel","moveRowCommand","moveColCommand","selectRowCommand","payload","selectColCommand","selectTableCommand","deleteSelectedCellsCommand","isRow","isCol","deleteTable","deleteColumn","deleteRow","addColBeforeCommand","addColumnBefore","addColAfterCommand","addColumnAfter","addRowBeforeCommand","selectedRect","addRowAfterCommand","setAlignCommand","alignment","setCellAttr","insertTableInputRule","InputRule","match","end","$start","_b","TextSelection","tableKeymap","id","markdownId","footnoteDefinitionSchema","expectDomTypeError","label","footnoteReferenceSchema","extendListItemSchemaForTask","listItemSchema","prev","baseSchema","checked","listType","spread","wrapInTaskListInputRule","depth","finPos","keymap","inputRules","markInputRules","autoInsertSpanPlugin","$prose","imeSpan","columnResizingPlugin","columnResizing","tableEditingPlugin","tableEditing","remarkGFMPlugin","$remark","remarkGFM","pluginKey","PluginKey","getChildIndex","parent","child","_offset","keepTableAlignPlugin","Plugin","oldState","check","tableRow","tableHeaderRow","headerCell","currentAlign","plugins","schema","gfm"],"mappings":"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"}