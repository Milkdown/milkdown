{"version":3,"file":"index.es.js","sources":["../src/slash-plugin.ts","../src/slash-provider.ts"],"sourcesContent":["import type { SliceType } from '@milkdown/ctx'\nimport type { PluginSpec } from '@milkdown/prose/state'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { $Ctx, $Prose } from '@milkdown/utils'\nimport { $ctx, $prose } from '@milkdown/utils'\n\n/// @internal\nexport type SlashPluginSpecId<Id extends string> = `${Id}_SLASH_SPEC`\n\n/// @internal\nexport type SlashPlugin<Id extends string, State = any> = [$Ctx<PluginSpec<State>, SlashPluginSpecId<Id>>, $Prose] & {\n  key: SliceType<PluginSpec<State>, SlashPluginSpecId<Id>>\n  pluginKey: $Prose['key']\n}\n\n/// Create a slash plugin with a unique id.\nexport function slashFactory<Id extends string, State = any>(id: Id) {\n  const slashSpec = $ctx<PluginSpec<State>, SlashPluginSpecId<Id>>({}, `${id}_SLASH_SPEC`)\n  const slashPlugin = $prose((ctx) => {\n    const spec = ctx.get(slashSpec.key)\n    return new Plugin({\n      key: new PluginKey(`${id}_SLASH`),\n      ...spec,\n    })\n  })\n  const result = [slashSpec, slashPlugin] as SlashPlugin<Id>\n  result.key = slashSpec.key\n  result.pluginKey = slashPlugin.key\n  slashSpec.meta = {\n    package: '@milkdown/plugin-slash',\n    displayName: `Ctx<slashSpec>|${id}`,\n  }\n  slashPlugin.meta = {\n    package: '@milkdown/plugin-slash',\n    displayName: `Prose<slash>|${id}`,\n  }\n\n  return result\n}\n","import { findParentNode, posToDOMRect } from '@milkdown/prose'\nimport type { EditorState } from '@milkdown/prose/state'\nimport type { Node } from '@milkdown/prose/model'\nimport { TextSelection } from '@milkdown/prose/state'\nimport type { EditorView } from '@milkdown/prose/view'\nimport debounce from 'lodash.debounce'\nimport type { VirtualElement } from '@floating-ui/dom'\nimport { computePosition, flip, offset } from '@floating-ui/dom'\n\n/// Options for slash provider.\nexport interface SlashProviderOptions {\n  /// The slash content.\n  content: HTMLElement\n  /// The debounce time for updating slash, 200ms by default.\n  debounce?: number\n  /// The function to determine whether the tooltip should be shown.\n  shouldShow?: (view: EditorView, prevState?: EditorState) => boolean\n  /// The key trigger for shouldShow, '/' by default.\n  trigger?: string | string[]\n  /// The offset to get the block. Default is 0.\n  offset?: number | {\n    mainAxis?: number\n    crossAxis?: number\n    alignmentAxis?: number | null\n  }\n}\n\n/// A provider for creating slash.\nexport class SlashProvider {\n  /// The root element of the slash.\n  element: HTMLElement\n\n  /// @internal\n  #initialized = false\n\n  /// @internal\n  readonly #debounce: number\n\n  /// @internal\n  readonly #trigger: string | string[]\n\n  /// @internal\n  readonly #shouldShow: (view: EditorView, prevState?: EditorState) => boolean\n\n  /// The offset to get the block. Default is 0.\n  readonly #offset?: number | {\n    mainAxis?: number\n    crossAxis?: number\n    alignmentAxis?: number | null\n  }\n\n  /// On show callback.\n  onShow = () => {}\n\n  /// On hide callback.\n  onHide = () => {}\n\n  constructor(options: SlashProviderOptions) {\n    this.element = options.content\n    this.#debounce = options.debounce ?? 200\n    this.#shouldShow = options.shouldShow ?? this.#_shouldShow\n    this.#trigger = options.trigger ?? '/'\n    this.#offset = options.offset\n  }\n\n  /// @internal\n  #onUpdate = (view: EditorView, prevState?: EditorState): void => {\n    const { state, composing } = view\n    const { selection, doc } = state\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n    const isSame = prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection)\n\n    if (!this.#initialized) {\n      view.dom.parentElement?.appendChild(this.element)\n      this.#initialized = true\n    }\n\n    if (composing || isSame)\n      return\n\n    if (!this.#shouldShow(view, prevState)) {\n      this.hide()\n      return\n    }\n\n    const virtualEl: VirtualElement = {\n      getBoundingClientRect: () => posToDOMRect(view, from, to),\n    }\n    computePosition(virtualEl, this.element, {\n      placement: 'bottom-start',\n      middleware: [flip(), offset(this.#offset)],\n    })\n      .then(({ x, y }) => {\n        Object.assign(this.element.style, {\n          left: `${x}px`,\n          top: `${y}px`,\n        })\n      })\n\n    this.show()\n  }\n\n  /// @internal\n  #_shouldShow(view: EditorView): boolean {\n    const currentTextBlockContent = this.getContent(view)\n\n    if (!currentTextBlockContent)\n      return false\n\n    const target = currentTextBlockContent.at(-1)\n\n    if (!target)\n      return false\n\n    return Array.isArray(this.#trigger) ? this.#trigger.includes(target) : this.#trigger === target\n  }\n\n  /// Update provider state by editor view.\n  update = (view: EditorView, prevState?: EditorState): void => {\n    const updater = debounce(this.#onUpdate, this.#debounce)\n\n    updater(view, prevState)\n  }\n\n  /// Get the content of the current text block.\n  /// Pass the `matchNode` function to determine whether the current node should be matched, by default, it will match the paragraph node.\n  getContent = (view: EditorView, matchNode: (node: Node) => boolean = node => node.type.name === 'paragraph'): string | undefined => {\n    const { selection } = view.state\n    const { empty, $from } = selection\n    const isTextBlock = view.state.selection instanceof TextSelection\n\n    const isSlashChildren = this.element.contains(document.activeElement)\n\n    const notHasFocus = !view.hasFocus() && !isSlashChildren\n\n    const isReadonly = !view.editable\n\n    const paragraph = findParentNode(matchNode)(view.state.selection)\n\n    const isNotInParagraph = !paragraph\n\n    if (notHasFocus || isReadonly || !empty || !isTextBlock || isNotInParagraph)\n      return\n\n    return $from.parent.textBetween(Math.max(0, $from.parentOffset - 500), $from.parentOffset, undefined, '\\uFFFC')\n  }\n\n  /// Destroy the slash.\n  destroy = () => {\n  }\n\n  /// Show the slash.\n  show = () => {\n    this.element.dataset.show = 'true'\n    this.onShow()\n  }\n\n  /// Hide the slash.\n  hide = () => {\n    this.element.dataset.show = 'false'\n    this.onHide()\n  }\n}\n"],"names":["slashFactory","id","slashSpec","$ctx","slashPlugin","$prose","ctx","spec","Plugin","PluginKey","result","SlashProvider","options","__privateAdd","_SlashProvider_instances","_initialized","_debounce","_trigger","_shouldShow","_offset","_onUpdate","__privateSet","view","prevState","state","composing","selection","doc","ranges","from","range","to","isSame","__privateGet","_a","computePosition","posToDOMRect","flip","offset","x","y","debounce","matchNode","node","empty","$from","isTextBlock","TextSelection","isSlashChildren","notHasFocus","isReadonly","isNotInParagraph","findParentNode","__privateMethod","_shouldShow_fn","currentTextBlockContent","target"],"mappings":"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"}