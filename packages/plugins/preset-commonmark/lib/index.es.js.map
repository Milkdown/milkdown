{"version":3,"file":"index.es.js","sources":["../src/__internal__/serialize-text.ts","../src/__internal__/with-meta.ts","../src/mark/emphasis.ts","../src/mark/strong.ts","../src/mark/inline-code.ts","../src/mark/link.ts","../src/node/doc.ts","../src/node/paragraph.ts","../src/node/heading.ts","../src/node/blockquote.ts","../src/node/code-block.ts","../src/node/image.ts","../src/node/hardbreak.ts","../src/node/hr.ts","../src/node/bullet-list.ts","../src/node/ordered-list.ts","../src/node/list-item.ts","../src/node/text.ts","../src/node/html.ts","../src/composed/schema.ts","../src/composed/inputrules.ts","../src/composed/commands.ts","../src/composed/keymap.ts","../src/plugin/remark-add-order-in-list-plugin.ts","../src/plugin/remark-line-break.ts","../src/plugin/remark-inline-link-plugin.ts","../src/plugin/remark-html-transformer.ts","../src/plugin/remark-marker-plugin.ts","../src/plugin/inline-nodes-cursor-plugin.ts","../src/plugin/hardbreak-clear-mark-plugin.ts","../src/plugin/hardbreak-filter-plugin.ts","../src/plugin/sync-heading-id-plugin.ts","../src/plugin/sync-list-order-plugin.ts","../src/composed/plugins.ts","../src/index.ts"],"sourcesContent":["import type { SerializerState } from '@milkdown/transformer'\nimport type { Node } from '@milkdown/prose/model'\nimport { Fragment } from '@milkdown/prose/model'\n\nexport function serializeText(state: SerializerState, node: Node) {\n  const lastIsHardBreak =\n    node.childCount >= 1 && node.lastChild?.type.name === 'hardbreak'\n  if (!lastIsHardBreak) {\n    state.next(node.content)\n    return\n  }\n\n  const contentArr: Node[] = []\n  node.content.forEach((n, _, i) => {\n    if (i === node.childCount - 1) return\n\n    contentArr.push(n)\n  })\n  state.next(Fragment.fromArray(contentArr))\n}\n","import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-commonmark',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n","import { commandsCtx, remarkStringifyOptionsCtx } from '@milkdown/core'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { markRule } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the emphasis mark.\nexport const emphasisAttr = $markAttr('emphasis')\n\nwithMeta(emphasisAttr, {\n  displayName: 'Attr<emphasis>',\n  group: 'Emphasis',\n})\n\n/// Emphasis mark schema.\nexport const emphasisSchema = $markSchema('emphasis', (ctx) => ({\n  attrs: {\n    marker: {\n      default: ctx.get(remarkStringifyOptionsCtx).emphasis || '*',\n    },\n  },\n  parseDOM: [\n    { tag: 'i' },\n    { tag: 'em' },\n    { style: 'font-style', getAttrs: (value) => (value === 'italic') as false },\n  ],\n  toDOM: (mark) => ['em', ctx.get(emphasisAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'emphasis',\n    runner: (state, node, markType) => {\n      state.openMark(markType, { marker: node.marker })\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'emphasis',\n    runner: (state, mark) => {\n      state.withMark(mark, 'emphasis', undefined, {\n        marker: mark.attrs.marker,\n      })\n    },\n  },\n}))\n\nwithMeta(emphasisSchema.mark, {\n  displayName: 'MarkSchema<emphasis>',\n  group: 'Emphasis',\n})\n\nwithMeta(emphasisSchema.ctx, {\n  displayName: 'MarkSchemaCtx<emphasis>',\n  group: 'Emphasis',\n})\n\n/// A command to toggle the emphasis mark.\nexport const toggleEmphasisCommand = $command('ToggleEmphasis', (ctx) => () => {\n  return toggleMark(emphasisSchema.type(ctx))\n})\n\nwithMeta(toggleEmphasisCommand, {\n  displayName: 'Command<toggleEmphasisCommand>',\n  group: 'Emphasis',\n})\n\n/// Input rule for use `*` to create emphasis mark.\nexport const emphasisStarInputRule = $inputRule((ctx) => {\n  return markRule(/(?:^|[^*])\\*([^*]+)\\*$/, emphasisSchema.type(ctx), {\n    getAttr: () => ({\n      marker: '*',\n    }),\n    updateCaptured: ({ fullMatch, start }) =>\n      !fullMatch.startsWith('*')\n        ? { fullMatch: fullMatch.slice(1), start: start + 1 }\n        : {},\n  })\n})\n\nwithMeta(emphasisStarInputRule, {\n  displayName: 'InputRule<emphasis>|Star',\n  group: 'Emphasis',\n})\n\n/// Input rule for use `_` to create emphasis mark.\nexport const emphasisUnderscoreInputRule = $inputRule((ctx) => {\n  return markRule(/(?:^|[^_])_([^_]+)_$/, emphasisSchema.type(ctx), {\n    getAttr: () => ({\n      marker: '_',\n    }),\n    updateCaptured: ({ fullMatch, start }) =>\n      !fullMatch.startsWith('_')\n        ? { fullMatch: fullMatch.slice(1), start: start + 1 }\n        : {},\n  })\n})\n\nwithMeta(emphasisUnderscoreInputRule, {\n  displayName: 'InputRule<emphasis>|Underscore',\n  group: 'Emphasis',\n})\n\n/// Keymap for the emphasis mark.\n/// - `Mod-i` - Toggle the emphasis mark.\nexport const emphasisKeymap = $useKeymap('emphasisKeymap', {\n  ToggleEmphasis: {\n    shortcuts: 'Mod-i',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleEmphasisCommand.key)\n    },\n  },\n})\n\nwithMeta(emphasisKeymap.ctx, {\n  displayName: 'KeymapCtx<emphasis>',\n  group: 'Emphasis',\n})\n\nwithMeta(emphasisKeymap.shortcuts, {\n  displayName: 'Keymap<emphasis>',\n  group: 'Emphasis',\n})\n","import { commandsCtx, remarkStringifyOptionsCtx } from '@milkdown/core'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { markRule } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strong mark.\nexport const strongAttr = $markAttr('strong')\n\nwithMeta(strongAttr, {\n  displayName: 'Attr<strong>',\n  group: 'Strong',\n})\n\n/// Strong mark schema.\nexport const strongSchema = $markSchema('strong', (ctx) => ({\n  attrs: {\n    marker: {\n      default: ctx.get(remarkStringifyOptionsCtx).strong || '*',\n    },\n  },\n  parseDOM: [\n    { tag: 'b' },\n    { tag: 'strong' },\n    { style: 'font-style', getAttrs: (value) => (value === 'bold') as false },\n  ],\n  toDOM: (mark) => ['strong', ctx.get(strongAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'strong',\n    runner: (state, node, markType) => {\n      state.openMark(markType, { marker: node.marker })\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'strong',\n    runner: (state, mark) => {\n      state.withMark(mark, 'strong', undefined, {\n        marker: mark.attrs.marker,\n      })\n    },\n  },\n}))\n\nwithMeta(strongSchema.mark, {\n  displayName: 'MarkSchema<strong>',\n  group: 'Strong',\n})\n\nwithMeta(strongSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strong>',\n  group: 'Strong',\n})\n\n/// A command to toggle the strong mark.\nexport const toggleStrongCommand = $command('ToggleStrong', (ctx) => () => {\n  return toggleMark(strongSchema.type(ctx))\n})\n\nwithMeta(toggleStrongCommand, {\n  displayName: 'Command<toggleStrongCommand>',\n  group: 'Strong',\n})\n\n/// A input rule that will capture the strong mark.\nexport const strongInputRule = $inputRule((ctx) => {\n  return markRule(/(?:\\*\\*|__)([^*_]+)(?:\\*\\*|__)$/, strongSchema.type(ctx), {\n    getAttr: (match) => {\n      return {\n        marker: match[0].startsWith('*') ? '*' : '_',\n      }\n    },\n  })\n})\n\nwithMeta(strongInputRule, {\n  displayName: 'InputRule<strong>',\n  group: 'Strong',\n})\n\n/// Keymap for the strong mark.\n/// - `Mod-b` - Toggle the strong mark.\nexport const strongKeymap = $useKeymap('strongKeymap', {\n  ToggleBold: {\n    shortcuts: ['Mod-b'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrongCommand.key)\n    },\n  },\n})\n\nwithMeta(strongKeymap.ctx, {\n  displayName: 'KeymapCtx<strong>',\n  group: 'Strong',\n})\n\nwithMeta(strongKeymap.shortcuts, {\n  displayName: 'Keymap<strong>',\n  group: 'Strong',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport type { MarkType } from '@milkdown/prose/model'\nimport {\n  $command,\n  $inputRule,\n  $markAttr,\n  $markSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { markRule } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the inlineCode mark.\nexport const inlineCodeAttr = $markAttr('inlineCode')\n\nwithMeta(inlineCodeAttr, {\n  displayName: 'Attr<inlineCode>',\n  group: 'InlineCode',\n})\n\n/// InlineCode mark schema.\nexport const inlineCodeSchema = $markSchema('inlineCode', (ctx) => ({\n  priority: 100,\n  code: true,\n  inclusive: false,\n  parseDOM: [{ tag: 'code' }],\n  toDOM: (mark) => ['code', ctx.get(inlineCodeAttr.key)(mark)],\n  parseMarkdown: {\n    match: (node) => node.type === 'inlineCode',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.addText(node.value as string)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'inlineCode',\n    runner: (state, mark, node) => {\n      state.withMark(mark, 'inlineCode', node.text || '')\n    },\n  },\n}))\n\nwithMeta(inlineCodeSchema.mark, {\n  displayName: 'MarkSchema<inlineCode>',\n  group: 'InlineCode',\n})\n\nwithMeta(inlineCodeSchema.ctx, {\n  displayName: 'MarkSchemaCtx<inlineCode>',\n  group: 'InlineCode',\n})\n\n/// A command to toggle the inlineCode mark.\nexport const toggleInlineCodeCommand = $command(\n  'ToggleInlineCode',\n  (ctx) => () => (state, dispatch) => {\n    const { selection, tr } = state\n    if (selection.empty) return false\n    const { from, to } = selection\n\n    const has = state.doc.rangeHasMark(from, to, inlineCodeSchema.type(ctx))\n    // remove exists inlineCode mark if have\n    if (has) {\n      dispatch?.(tr.removeMark(from, to, inlineCodeSchema.type(ctx)))\n      return true\n    }\n\n    const restMarksName = Object.keys(state.schema.marks).filter(\n      (x) => x !== inlineCodeSchema.type.name\n    )\n\n    // remove other marks\n    restMarksName\n      .map((name) => state.schema.marks[name] as MarkType)\n      .forEach((t) => {\n        tr.removeMark(from, to, t)\n      })\n\n    // add inlineCode mark\n    dispatch?.(tr.addMark(from, to, inlineCodeSchema.type(ctx).create()))\n    return true\n  }\n)\n\nwithMeta(toggleInlineCodeCommand, {\n  displayName: 'Command<toggleInlineCodeCommand>',\n  group: 'InlineCode',\n})\n\n/// Input rule for create inlineCode mark.\nexport const inlineCodeInputRule = $inputRule((ctx) => {\n  return markRule(/(?:`)([^`]+)(?:`)$/, inlineCodeSchema.type(ctx))\n})\n\nwithMeta(inlineCodeInputRule, {\n  displayName: 'InputRule<inlineCodeInputRule>',\n  group: 'InlineCode',\n})\n\n/// Keymap for the inlineCode mark.\n/// - `Mod-e` - Toggle the inlineCode mark.\nexport const inlineCodeKeymap = $useKeymap('inlineCodeKeymap', {\n  ToggleInlineCode: {\n    shortcuts: 'Mod-e',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleInlineCodeCommand.key)\n    },\n  },\n})\n\nwithMeta(inlineCodeKeymap.ctx, {\n  displayName: 'KeymapCtx<inlineCode>',\n  group: 'InlineCode',\n})\n\nwithMeta(inlineCodeKeymap.shortcuts, {\n  displayName: 'Keymap<inlineCode>',\n  group: 'InlineCode',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport type { Node as ProseNode } from '@milkdown/prose/model'\nimport { TextSelection } from '@milkdown/prose/state'\nimport { $command, $markAttr, $markSchema } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the link mark.\nexport const linkAttr = $markAttr('link')\n\nwithMeta(linkAttr, {\n  displayName: 'Attr<link>',\n  group: 'Link',\n})\n\n/// Link mark schema.\nexport const linkSchema = $markSchema('link', (ctx) => ({\n  attrs: {\n    href: {},\n    title: { default: null },\n  },\n  parseDOM: [\n    {\n      tag: 'a[href]',\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n        return {\n          href: dom.getAttribute('href'),\n          title: dom.getAttribute('title'),\n        }\n      },\n    },\n  ],\n  toDOM: (mark) => ['a', { ...ctx.get(linkAttr.key)(mark), ...mark.attrs }],\n  parseMarkdown: {\n    match: (node) => node.type === 'link',\n    runner: (state, node, markType) => {\n      const url = node.url as string\n      const title = node.title as string\n      state.openMark(markType, { href: url, title })\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: (mark) => mark.type.name === 'link',\n    runner: (state, mark) => {\n      state.withMark(mark, 'link', undefined, {\n        title: mark.attrs.title,\n        url: mark.attrs.href,\n      })\n    },\n  },\n}))\n\nwithMeta(linkSchema.mark, {\n  displayName: 'MarkSchema<link>',\n  group: 'Link',\n})\n\n/// @internal\nexport interface UpdateLinkCommandPayload {\n  href?: string\n  title?: string\n}\n/// A command to toggle the link mark.\n/// You can pass the `href` and `title` to the link.\nexport const toggleLinkCommand = $command(\n  'ToggleLink',\n  (ctx) =>\n    (payload: UpdateLinkCommandPayload = {}) =>\n      toggleMark(linkSchema.type(ctx), payload)\n)\n\nwithMeta(toggleLinkCommand, {\n  displayName: 'Command<toggleLinkCommand>',\n  group: 'Link',\n})\n\n/// A command to update the link mark.\n/// You can pass the `href` and `title` to update the link.\nexport const updateLinkCommand = $command(\n  'UpdateLink',\n  (ctx) =>\n    (payload: UpdateLinkCommandPayload = {}) =>\n    (state, dispatch) => {\n      if (!dispatch) return false\n\n      let node: ProseNode | undefined\n      let pos = -1\n      const { selection } = state\n      const { from, to } = selection\n      state.doc.nodesBetween(from, from === to ? to + 1 : to, (n, p) => {\n        if (linkSchema.type(ctx).isInSet(n.marks)) {\n          node = n\n          pos = p\n          return false\n        }\n\n        return undefined\n      })\n\n      if (!node) return false\n\n      const mark = node.marks.find(({ type }) => type === linkSchema.type(ctx))\n      if (!mark) return false\n\n      const start = pos\n      const end = pos + node.nodeSize\n      const { tr } = state\n      const linkMark = linkSchema\n        .type(ctx)\n        .create({ ...mark.attrs, ...payload })\n      if (!linkMark) return false\n\n      dispatch(\n        tr\n          .removeMark(start, end, mark)\n          .addMark(start, end, linkMark)\n          .setSelection(new TextSelection(tr.selection.$anchor))\n          .scrollIntoView()\n      )\n\n      return true\n    }\n)\n\nwithMeta(updateLinkCommand, {\n  displayName: 'Command<updateLinkCommand>',\n  group: 'Link',\n})\n","import { $node } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// The top-level document node.\nexport const docSchema = $node('doc', () => ({\n  content: 'block+',\n  parseMarkdown: {\n    match: ({ type }) => type === 'root',\n    runner: (state, node, type) => {\n      state.injectRoot(node, type)\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'doc',\n    runner: (state, node) => {\n      state.openNode('root')\n      state.next(node.content)\n    },\n  },\n}))\n\nwithMeta(docSchema, {\n  displayName: 'NodeSchema<doc>',\n  group: 'Doc',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { $command, $nodeAttr, $nodeSchema, $useKeymap } from '@milkdown/utils'\nimport { serializeText, withMeta } from '../__internal__'\n\n/// HTML attributes for paragraph node.\nexport const paragraphAttr = $nodeAttr('paragraph')\n\nwithMeta(paragraphAttr, {\n  displayName: 'Attr<paragraph>',\n  group: 'Paragraph',\n})\n\n/// Schema for paragraph node.\nexport const paragraphSchema = $nodeSchema('paragraph', (ctx) => ({\n  content: 'inline*',\n  group: 'block',\n  parseDOM: [{ tag: 'p' }],\n  toDOM: (node) => ['p', ctx.get(paragraphAttr.key)(node), 0],\n  parseMarkdown: {\n    match: (node) => node.type === 'paragraph',\n    runner: (state, node, type) => {\n      state.openNode(type)\n      if (node.children) state.next(node.children)\n      else state.addText((node.value || '') as string)\n\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'paragraph',\n    runner: (state, node) => {\n      state.openNode('paragraph')\n      serializeText(state, node)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(paragraphSchema.node, {\n  displayName: 'NodeSchema<paragraph>',\n  group: 'Paragraph',\n})\nwithMeta(paragraphSchema.ctx, {\n  displayName: 'NodeSchemaCtx<paragraph>',\n  group: 'Paragraph',\n})\n\n/// This command can turn the selected block into paragraph.\nexport const turnIntoTextCommand = $command(\n  'TurnIntoText',\n  (ctx) => () => setBlockType(paragraphSchema.type(ctx))\n)\n\nwithMeta(turnIntoTextCommand, {\n  displayName: 'Command<turnIntoTextCommand>',\n  group: 'Paragraph',\n})\n\n/// Keymap for paragraph node.\n/// - `<Mod-Alt-0>`: Turn the selected block into paragraph.\nexport const paragraphKeymap = $useKeymap('paragraphKeymap', {\n  TurnIntoText: {\n    shortcuts: 'Mod-Alt-0',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(turnIntoTextCommand.key)\n    },\n  },\n})\n\nwithMeta(paragraphKeymap.ctx, {\n  displayName: 'KeymapCtx<paragraph>',\n  group: 'Paragraph',\n})\n\nwithMeta(paragraphKeymap.shortcuts, {\n  displayName: 'Keymap<paragraph>',\n  group: 'Paragraph',\n})\n","import { commandsCtx, editorViewCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules'\nimport type { Node } from '@milkdown/prose/model'\nimport {\n  $command,\n  $ctx,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport slugify from '@sindresorhus/slugify'\nimport { serializeText, withMeta } from '../__internal__'\nimport { paragraphSchema } from './paragraph'\n\nconst headingIndex = Array(6)\n  .fill(0)\n  .map((_, i) => i + 1)\n\nfunction defaultHeadingIdGenerator(node: Node) {\n  return slugify(node.textContent)\n}\n\n/// This is a slice contains a function to generate heading id.\n/// You can configure it to generate id in your own way.\nexport const headingIdGenerator = $ctx(\n  defaultHeadingIdGenerator,\n  'headingIdGenerator'\n)\n\nwithMeta(headingIdGenerator, {\n  displayName: 'Ctx<HeadingIdGenerator>',\n  group: 'Heading',\n})\n\n/// HTML attributes for heading node.\nexport const headingAttr = $nodeAttr('heading')\n\nwithMeta(headingAttr, {\n  displayName: 'Attr<heading>',\n  group: 'Heading',\n})\n\n/// Schema for heading node.\nexport const headingSchema = $nodeSchema('heading', (ctx) => {\n  const getId = ctx.get(headingIdGenerator.key)\n  return {\n    content: 'inline*',\n    group: 'block',\n    defining: true,\n    attrs: {\n      id: {\n        default: '',\n      },\n      level: {\n        default: 1,\n      },\n    },\n    parseDOM: headingIndex.map((x) => ({\n      tag: `h${x}`,\n      getAttrs: (node) => {\n        if (!(node instanceof HTMLElement)) throw expectDomTypeError(node)\n\n        return { level: x, id: node.id }\n      },\n    })),\n    toDOM: (node) => {\n      return [\n        `h${node.attrs.level}`,\n        {\n          ...ctx.get(headingAttr.key)(node),\n          id: node.attrs.id || getId(node),\n        },\n        0,\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'heading',\n      runner: (state, node, type) => {\n        const depth = node.depth as number\n        state.openNode(type, { level: depth })\n        state.next(node.children)\n        state.closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'heading',\n      runner: (state, node) => {\n        state.openNode('heading', undefined, { depth: node.attrs.level })\n        serializeText(state, node)\n        state.closeNode()\n      },\n    },\n  }\n})\n\nwithMeta(headingSchema.node, {\n  displayName: 'NodeSchema<heading>',\n  group: 'Heading',\n})\n\nwithMeta(headingSchema.ctx, {\n  displayName: 'NodeSchemaCtx<heading>',\n  group: 'Heading',\n})\n\n/// This input rule can turn the selected block into heading.\n/// You can input numbers of `#` and a `space` to create heading.\nexport const wrapInHeadingInputRule = $inputRule((ctx) => {\n  return textblockTypeInputRule(\n    /^(?<hashes>#+)\\s$/,\n    headingSchema.type(ctx),\n    (match) => {\n      const x = match.groups?.hashes?.length || 0\n\n      const view = ctx.get(editorViewCtx)\n      const { $from } = view.state.selection\n      const node = $from.node()\n      if (node.type.name === 'heading') {\n        let level = Number(node.attrs.level) + Number(x)\n        if (level > 6) level = 6\n\n        return { level }\n      }\n      return { level: x }\n    }\n  )\n})\n\nwithMeta(wrapInHeadingInputRule, {\n  displayName: 'InputRule<wrapInHeadingInputRule>',\n  group: 'Heading',\n})\n\n/// This command can turn the selected block into heading.\n/// You can pass the level of heading to this command.\n/// By default, the level is 1, which means it will create a `h1` element.\nexport const wrapInHeadingCommand = $command('WrapInHeading', (ctx) => {\n  return (level?: number) => {\n    level ??= 1\n\n    if (level < 1) return setBlockType(paragraphSchema.type(ctx))\n\n    return setBlockType(headingSchema.type(ctx), { level })\n  }\n})\n\nwithMeta(wrapInHeadingCommand, {\n  displayName: 'Command<wrapInHeadingCommand>',\n  group: 'Heading',\n})\n\n/// This command can downgrade the selected heading.\n/// For example, if you have a `h2` element, and you call this command, you will get a `h1` element.\n/// If the element is already a `h1` element, it will turn it into a `p` element.\nexport const downgradeHeadingCommand = $command(\n  'DowngradeHeading',\n  (ctx) => () => (state, dispatch, view) => {\n    const { $from } = state.selection\n    const node = $from.node()\n    if (\n      node.type !== headingSchema.type(ctx) ||\n      !state.selection.empty ||\n      $from.parentOffset !== 0\n    )\n      return false\n\n    const level = node.attrs.level - 1\n    if (!level)\n      return setBlockType(paragraphSchema.type(ctx))(state, dispatch, view)\n\n    dispatch?.(\n      state.tr.setNodeMarkup(state.selection.$from.before(), undefined, {\n        ...node.attrs,\n        level,\n      })\n    )\n    return true\n  }\n)\n\nwithMeta(downgradeHeadingCommand, {\n  displayName: 'Command<downgradeHeadingCommand>',\n  group: 'Heading',\n})\n\n/// Keymap for heading node.\n/// - `<Mod-Alt-{1-6}>`: Turn the selected block into `h{1-6}` element.\n/// - `<Delete>/<Backspace>`: Downgrade the selected heading.\nexport const headingKeymap = $useKeymap('headingKeymap', {\n  TurnIntoH1: {\n    shortcuts: 'Mod-Alt-1',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 1)\n    },\n  },\n  TurnIntoH2: {\n    shortcuts: 'Mod-Alt-2',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 2)\n    },\n  },\n  TurnIntoH3: {\n    shortcuts: 'Mod-Alt-3',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 3)\n    },\n  },\n  TurnIntoH4: {\n    shortcuts: 'Mod-Alt-4',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 4)\n    },\n  },\n  TurnIntoH5: {\n    shortcuts: 'Mod-Alt-5',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 5)\n    },\n  },\n  TurnIntoH6: {\n    shortcuts: 'Mod-Alt-6',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInHeadingCommand.key, 6)\n    },\n  },\n  DowngradeHeading: {\n    shortcuts: ['Delete', 'Backspace'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(downgradeHeadingCommand.key)\n    },\n  },\n})\n\nwithMeta(headingKeymap.ctx, {\n  displayName: 'KeymapCtx<heading>',\n  group: 'Heading',\n})\n\nwithMeta(headingKeymap.shortcuts, {\n  displayName: 'Keymap<heading>',\n  group: 'Heading',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport type { $NodeSchema } from '@milkdown/utils'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for blockquote node.\nexport const blockquoteAttr = $nodeAttr('blockquote')\n\nwithMeta(blockquoteAttr, {\n  displayName: 'Attr<blockquote>',\n  group: 'Blockquote',\n})\n\n/// Schema for blockquote node.\nexport const blockquoteSchema: $NodeSchema<'blockquote'> = $nodeSchema(\n  'blockquote',\n  (ctx) => ({\n    content: 'block+',\n    group: 'block',\n    defining: true,\n    parseDOM: [{ tag: 'blockquote' }],\n    toDOM: (node) => ['blockquote', ctx.get(blockquoteAttr.key)(node), 0],\n    parseMarkdown: {\n      match: ({ type }) => type === 'blockquote',\n      runner: (state, node, type) => {\n        state.openNode(type).next(node.children).closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'blockquote',\n      runner: (state, node) => {\n        state.openNode('blockquote').next(node.content).closeNode()\n      },\n    },\n  })\n)\n\nwithMeta(blockquoteSchema.node, {\n  displayName: 'NodeSchema<blockquote>',\n  group: 'Blockquote',\n})\n\nwithMeta(blockquoteSchema.ctx, {\n  displayName: 'NodeSchemaCtx<blockquote>',\n  group: 'Blockquote',\n})\n\n/// This input rule will convert a line that starts with `> ` into a blockquote.\n/// You can type `> ` at the start of a line to create a blockquote.\nexport const wrapInBlockquoteInputRule = $inputRule((ctx) =>\n  wrappingInputRule(/^\\s*>\\s$/, blockquoteSchema.type(ctx))\n)\n\nwithMeta(wrapInBlockquoteInputRule, {\n  displayName: 'InputRule<wrapInBlockquoteInputRule>',\n  group: 'Blockquote',\n})\n\n/// This command will wrap the current selection in a blockquote.\nexport const wrapInBlockquoteCommand = $command(\n  'WrapInBlockquote',\n  (ctx) => () => wrapIn(blockquoteSchema.type(ctx))\n)\n\nwithMeta(wrapInBlockquoteCommand, {\n  displayName: 'Command<wrapInBlockquoteCommand>',\n  group: 'Blockquote',\n})\n\n/// Keymap for blockquote.\n/// - `Mod-Shift-b`: Wrap selection in blockquote.\nexport const blockquoteKeymap = $useKeymap('blockquoteKeymap', {\n  WrapInBlockquote: {\n    shortcuts: 'Mod-Shift-b',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInBlockquoteCommand.key)\n    },\n  },\n})\n\nwithMeta(blockquoteKeymap.ctx, {\n  displayName: 'KeymapCtx<blockquote>',\n  group: 'Blockquote',\n})\n\nwithMeta(blockquoteKeymap.shortcuts, {\n  displayName: 'Keymap<blockquote>',\n  group: 'Blockquote',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for code block node.\nexport const codeBlockAttr = $nodeAttr('codeBlock', () => ({\n  pre: {},\n  code: {},\n}))\n\nwithMeta(codeBlockAttr, {\n  displayName: 'Attr<codeBlock>',\n  group: 'CodeBlock',\n})\n\n/// Schema for code block node.\nexport const codeBlockSchema = $nodeSchema('code_block', (ctx) => {\n  return {\n    content: 'text*',\n    group: 'block',\n    marks: '',\n    defining: true,\n    code: true,\n    attrs: {\n      language: {\n        default: '',\n      },\n    },\n    parseDOM: [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return { language: dom.dataset.language }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      const attr = ctx.get(codeBlockAttr.key)(node)\n      return [\n        'pre',\n        {\n          ...attr.pre,\n          'data-language': node.attrs.language,\n        },\n        ['code', attr.code, 0],\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'code',\n      runner: (state, node, type) => {\n        const language = node.lang as string\n        const value = node.value as string\n        state.openNode(type, { language })\n        if (value) state.addText(value)\n\n        state.closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'code_block',\n      runner: (state, node) => {\n        state.addNode('code', undefined, node.content.firstChild?.text || '', {\n          lang: node.attrs.language,\n        })\n      },\n    },\n  }\n})\n\nwithMeta(codeBlockSchema.node, {\n  displayName: 'NodeSchema<codeBlock>',\n  group: 'CodeBlock',\n})\n\nwithMeta(codeBlockSchema.ctx, {\n  displayName: 'NodeSchemaCtx<codeBlock>',\n  group: 'CodeBlock',\n})\n\n/// A input rule for creating code block.\n/// For example, ` ```javascript ` will create a code block with language javascript.\nexport const createCodeBlockInputRule = $inputRule((ctx) =>\n  textblockTypeInputRule(\n    /^```(?<language>[a-z]*)?[\\s\\n]$/,\n    codeBlockSchema.type(ctx),\n    (match) => ({\n      language: match.groups?.language ?? '',\n    })\n  )\n)\n\nwithMeta(createCodeBlockInputRule, {\n  displayName: 'InputRule<createCodeBlockInputRule>',\n  group: 'CodeBlock',\n})\n\n/// A command for creating code block.\n/// You can pass the language of the code block as the parameter.\nexport const createCodeBlockCommand = $command(\n  'CreateCodeBlock',\n  (ctx) =>\n    (language = '') =>\n      setBlockType(codeBlockSchema.type(ctx), { language })\n)\n\nwithMeta(createCodeBlockCommand, {\n  displayName: 'Command<createCodeBlockCommand>',\n  group: 'CodeBlock',\n})\n\n/// A command for updating the code block language of the target position.\nexport const updateCodeBlockLanguageCommand = $command(\n  'UpdateCodeBlockLanguage',\n  () =>\n    (\n      { pos, language }: { pos: number; language: string } = {\n        pos: -1,\n        language: '',\n      }\n    ) =>\n    (state, dispatch) => {\n      if (pos >= 0) {\n        dispatch?.(state.tr.setNodeAttribute(pos, 'language', language))\n        return true\n      }\n\n      return false\n    }\n)\n\nwithMeta(updateCodeBlockLanguageCommand, {\n  displayName: 'Command<updateCodeBlockLanguageCommand>',\n  group: 'CodeBlock',\n})\n\n/// Keymap for code block.\n/// - `Mod-Alt-c`: Create a code block.\nexport const codeBlockKeymap = $useKeymap('codeBlockKeymap', {\n  CreateCodeBlock: {\n    shortcuts: 'Mod-Alt-c',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(createCodeBlockCommand.key)\n    },\n  },\n})\n\nwithMeta(codeBlockKeymap.ctx, {\n  displayName: 'KeymapCtx<codeBlock>',\n  group: 'CodeBlock',\n})\n\nwithMeta(codeBlockKeymap.shortcuts, {\n  displayName: 'Keymap<codeBlock>',\n  group: 'CodeBlock',\n})\n","import { expectDomTypeError } from '@milkdown/exception'\nimport { findSelectedNodeOfType } from '@milkdown/prose'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $command, $inputRule, $nodeAttr, $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for image node.\nexport const imageAttr = $nodeAttr('image')\n\nwithMeta(imageAttr, {\n  displayName: 'Attr<image>',\n  group: 'Image',\n})\n\n/// Schema for image node.\nexport const imageSchema = $nodeSchema('image', (ctx) => {\n  return {\n    inline: true,\n    group: 'inline',\n    selectable: true,\n    draggable: true,\n    marks: '',\n    atom: true,\n    defining: true,\n    isolating: true,\n    attrs: {\n      src: { default: '' },\n      alt: { default: '' },\n      title: { default: '' },\n    },\n    parseDOM: [\n      {\n        tag: 'img[src]',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            src: dom.getAttribute('src') || '',\n            alt: dom.getAttribute('alt') || '',\n            title: dom.getAttribute('title') || dom.getAttribute('alt') || '',\n          }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      return ['img', { ...ctx.get(imageAttr.key)(node), ...node.attrs }]\n    },\n    parseMarkdown: {\n      match: ({ type }) => type === 'image',\n      runner: (state, node, type) => {\n        const url = node.url as string\n        const alt = node.alt as string\n        const title = node.title as string\n        state.addNode(type, {\n          src: url,\n          alt,\n          title,\n        })\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'image',\n      runner: (state, node) => {\n        state.addNode('image', undefined, undefined, {\n          title: node.attrs.title,\n          url: node.attrs.src,\n          alt: node.attrs.alt,\n        })\n      },\n    },\n  }\n})\n\nwithMeta(imageSchema.node, {\n  displayName: 'NodeSchema<image>',\n  group: 'Image',\n})\n\nwithMeta(imageSchema.ctx, {\n  displayName: 'NodeSchemaCtx<image>',\n  group: 'Image',\n})\n\n/// @internal\nexport interface UpdateImageCommandPayload {\n  src?: string\n  title?: string\n  alt?: string\n}\n\n/// This command will insert a image node.\n/// You can pass a payload to set `src`, `alt` and `title` for the image node.\nexport const insertImageCommand = $command(\n  'InsertImage',\n  (ctx) =>\n    (payload: UpdateImageCommandPayload = {}) =>\n    (state, dispatch) => {\n      if (!dispatch) return true\n\n      const { src = '', alt = '', title = '' } = payload\n\n      const node = imageSchema.type(ctx).create({ src, alt, title })\n      if (!node) return true\n\n      dispatch(state.tr.replaceSelectionWith(node).scrollIntoView())\n      return true\n    }\n)\n\nwithMeta(insertImageCommand, {\n  displayName: 'Command<insertImageCommand>',\n  group: 'Image',\n})\n\n/// This command will update the selected image node.\n/// You can pass a payload to update `src`, `alt` and `title` for the image node.\nexport const updateImageCommand = $command(\n  'UpdateImage',\n  (ctx) =>\n    (payload: UpdateImageCommandPayload = {}) =>\n    (state, dispatch) => {\n      const nodeWithPos = findSelectedNodeOfType(\n        state.selection,\n        imageSchema.type(ctx)\n      )\n      if (!nodeWithPos) return false\n\n      const { node, pos } = nodeWithPos\n\n      const newAttrs = { ...node.attrs }\n      const { src, alt, title } = payload\n      if (src !== undefined) newAttrs.src = src\n      if (alt !== undefined) newAttrs.alt = alt\n      if (title !== undefined) newAttrs.title = title\n\n      dispatch?.(\n        state.tr.setNodeMarkup(pos, undefined, newAttrs).scrollIntoView()\n      )\n      return true\n    }\n)\n\nwithMeta(updateImageCommand, {\n  displayName: 'Command<updateImageCommand>',\n  group: 'Image',\n})\n\n/// This input rule will insert a image node.\n/// You can input `![alt](src \"title\")` to insert a image node.\n/// The `title` is optional.\nexport const insertImageInputRule = $inputRule(\n  (ctx) =>\n    new InputRule(\n      /!\\[(?<alt>.*?)]\\((?<filename>.*?)\\s*(?=\"|\\))\"?(?<title>[^\"]+)?\"?\\)/,\n      (state, match, start, end) => {\n        const [matched, alt, src = '', title] = match\n        if (matched)\n          return state.tr.replaceWith(\n            start,\n            end,\n            imageSchema.type(ctx).create({ src, alt, title })\n          )\n\n        return null\n      }\n    )\n)\n\nwithMeta(insertImageInputRule, {\n  displayName: 'InputRule<insertImageInputRule>',\n  group: 'Image',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { Selection, TextSelection } from '@milkdown/prose/state'\nimport { $command, $nodeAttr, $nodeSchema, $useKeymap } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the hardbreak node.\n///\n/// Default value:\n/// - `data-is-inline` - Whether the hardbreak is inline.\nexport const hardbreakAttr = $nodeAttr('hardbreak', (node) => {\n  return {\n    'data-type': 'hardbreak',\n    'data-is-inline': node.attrs.isInline,\n  }\n})\n\nwithMeta(hardbreakAttr, {\n  displayName: 'Attr<hardbreak>',\n  group: 'Hardbreak',\n})\n\n/// Hardbreak node schema.\nexport const hardbreakSchema = $nodeSchema('hardbreak', (ctx) => ({\n  inline: true,\n  group: 'inline',\n  attrs: {\n    isInline: {\n      default: false,\n    },\n  },\n  selectable: false,\n  parseDOM: [\n    { tag: 'br' },\n    {\n      tag: 'span[data-type=\"hardbreak\"]',\n      getAttrs: () => ({ isInline: true }),\n    },\n  ],\n  toDOM: (node) =>\n    node.attrs.isInline\n      ? ['span', ctx.get(hardbreakAttr.key)(node), ' ']\n      : ['br', ctx.get(hardbreakAttr.key)(node)],\n  parseMarkdown: {\n    match: ({ type }) => type === 'break',\n    runner: (state, node, type) => {\n      state.addNode(type, {\n        isInline: Boolean(\n          (node.data as undefined | { isInline: boolean })?.isInline\n        ),\n      })\n    },\n  },\n  leafText: () => '\\n',\n  toMarkdown: {\n    match: (node) => node.type.name === 'hardbreak',\n    runner: (state, node) => {\n      if (node.attrs.isInline) state.addNode('text', undefined, '\\n')\n      else state.addNode('break')\n    },\n  },\n}))\n\nwithMeta(hardbreakSchema.node, {\n  displayName: 'NodeSchema<hardbreak>',\n  group: 'Hardbreak',\n})\n\nwithMeta(hardbreakSchema.ctx, {\n  displayName: 'NodeSchemaCtx<hardbreak>',\n  group: 'Hardbreak',\n})\n\n/// Command to insert a hardbreak.\nexport const insertHardbreakCommand = $command(\n  'InsertHardbreak',\n  (ctx) => () => (state, dispatch) => {\n    const { selection, tr } = state\n    if (!(selection instanceof TextSelection)) return false\n\n    if (selection.empty) {\n      // Transform two successive hardbreak into a new line\n      const node = selection.$from.node()\n      if (node.childCount > 0 && node.lastChild?.type.name === 'hardbreak') {\n        dispatch?.(\n          tr\n            .replaceRangeWith(\n              selection.to - 1,\n              selection.to,\n              state.schema.node('paragraph')\n            )\n            .setSelection(Selection.near(tr.doc.resolve(selection.to)))\n            .scrollIntoView()\n        )\n        return true\n      }\n    }\n    dispatch?.(\n      tr\n        .setMeta('hardbreak', true)\n        .replaceSelectionWith(hardbreakSchema.type(ctx).create())\n        .scrollIntoView()\n    )\n    return true\n  }\n)\n\nwithMeta(insertHardbreakCommand, {\n  displayName: 'Command<insertHardbreakCommand>',\n  group: 'Hardbreak',\n})\n\n/// Keymap for the hardbreak node.\n/// - `Shift-Enter` - Insert a hardbreak.\nexport const hardbreakKeymap = $useKeymap('hardbreakKeymap', {\n  InsertHardbreak: {\n    shortcuts: 'Shift-Enter',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(insertHardbreakCommand.key)\n    },\n  },\n})\n\nwithMeta(hardbreakKeymap.ctx, {\n  displayName: 'KeymapCtx<hardbreak>',\n  group: 'Hardbreak',\n})\n\nwithMeta(hardbreakKeymap.shortcuts, {\n  displayName: 'Keymap<hardbreak>',\n  group: 'Hardbreak',\n})\n","import { InputRule } from '@milkdown/prose/inputrules'\nimport { Selection } from '@milkdown/prose/state'\nimport { $command, $inputRule, $nodeAttr, $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\nimport { paragraphSchema } from './paragraph'\n\n/// HTML attributes for the hr node.\nexport const hrAttr = $nodeAttr('hr')\n\nwithMeta(hrAttr, {\n  displayName: 'Attr<hr>',\n  group: 'Hr',\n})\n\n/// Hr node schema.\nexport const hrSchema = $nodeSchema('hr', (ctx) => ({\n  group: 'block',\n  parseDOM: [{ tag: 'hr' }],\n  toDOM: (node) => ['hr', ctx.get(hrAttr.key)(node)],\n  parseMarkdown: {\n    match: ({ type }) => type === 'thematicBreak',\n    runner: (state, _, type) => {\n      state.addNode(type)\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'hr',\n    runner: (state) => {\n      state.addNode('thematicBreak')\n    },\n  },\n}))\n\nwithMeta(hrSchema.node, {\n  displayName: 'NodeSchema<hr>',\n  group: 'Hr',\n})\n\nwithMeta(hrSchema.ctx, {\n  displayName: 'NodeSchemaCtx<hr>',\n  group: 'Hr',\n})\n\n/// Input rule to insert a hr.\n/// For example, `---` will be converted to a hr.\nexport const insertHrInputRule = $inputRule(\n  (ctx) =>\n    new InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n      const { tr } = state\n\n      if (match[0]) tr.replaceWith(start - 1, end, hrSchema.type(ctx).create())\n\n      return tr\n    })\n)\n\nwithMeta(insertHrInputRule, {\n  displayName: 'InputRule<insertHrInputRule>',\n  group: 'Hr',\n})\n\n/// Command to insert a hr.\nexport const insertHrCommand = $command(\n  'InsertHr',\n  (ctx) => () => (state, dispatch) => {\n    if (!dispatch) return true\n\n    const paragraph = paragraphSchema.node.type(ctx).create()\n    const { tr, selection } = state\n    const { from } = selection\n    const node = hrSchema.type(ctx).create()\n    if (!node) return true\n\n    const _tr = tr.replaceSelectionWith(node).insert(from, paragraph)\n    const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n    if (!sel) return true\n\n    dispatch(_tr.setSelection(sel).scrollIntoView())\n    return true\n  }\n)\n\nwithMeta(insertHrCommand, {\n  displayName: 'Command<insertHrCommand>',\n  group: 'Hr',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for bullet list node.\nexport const bulletListAttr = $nodeAttr('bulletList')\n\nwithMeta(bulletListAttr, {\n  displayName: 'Attr<bulletList>',\n  group: 'BulletList',\n})\n\n/// Schema for bullet list node.\nexport const bulletListSchema = $nodeSchema('bullet_list', (ctx) => {\n  return {\n    content: 'listItem+',\n    group: 'block',\n    attrs: {\n      spread: {\n        default: false,\n      },\n    },\n    parseDOM: [\n      {\n        tag: 'ul',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n          return {\n            spread: dom.dataset.spread,\n          }\n        },\n      },\n    ],\n    toDOM: (node) => {\n      return [\n        'ul',\n        {\n          ...ctx.get(bulletListAttr.key)(node),\n          'data-spread': node.attrs.spread,\n        },\n        0,\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type, ordered }) => type === 'list' && !ordered,\n      runner: (state, node, type) => {\n        const spread = node.spread != null ? `${node.spread}` : 'false'\n        state.openNode(type, { spread }).next(node.children).closeNode()\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'bullet_list',\n      runner: (state, node) => {\n        state\n          .openNode('list', undefined, {\n            ordered: false,\n            spread: node.attrs.spread === 'true',\n          })\n          .next(node.content)\n          .closeNode()\n      },\n    },\n  }\n})\n\nwithMeta(bulletListSchema.node, {\n  displayName: 'NodeSchema<bulletList>',\n  group: 'BulletList',\n})\n\nwithMeta(bulletListSchema.ctx, {\n  displayName: 'NodeSchemaCtx<bulletList>',\n  group: 'BulletList',\n})\n\n/// Input rule for wrapping a block in bullet list node.\nexport const wrapInBulletListInputRule = $inputRule((ctx) =>\n  wrappingInputRule(/^\\s*([-+*])\\s$/, bulletListSchema.type(ctx))\n)\n\nwithMeta(wrapInBulletListInputRule, {\n  displayName: 'InputRule<wrapInBulletListInputRule>',\n  group: 'BulletList',\n})\n\n/// Command for creating bullet list node.\nexport const wrapInBulletListCommand = $command(\n  'WrapInBulletList',\n  (ctx) => () => wrapIn(bulletListSchema.type(ctx))\n)\n\nwithMeta(wrapInBulletListCommand, {\n  displayName: 'Command<wrapInBulletListCommand>',\n  group: 'BulletList',\n})\n\n/// Keymap for bullet list node.\n/// - `Mod-Alt-8`: Wrap a block in bullet list.\nexport const bulletListKeymap = $useKeymap('bulletListKeymap', {\n  WrapInBulletList: {\n    shortcuts: 'Mod-Alt-8',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInBulletListCommand.key)\n    },\n  },\n})\n\nwithMeta(bulletListKeymap.ctx, {\n  displayName: 'KeymapCtx<bulletListKeymap>',\n  group: 'BulletList',\n})\n\nwithMeta(bulletListKeymap.shortcuts, {\n  displayName: 'Keymap<bulletListKeymap>',\n  group: 'BulletList',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport {\n  $command,\n  $inputRule,\n  $nodeAttr,\n  $nodeSchema,\n  $useKeymap,\n} from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for ordered list node.\nexport const orderedListAttr = $nodeAttr('orderedList')\n\nwithMeta(orderedListAttr, {\n  displayName: 'Attr<orderedList>',\n  group: 'OrderedList',\n})\n\n/// Schema for ordered list node.\nexport const orderedListSchema = $nodeSchema('ordered_list', (ctx) => ({\n  content: 'listItem+',\n  group: 'block',\n  attrs: {\n    order: {\n      default: 1,\n    },\n    spread: {\n      default: false,\n    },\n  },\n  parseDOM: [\n    {\n      tag: 'ol',\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n        return {\n          spread: dom.dataset.spread,\n          order: dom.hasAttribute('start')\n            ? Number(dom.getAttribute('start'))\n            : 1,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => [\n    'ol',\n    {\n      ...ctx.get(orderedListAttr.key)(node),\n      ...(node.attrs.order === 1 ? {} : node.attrs.order),\n      'data-spread': node.attrs.spread,\n    },\n    0,\n  ],\n  parseMarkdown: {\n    match: ({ type, ordered }) => type === 'list' && !!ordered,\n    runner: (state, node, type) => {\n      const spread = node.spread != null ? `${node.spread}` : 'true'\n      state.openNode(type, { spread }).next(node.children).closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'ordered_list',\n    runner: (state, node) => {\n      state.openNode('list', undefined, {\n        ordered: true,\n        start: 1,\n        spread: node.attrs.spread === 'true',\n      })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(orderedListSchema.node, {\n  displayName: 'NodeSchema<orderedList>',\n  group: 'OrderedList',\n})\n\nwithMeta(orderedListSchema.ctx, {\n  displayName: 'NodeSchemaCtx<orderedList>',\n  group: 'OrderedList',\n})\n\n/// Input rule for wrapping a block in ordered list node.\nexport const wrapInOrderedListInputRule = $inputRule((ctx) =>\n  wrappingInputRule(\n    /^\\s*(\\d+)\\.\\s$/,\n    orderedListSchema.type(ctx),\n    (match) => ({ order: Number(match[1]) }),\n    (match, node) => node.childCount + node.attrs.order === Number(match[1])\n  )\n)\n\nwithMeta(wrapInOrderedListInputRule, {\n  displayName: 'InputRule<wrapInOrderedListInputRule>',\n  group: 'OrderedList',\n})\n\n/// Command for wrapping a block in ordered list node.\nexport const wrapInOrderedListCommand = $command(\n  'WrapInOrderedList',\n  (ctx) => () => wrapIn(orderedListSchema.type(ctx))\n)\n\nwithMeta(wrapInOrderedListCommand, {\n  displayName: 'Command<wrapInOrderedListCommand>',\n  group: 'OrderedList',\n})\n\n/// Keymap for ordered list node.\n/// - `Mod-Alt-7`: Wrap a block in ordered list.\nexport const orderedListKeymap = $useKeymap('orderedListKeymap', {\n  WrapInOrderedList: {\n    shortcuts: 'Mod-Alt-7',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(wrapInOrderedListCommand.key)\n    },\n  },\n})\n\nwithMeta(orderedListKeymap.ctx, {\n  displayName: 'KeymapCtx<orderedList>',\n  group: 'OrderedList',\n})\n\nwithMeta(orderedListKeymap.shortcuts, {\n  displayName: 'Keymap<orderedList>',\n  group: 'OrderedList',\n})\n","import { commandsCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport {\n  liftListItem,\n  sinkListItem,\n  splitListItem,\n} from '@milkdown/prose/schema-list'\nimport { $command, $nodeAttr, $nodeSchema, $useKeymap } from '@milkdown/utils'\nimport { type Command, TextSelection } from '@milkdown/prose/state'\nimport type { Ctx } from '@milkdown/ctx'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for list item node.\nexport const listItemAttr = $nodeAttr('listItem')\n\nwithMeta(listItemAttr, {\n  displayName: 'Attr<listItem>',\n  group: 'ListItem',\n})\n\n/// Schema for list item node.\nexport const listItemSchema = $nodeSchema('list_item', (ctx) => ({\n  group: 'listItem',\n  content: '(paragraph|blockquote) block*',\n  attrs: {\n    label: {\n      default: '',\n    },\n    listType: {\n      default: 'bullet',\n    },\n    spread: {\n      default: 'true',\n    },\n  },\n  defining: true,\n  parseDOM: [\n    {\n      tag: 'li',\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement)) throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n          listType: dom.dataset.listType,\n          spread: dom.dataset.spread,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => [\n    'li',\n    {\n      ...ctx.get(listItemAttr.key)(node),\n      'data-label': node.attrs.label,\n      'data-list-type': node.attrs.listType,\n      'data-spread': node.attrs.spread,\n    },\n    0,\n  ],\n  parseMarkdown: {\n    match: ({ type }) => type === 'listItem',\n    runner: (state, node, type) => {\n      const label = node.label != null ? `${node.label}.` : ''\n      const listType = node.label != null ? 'ordered' : 'bullet'\n      const spread = node.spread != null ? `${node.spread}` : 'true'\n      state.openNode(type, { label, listType, spread })\n      state.next(node.children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'list_item',\n    runner: (state, node) => {\n      state.openNode('listItem', undefined, {\n        spread: node.attrs.spread === 'true',\n      })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(listItemSchema.node, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\nwithMeta(listItemSchema.ctx, {\n  displayName: 'NodeSchemaCtx<listItem>',\n  group: 'ListItem',\n})\n\n/// The command to sink list item.\n///\n/// For example:\n/// ```md\n/// * List item 1\n/// * List item 2 <- cursor here\n/// ```\n/// Will get:\n/// ```md\n/// * List item 1\n///   * List item 2\n/// ```\nexport const sinkListItemCommand = $command(\n  'SinkListItem',\n  (ctx) => () => sinkListItem(listItemSchema.type(ctx))\n)\n\nwithMeta(sinkListItemCommand, {\n  displayName: 'Command<sinkListItemCommand>',\n  group: 'ListItem',\n})\n\n/// The command to lift list item.\n///\n/// For example:\n/// ```md\n/// * List item 1\n///   * List item 2 <- cursor here\n/// ```\n/// Will get:\n/// ```md\n/// * List item 1\n/// * List item 2\n/// ```\nexport const liftListItemCommand = $command(\n  'LiftListItem',\n  (ctx) => () => liftListItem(listItemSchema.type(ctx))\n)\n\nwithMeta(liftListItemCommand, {\n  displayName: 'Command<liftListItemCommand>',\n  group: 'ListItem',\n})\n\n/// The command to split a list item.\n///\n/// For example:\n/// ```md\n/// * List item 1\n/// * List item 2 <- cursor here\n/// ```\n/// Will get:\n/// ```md\n/// * List item 1\n/// * List item 2\n/// * <- cursor here\n/// ```\nexport const splitListItemCommand = $command(\n  'SplitListItem',\n  (ctx) => () => splitListItem(listItemSchema.type(ctx))\n)\n\nwithMeta(splitListItemCommand, {\n  displayName: 'Command<splitListItemCommand>',\n  group: 'ListItem',\n})\n\nfunction liftFirstListItem(ctx: Ctx): Command {\n  return (state, dispatch, view) => {\n    const { selection } = state\n    if (!(selection instanceof TextSelection)) return false\n\n    const { empty, $from } = selection\n\n    // selection should be empty and at the start of the node\n    if (!empty || $from.parentOffset !== 0) return false\n\n    const parentItem = $from.node(-1)\n    // selection should be in list item and list item should be the first child of the list\n    if (\n      parentItem.type !== listItemSchema.type(ctx) ||\n      parentItem.firstChild !== $from.node()\n    )\n      return false\n\n    const list = $from.node(-2)\n    // list should have only one list item\n    if (list.childCount > 1) return false\n\n    return liftListItem(listItemSchema.type(ctx))(state, dispatch, view)\n  }\n}\n\n/// The command to remove list item **only if**:\n///\n/// - Selection is at the start of the list item.\n/// - List item is the only child of the list.\n///\n/// Most of the time, you shouldn't use this command directly.\nexport const liftFirstListItemCommand = $command(\n  'LiftFirstListItem',\n  (ctx) => () => liftFirstListItem(ctx)\n)\n\nwithMeta(liftFirstListItemCommand, {\n  displayName: 'Command<liftFirstListItemCommand>',\n  group: 'ListItem',\n})\n\n/// Keymap for list item node.\n/// - `<Enter>`: Split the current list item.\n/// - `<Tab>/<Mod-]>`: Sink the current list item.\n/// - `<Shift-Tab>/<Mod-[>`: Lift the current list item.\nexport const listItemKeymap = $useKeymap('listItemKeymap', {\n  NextListItem: {\n    shortcuts: 'Enter',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(splitListItemCommand.key)\n    },\n  },\n  SinkListItem: {\n    shortcuts: ['Tab', 'Mod-]'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(sinkListItemCommand.key)\n    },\n  },\n  LiftListItem: {\n    shortcuts: ['Shift-Tab', 'Mod-['],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(liftListItemCommand.key)\n    },\n  },\n  LiftFirstListItem: {\n    shortcuts: ['Backspace', 'Delete'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(liftFirstListItemCommand.key)\n    },\n  },\n})\n\nwithMeta(listItemKeymap.ctx, {\n  displayName: 'KeymapCtx<listItem>',\n  group: 'ListItem',\n})\n\nwithMeta(listItemKeymap.shortcuts, {\n  displayName: 'Keymap<listItem>',\n  group: 'ListItem',\n})\n","import { $node } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// The bottom-level node.\nexport const textSchema = $node('text', () => ({\n  group: 'inline',\n  parseMarkdown: {\n    match: ({ type }) => type === 'text',\n    runner: (state, node) => {\n      state.addText(node.value as string)\n    },\n  },\n  toMarkdown: {\n    match: (node) => node.type.name === 'text',\n    runner: (state, node) => {\n      state.addNode('text', undefined, node.text as string)\n    },\n  },\n}))\n\nwithMeta(textSchema, {\n  displayName: 'NodeSchema<text>',\n  group: 'Text',\n})\n","import { $nodeAttr, $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\nexport const htmlAttr = $nodeAttr('html')\n\nwithMeta(htmlAttr, {\n  displayName: 'Attr<html>',\n  group: 'Html',\n})\n\nexport const htmlSchema = $nodeSchema('html', (ctx) => {\n  return {\n    atom: true,\n    group: 'inline',\n    inline: true,\n    attrs: {\n      value: {\n        default: '',\n      },\n    },\n    toDOM: (node) => {\n      const span = document.createElement('span')\n      const attr = {\n        ...ctx.get(htmlAttr.key)(node),\n        'data-value': node.attrs.value,\n        'data-type': 'html',\n      }\n      span.textContent = node.attrs.value\n      return ['span', attr, node.attrs.value]\n    },\n    parseDOM: [\n      {\n        tag: 'span[data-type=\"html\"]',\n        getAttrs: (dom) => {\n          return {\n            value: dom.dataset.value ?? '',\n          }\n        },\n      },\n    ],\n    parseMarkdown: {\n      match: ({ type }) => Boolean(type === 'html'),\n      runner: (state, node, type) => {\n        state.addNode(type, { value: node.value as string })\n      },\n    },\n    toMarkdown: {\n      match: (node) => node.type.name === 'html',\n      runner: (state, node) => {\n        state.addNode('html', undefined, node.attrs.value)\n      },\n    },\n  }\n})\n\nwithMeta(htmlSchema.node, {\n  displayName: 'NodeSchema<html>',\n  group: 'Html',\n})\n\nwithMeta(htmlSchema.ctx, {\n  displayName: 'NodeSchemaCtx<html>',\n  group: 'Html',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  emphasisAttr,\n  emphasisSchema,\n  inlineCodeAttr,\n  inlineCodeSchema,\n  linkAttr,\n  linkSchema,\n  strongAttr,\n  strongSchema,\n} from '../mark'\nimport {\n  blockquoteAttr,\n  blockquoteSchema,\n  bulletListAttr,\n  bulletListSchema,\n  codeBlockAttr,\n  codeBlockSchema,\n  docSchema,\n  hardbreakAttr,\n  hardbreakSchema,\n  headingAttr,\n  headingIdGenerator,\n  headingSchema,\n  hrAttr,\n  hrSchema,\n  htmlAttr,\n  htmlSchema,\n  imageAttr,\n  imageSchema,\n  listItemAttr,\n  listItemSchema,\n  orderedListAttr,\n  orderedListSchema,\n  paragraphAttr,\n  paragraphSchema,\n  textSchema,\n} from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  docSchema,\n\n  paragraphAttr,\n  paragraphSchema,\n\n  headingIdGenerator,\n  headingAttr,\n  headingSchema,\n\n  hardbreakAttr,\n  hardbreakSchema,\n\n  blockquoteAttr,\n  blockquoteSchema,\n\n  codeBlockAttr,\n  codeBlockSchema,\n\n  hrAttr,\n  hrSchema,\n\n  imageAttr,\n  imageSchema,\n\n  bulletListAttr,\n  bulletListSchema,\n\n  orderedListAttr,\n  orderedListSchema,\n\n  listItemAttr,\n  listItemSchema,\n\n  emphasisAttr,\n  emphasisSchema,\n\n  strongAttr,\n  strongSchema,\n\n  inlineCodeAttr,\n  inlineCodeSchema,\n\n  linkAttr,\n  linkSchema,\n\n  htmlAttr,\n  htmlSchema,\n\n  textSchema,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  createCodeBlockInputRule,\n  insertHrInputRule,\n  wrapInBlockquoteInputRule,\n  wrapInBulletListInputRule,\n  wrapInHeadingInputRule,\n  wrapInOrderedListInputRule,\n} from '../node'\nimport {\n  emphasisStarInputRule,\n  emphasisUnderscoreInputRule,\n  inlineCodeInputRule,\n  strongInputRule,\n} from '../mark'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  wrapInBlockquoteInputRule,\n  wrapInBulletListInputRule,\n  wrapInOrderedListInputRule,\n  createCodeBlockInputRule,\n  insertHrInputRule,\n  wrapInHeadingInputRule,\n].flat()\n\n/// @internal\nexport const markInputRules: MilkdownPlugin[] = [\n  emphasisStarInputRule,\n  emphasisUnderscoreInputRule,\n  inlineCodeInputRule,\n  strongInputRule,\n]\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  toggleEmphasisCommand,\n  toggleInlineCodeCommand,\n  toggleLinkCommand,\n  toggleStrongCommand,\n  updateLinkCommand,\n} from '../mark'\nimport {\n  createCodeBlockCommand,\n  downgradeHeadingCommand,\n  insertHardbreakCommand,\n  insertHrCommand,\n  insertImageCommand,\n  liftFirstListItemCommand,\n  liftListItemCommand,\n  sinkListItemCommand,\n  splitListItemCommand,\n  turnIntoTextCommand,\n  updateImageCommand,\n  wrapInBlockquoteCommand,\n  wrapInBulletListCommand,\n  wrapInHeadingCommand,\n  wrapInOrderedListCommand,\n} from '../node'\n\n/// @internal\nexport const commands: MilkdownPlugin[] = [\n  turnIntoTextCommand,\n  wrapInBlockquoteCommand,\n  wrapInHeadingCommand,\n  downgradeHeadingCommand,\n  createCodeBlockCommand,\n  insertHardbreakCommand,\n  insertHrCommand,\n\n  insertImageCommand,\n  updateImageCommand,\n\n  wrapInOrderedListCommand,\n  wrapInBulletListCommand,\n  sinkListItemCommand,\n  splitListItemCommand,\n  liftListItemCommand,\n  liftFirstListItemCommand,\n\n  toggleEmphasisCommand,\n  toggleInlineCodeCommand,\n  toggleStrongCommand,\n\n  toggleLinkCommand,\n  updateLinkCommand,\n]\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { emphasisKeymap, inlineCodeKeymap, strongKeymap } from '../mark'\nimport {\n  blockquoteKeymap,\n  bulletListKeymap,\n  codeBlockKeymap,\n  hardbreakKeymap,\n  headingKeymap,\n  listItemKeymap,\n  orderedListKeymap,\n  paragraphKeymap,\n} from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  blockquoteKeymap,\n  codeBlockKeymap,\n  hardbreakKeymap,\n  headingKeymap,\n  listItemKeymap,\n  orderedListKeymap,\n  bulletListKeymap,\n  paragraphKeymap,\n\n  emphasisKeymap,\n  inlineCodeKeymap,\n  strongKeymap,\n].flat()\n","import { $remark } from '@milkdown/utils'\nimport { visit } from 'unist-util-visit'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to add order in list for remark AST.\nexport const remarkAddOrderInListPlugin = $remark(\n  'remarkAddOrderInList',\n  () => () => (tree) => {\n    visit(tree, 'list', (node) => {\n      if (node.ordered) {\n        const start = node.start ?? 1\n        node.children.forEach((child, index) => {\n          ;(child as unknown as Record<string, number>).label = index + start\n        })\n      }\n    })\n  }\n)\n\nwithMeta(remarkAddOrderInListPlugin.plugin, {\n  displayName: 'Remark<remarkAddOrderInListPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkAddOrderInListPlugin.options, {\n  displayName: 'RemarkConfig<remarkAddOrderInListPlugin>',\n  group: 'Remark',\n})\n","import { $remark } from '@milkdown/utils'\nimport type { Node } from '@milkdown/transformer'\nimport { visit } from 'unist-util-visit'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to add inline line break for remark AST.\n/// The inline line break should be treated as a `space`.\n/// And the normal line break should be treated as a `LF`.\nexport const remarkLineBreak = $remark(\n  'remarkLineBreak',\n  () => () => (tree: Node) => {\n    const find = /[\\t ]*(?:\\r?\\n|\\r)/g\n    visit(\n      tree,\n      'text',\n      (\n        node: Node & { value: string },\n        index: number,\n        parent: Node & { children: Node[] }\n      ) => {\n        if (!node.value || typeof node.value !== 'string') return\n\n        const result = []\n        let start = 0\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n\n          if (start !== position)\n            result.push({\n              type: 'text',\n              value: node.value.slice(start, position),\n            })\n\n          result.push({ type: 'break', data: { isInline: true } })\n          start = position + match[0].length\n          match = find.exec(node.value)\n        }\n\n        const hasResultAndIndex =\n          result.length > 0 && parent && typeof index === 'number'\n\n        if (!hasResultAndIndex) return\n\n        if (start < node.value.length)\n          result.push({ type: 'text', value: node.value.slice(start) })\n\n        parent.children.splice(index, 1, ...result)\n        return index + result.length\n      }\n    )\n  }\n)\n\nwithMeta(remarkLineBreak.plugin, {\n  displayName: 'Remark<remarkLineBreak>',\n  group: 'Remark',\n})\n\nwithMeta(remarkLineBreak.options, {\n  displayName: 'RemarkConfig<remarkLineBreak>',\n  group: 'Remark',\n})\n","import { $remark } from '@milkdown/utils'\nimport remarkInlineLinks from 'remark-inline-links'\nimport { withMeta } from '../__internal__'\n\n/// This plugin wraps [remark-inline-links](https://github.com/remarkjs/remark-inline-links).\nexport const remarkInlineLinkPlugin = $remark(\n  'remarkInlineLink',\n  () => remarkInlineLinks\n)\n\nwithMeta(remarkInlineLinkPlugin.plugin, {\n  displayName: 'Remark<remarkInlineLinkPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkInlineLinkPlugin.options, {\n  displayName: 'RemarkConfig<remarkInlineLinkPlugin>',\n  group: 'Remark',\n})\n","import { $remark } from '@milkdown/utils'\nimport type { Node } from '@milkdown/transformer'\nimport { withMeta } from '../__internal__'\n\nconst isParent = (node: Node): node is Node & { children: Node[] } =>\n  !!(node as Node & { children: Node[] }).children\nconst isHTML = (\n  node: Node\n): node is Node & { children: Node[]; value: unknown } => node.type === 'html'\n\nfunction flatMapWithDepth(\n  ast: Node,\n  fn: (node: Node, index: number, parent: Node | null) => Node[]\n) {\n  return transform(ast, 0, null)[0]\n\n  function transform(node: Node, index: number, parent: Node | null) {\n    if (isParent(node)) {\n      const out = []\n      for (let i = 0, n = node.children.length; i < n; i++) {\n        const nthChild = node.children[i]\n        if (nthChild) {\n          const xs = transform(nthChild, i, node)\n          if (xs) {\n            for (let j = 0, m = xs.length; j < m; j++) {\n              const item = xs[j]\n              if (item) out.push(item)\n            }\n          }\n        }\n      }\n      node.children = out\n    }\n\n    return fn(node, index, parent)\n  }\n}\n\n/// @internal\n/// This plugin should be deprecated after we support HTML.\nexport const remarkHtmlTransformer = $remark(\n  'remarkHTMLTransformer',\n  () => () => (tree: Node) => {\n    flatMapWithDepth(tree, (node, _index, parent) => {\n      if (!isHTML(node)) return [node]\n\n      if (parent?.type === 'root') {\n        node.children = [{ ...node }]\n        delete node.value\n        ;(node as { type: string }).type = 'paragraph'\n      }\n\n      return [node]\n    })\n  }\n)\n\nwithMeta(remarkHtmlTransformer.plugin, {\n  displayName: 'Remark<remarkHtmlTransformer>',\n  group: 'Remark',\n})\n\nwithMeta(remarkHtmlTransformer.options, {\n  displayName: 'RemarkConfig<remarkHtmlTransformer>',\n  group: 'Remark',\n})\n","import { $remark } from '@milkdown/utils'\nimport type { Node } from '@milkdown/transformer'\nimport { visit } from 'unist-util-visit'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to keep the marker (`_` and `*`) of emphasis and strong nodes.\nexport const remarkMarker = $remark(\n  'remarkMarker',\n  () => () => (tree, file) => {\n    const getMarker = (node: Node) => {\n      return (file.value as string).charAt(node.position!.start.offset!)\n    }\n    visit(\n      tree,\n      (node: Node) => ['strong', 'emphasis'].includes(node.type),\n      (node: Node) => {\n        ;(node as Node & { marker: string }).marker = getMarker(node)\n      }\n    )\n  }\n)\n\nwithMeta(remarkMarker.plugin, {\n  displayName: 'Remark<remarkMarker>',\n  group: 'Remark',\n})\n\nwithMeta(remarkMarker.options, {\n  displayName: 'RemarkConfig<remarkMarker>',\n  group: 'Remark',\n})\n","import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { Decoration, DecorationSet } from '@milkdown/prose/view'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is to solve the [chrome 98 bug](https://discuss.prosemirror.net/t/cursor-jumps-at-the-end-of-line-when-it-betweens-two-inline-nodes/4641).\nexport const inlineNodesCursorPlugin = $prose(() => {\n  let lock = false\n  const inlineNodesCursorPluginKey = new PluginKey(\n    'MILKDOWN_INLINE_NODES_CURSOR'\n  )\n  const inlineNodesCursorPlugin: Plugin = new Plugin({\n    key: inlineNodesCursorPluginKey,\n    state: {\n      init() {\n        return false\n      },\n      apply(tr) {\n        if (!tr.selection.empty) return false\n\n        const pos = tr.selection.$from\n        const left = pos.nodeBefore\n        const right = pos.nodeAfter\n        if (\n          left &&\n          right &&\n          left.isInline &&\n          !left.isText &&\n          right.isInline &&\n          !right.isText\n        )\n          return true\n\n        return false\n      },\n    },\n    props: {\n      handleDOMEvents: {\n        compositionend: (view, e) => {\n          if (lock) {\n            lock = false\n            requestAnimationFrame(() => {\n              const active = inlineNodesCursorPlugin.getState(view.state)\n              if (active) {\n                const from = view.state.selection.from\n                e.preventDefault()\n                view.dispatch(view.state.tr.insertText(e.data || '', from))\n              }\n            })\n\n            return true\n          }\n          return false\n        },\n        compositionstart: (view) => {\n          const active = inlineNodesCursorPlugin.getState(view.state)\n          if (active) lock = true\n\n          return false\n        },\n        beforeinput: (view, e) => {\n          const active = inlineNodesCursorPlugin.getState(view.state)\n          if (active && e instanceof InputEvent && e.data && !lock) {\n            const from = view.state.selection.from\n            e.preventDefault()\n            view.dispatch(view.state.tr.insertText(e.data || '', from))\n\n            return true\n          }\n\n          return false\n        },\n      },\n      decorations(state) {\n        const active = inlineNodesCursorPlugin.getState(state)\n        if (active) {\n          const pos = state.selection.$from\n          const position = pos.pos\n          const left = document.createElement('span')\n          const leftDec = Decoration.widget(position, left, {\n            side: -1,\n          })\n          const right = document.createElement('span')\n          const rightDec = Decoration.widget(position, right)\n          setTimeout(() => {\n            left.contentEditable = 'true'\n            right.contentEditable = 'true'\n          })\n          return DecorationSet.create(state.doc, [leftDec, rightDec])\n        }\n        return DecorationSet.empty\n      },\n    },\n  })\n\n  return inlineNodesCursorPlugin\n})\n\nwithMeta(inlineNodesCursorPlugin, {\n  displayName: 'Prose<inlineNodesCursorPlugin>',\n  group: 'Prose',\n})\n","import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { AddMarkStep, ReplaceStep } from '@milkdown/prose/transform'\nimport { $prose } from '@milkdown/utils'\nimport { hardbreakSchema } from '../node'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to clear the marks around the hardbreak node.\nexport const hardbreakClearMarkPlugin = $prose((ctx) => {\n  return new Plugin({\n    key: new PluginKey('MILKDOWN_HARDBREAK_MARKS'),\n    appendTransaction: (trs, _oldState, newState) => {\n      if (!trs.length) return\n\n      const [tr] = trs\n      if (!tr) return\n\n      const [step] = tr.steps\n\n      const isInsertHr = tr.getMeta('hardbreak')\n      if (isInsertHr) {\n        if (!(step instanceof ReplaceStep)) return\n\n        const { from } = step as unknown as { from: number }\n        return newState.tr.setNodeMarkup(\n          from,\n          hardbreakSchema.type(ctx),\n          undefined,\n          []\n        )\n      }\n\n      const isAddMarkStep = step instanceof AddMarkStep\n      if (isAddMarkStep) {\n        let _tr = newState.tr\n        const { from, to } = step as unknown as { from: number; to: number }\n        newState.doc.nodesBetween(from, to, (node, pos) => {\n          if (node.type === hardbreakSchema.type(ctx))\n            _tr = _tr.setNodeMarkup(\n              pos,\n              hardbreakSchema.type(ctx),\n              undefined,\n              []\n            )\n        })\n\n        return _tr\n      }\n\n      return undefined\n    },\n  })\n})\n\nwithMeta(hardbreakClearMarkPlugin, {\n  displayName: 'Prose<hardbreakClearMarkPlugin>',\n  group: 'Prose',\n})\n","import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $ctx, $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This slice contains the nodes that within which the hardbreak will be ignored.\nexport const hardbreakFilterNodes = $ctx(\n  ['table', 'code_block'],\n  'hardbreakFilterNodes'\n)\n\nwithMeta(hardbreakFilterNodes, {\n  displayName: 'Ctx<hardbreakFilterNodes>',\n  group: 'Prose',\n})\n\n/// This plugin is used to filter the hardbreak node.\n/// If the hardbreak is going to be inserted within a node that is in the `hardbreakFilterNodes`, ignore it.\nexport const hardbreakFilterPlugin = $prose((ctx) => {\n  const notIn = ctx.get(hardbreakFilterNodes.key)\n  return new Plugin({\n    key: new PluginKey('MILKDOWN_HARDBREAK_FILTER'),\n    filterTransaction: (tr, state) => {\n      const isInsertHr = tr.getMeta('hardbreak')\n      const [step] = tr.steps\n      if (isInsertHr && step) {\n        const { from } = step as unknown as { from: number }\n        const $from = state.doc.resolve(from)\n        let curDepth = $from.depth\n        let canApply = true\n        while (curDepth > 0) {\n          if (notIn.includes($from.node(curDepth).type.name)) canApply = false\n\n          curDepth--\n        }\n        return canApply\n      }\n      return true\n    },\n  })\n})\n\nwithMeta(hardbreakFilterPlugin, {\n  displayName: 'Prose<hardbreakFilterPlugin>',\n  group: 'Prose',\n})\n","import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { EditorView } from '@milkdown/prose/view'\nimport { $prose } from '@milkdown/utils'\nimport { headingIdGenerator, headingSchema } from '../node/heading'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to sync the heading id when the heading content changes.\n/// It will use the `headingIdGenerator` to generate the id.\nexport const syncHeadingIdPlugin = $prose((ctx) => {\n  const headingIdPluginKey = new PluginKey('MILKDOWN_HEADING_ID')\n\n  const updateId = (view: EditorView) => {\n    if (view.composing) return\n\n    const getId = ctx.get(headingIdGenerator.key)\n    const tr = view.state.tr.setMeta('addToHistory', false)\n\n    let found = false\n    const idMap: Record<string, number> = {}\n\n    view.state.doc.descendants((node, pos) => {\n      if (node.type === headingSchema.type(ctx)) {\n        if (node.textContent.trim().length === 0) return\n\n        const attrs = node.attrs\n        let id = getId(node)\n        if (idMap[id]) {\n          idMap[id]! += 1\n          id += `-#${idMap[id]}`\n        } else {\n          idMap[id] = 1\n        }\n\n        if (attrs.id !== id) {\n          found = true\n          tr.setMeta(headingIdPluginKey, true).setNodeMarkup(pos, undefined, {\n            ...attrs,\n            id,\n          })\n        }\n      }\n    })\n\n    if (found) view.dispatch(tr)\n  }\n\n  return new Plugin({\n    key: headingIdPluginKey,\n    view: (view) => {\n      updateId(view)\n\n      return {\n        update: (view, prevState) => {\n          if (view.state.doc.eq(prevState.doc)) return\n          updateId(view)\n        },\n      }\n    },\n  })\n})\n\nwithMeta(syncHeadingIdPlugin, {\n  displayName: 'Prose<syncHeadingIdPlugin>',\n  group: 'Prose',\n})\n","import { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { $prose } from '@milkdown/utils'\nimport type { EditorView } from '@milkdown/prose/view'\nimport { listItemSchema } from '../node/list-item'\n\nimport { orderedListSchema } from '../node/ordered-list'\nimport { bulletListSchema } from '../node'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to keep the label of list item up to date in ordered list.\nexport const syncListOrderPlugin = $prose((ctx) => {\n  const syncOrderLabel = (view: EditorView) => {\n    if (view.composing || !view.editable) return\n\n    const orderedListType = orderedListSchema.type(ctx)\n    const bulletListType = bulletListSchema.type(ctx)\n    const listItemType = listItemSchema.type(ctx)\n    const state = view.state\n    const handleNodeItem = (\n      attrs: Record<string, any>,\n      index: number\n    ): boolean => {\n      let changed = false\n      const expectedLabel = `${index + 1}.`\n      if (attrs.label !== expectedLabel) {\n        attrs.label = expectedLabel\n        changed = true\n      }\n\n      return changed\n    }\n\n    let tr = state.tr\n    let needDispatch = false\n    state.doc.descendants((node, pos, parent, index) => {\n      if (node.type === bulletListType) {\n        const base = node.maybeChild(0)\n        if (base?.type === listItemType && base.attrs.listType === 'ordered') {\n          needDispatch = true\n          tr.setNodeMarkup(pos, orderedListType, { spread: 'true' })\n\n          node.descendants((child, pos, _parent, index) => {\n            if (child.type === listItemType) {\n              const attrs = { ...child.attrs }\n              const changed = handleNodeItem(attrs, index)\n              if (changed) tr = tr.setNodeMarkup(pos, undefined, attrs)\n            }\n            return false\n          })\n        }\n      } else if (\n        node.type === listItemType &&\n        parent?.type === orderedListType\n      ) {\n        const attrs = { ...node.attrs }\n        let changed = false\n        if (attrs.listType !== 'ordered') {\n          attrs.listType = 'ordered'\n          changed = true\n        }\n\n        const base = parent?.maybeChild(0)\n        if (base) changed = handleNodeItem(attrs, index)\n\n        if (changed) {\n          tr = tr.setNodeMarkup(pos, undefined, attrs)\n          needDispatch = true\n        }\n      }\n    })\n\n    if (needDispatch) view.dispatch(tr.setMeta('addToHistory', false))\n  }\n  return new Plugin({\n    key: new PluginKey('MILKDOWN_KEEP_LIST_ORDER'),\n    view: (view) => {\n      syncOrderLabel(view)\n      return {\n        update: (view) => {\n          syncOrderLabel(view)\n        },\n      }\n    },\n  })\n})\n\nwithMeta(syncListOrderPlugin, {\n  displayName: 'Prose<syncListOrderPlugin>',\n  group: 'Prose',\n})\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  hardbreakClearMarkPlugin,\n  hardbreakFilterNodes,\n  hardbreakFilterPlugin,\n  inlineNodesCursorPlugin,\n  remarkAddOrderInListPlugin,\n  remarkHtmlTransformer,\n  remarkInlineLinkPlugin,\n  remarkLineBreak,\n  remarkMarker,\n  syncHeadingIdPlugin,\n  syncListOrderPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  hardbreakClearMarkPlugin,\n  hardbreakFilterNodes,\n  hardbreakFilterPlugin,\n\n  inlineNodesCursorPlugin,\n\n  remarkAddOrderInListPlugin,\n  remarkInlineLinkPlugin,\n  remarkLineBreak,\n  remarkHtmlTransformer,\n  remarkMarker,\n\n  syncHeadingIdPlugin,\n  syncListOrderPlugin,\n].flat()\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  commands,\n  inputRules,\n  keymap,\n  markInputRules,\n  plugins,\n  schema,\n} from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The commonmark preset, includes all the plugins.\nexport const commonmark: MilkdownPlugin[] = [\n  schema,\n  inputRules,\n  markInputRules,\n  commands,\n  keymap,\n  plugins,\n].flat()\n"],"names":["serializeText","state","node","_a","contentArr","n","_","Fragment","withMeta","plugin","meta","emphasisAttr","$markAttr","emphasisSchema","$markSchema","ctx","remarkStringifyOptionsCtx","value","mark","markType","toggleEmphasisCommand","$command","toggleMark","emphasisStarInputRule","$inputRule","markRule","fullMatch","start","emphasisUnderscoreInputRule","emphasisKeymap","$useKeymap","commands","commandsCtx","strongAttr","strongSchema","toggleStrongCommand","strongInputRule","match","strongKeymap","inlineCodeAttr","inlineCodeSchema","toggleInlineCodeCommand","dispatch","selection","tr","from","to","x","name","t","inlineCodeInputRule","inlineCodeKeymap","linkAttr","linkSchema","dom","expectDomTypeError","url","title","toggleLinkCommand","payload","updateLinkCommand","pos","p","type","end","linkMark","TextSelection","docSchema","$node","paragraphAttr","$nodeAttr","paragraphSchema","$nodeSchema","turnIntoTextCommand","setBlockType","paragraphKeymap","headingIndex","i","defaultHeadingIdGenerator","slugify","headingIdGenerator","$ctx","headingAttr","headingSchema","getId","depth","wrapInHeadingInputRule","textblockTypeInputRule","_b","view","editorViewCtx","$from","level","wrapInHeadingCommand","downgradeHeadingCommand","headingKeymap","blockquoteAttr","blockquoteSchema","wrapInBlockquoteInputRule","wrappingInputRule","wrapInBlockquoteCommand","wrapIn","blockquoteKeymap","codeBlockAttr","codeBlockSchema","attr","language","createCodeBlockInputRule","createCodeBlockCommand","updateCodeBlockLanguageCommand","codeBlockKeymap","imageAttr","imageSchema","alt","insertImageCommand","src","updateImageCommand","nodeWithPos","findSelectedNodeOfType","newAttrs","insertImageInputRule","InputRule","matched","hardbreakAttr","hardbreakSchema","insertHardbreakCommand","Selection","hardbreakKeymap","hrAttr","hrSchema","insertHrInputRule","insertHrCommand","paragraph","_tr","sel","bulletListAttr","bulletListSchema","ordered","spread","wrapInBulletListInputRule","wrapInBulletListCommand","bulletListKeymap","orderedListAttr","orderedListSchema","wrapInOrderedListInputRule","wrapInOrderedListCommand","orderedListKeymap","listItemAttr","listItemSchema","label","listType","sinkListItemCommand","sinkListItem","liftListItemCommand","liftListItem","splitListItemCommand","splitListItem","liftFirstListItem","empty","parentItem","liftFirstListItemCommand","listItemKeymap","textSchema","htmlAttr","htmlSchema","span","schema","inputRules","markInputRules","keymap","remarkAddOrderInListPlugin","$remark","tree","visit","child","index","remarkLineBreak","find","parent","result","position","remarkInlineLinkPlugin","remarkInlineLinks","isParent","isHTML","flatMapWithDepth","ast","fn","transform","out","nthChild","xs","j","m","item","remarkHtmlTransformer","_index","remarkMarker","file","getMarker","inlineNodesCursorPlugin","$prose","lock","inlineNodesCursorPluginKey","PluginKey","Plugin","left","right","e","leftDec","Decoration","rightDec","DecorationSet","hardbreakClearMarkPlugin","trs","_oldState","newState","step","ReplaceStep","AddMarkStep","hardbreakFilterNodes","hardbreakFilterPlugin","notIn","isInsertHr","curDepth","canApply","syncHeadingIdPlugin","headingIdPluginKey","updateId","found","idMap","attrs","id","prevState","syncListOrderPlugin","syncOrderLabel","orderedListType","bulletListType","listItemType","handleNodeItem","changed","expectedLabel","needDispatch","base","_parent","plugins","commonmark"],"mappings":"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"}