{"version":3,"file":"index.es.js","sources":["../src/context/container.ts","../src/context/slice.ts","../src/inspector/inspector.ts","../src/plugin/ctx.ts","../src/timer/clock.ts","../src/timer/timer.ts"],"sourcesContent":["import { contextNotFound } from '@milkdown/exception'\n\nimport type { Slice, SliceType } from './slice'\n\n/// @internal\nexport type SliceMap = Map<symbol, Slice>\n\n/// Container is a map of slices.\nexport class Container {\n  /// @internal\n  sliceMap: SliceMap = new Map()\n\n  /// Get a slice from the container by slice type or slice name.\n  get = <T, N extends string = string>(\n    slice: SliceType<T, N> | N\n  ): Slice<T, N> => {\n    const context =\n      typeof slice === 'string'\n        ? [...this.sliceMap.values()].find((x) => x.type.name === slice)\n        : this.sliceMap.get(slice.id)\n\n    if (!context) {\n      const name = typeof slice === 'string' ? slice : slice.name\n      throw contextNotFound(name)\n    }\n    return context as Slice<T, N>\n  }\n\n  /// Remove a slice from the container by slice type or slice name.\n  remove = <T, N extends string = string>(slice: SliceType<T, N> | N): void => {\n    const context =\n      typeof slice === 'string'\n        ? [...this.sliceMap.values()].find((x) => x.type.name === slice)\n        : this.sliceMap.get(slice.id)\n\n    if (!context) return\n\n    this.sliceMap.delete(context.type.id)\n  }\n\n  /// Check if the container has a slice by slice type or slice name.\n  has = <T, N extends string = string>(slice: SliceType<T, N> | N): boolean => {\n    if (typeof slice === 'string')\n      return [...this.sliceMap.values()].some((x) => x.type.name === slice)\n\n    return this.sliceMap.has(slice.id)\n  }\n}\n","import { ctxCallOutOfScope } from '@milkdown/exception'\nimport type { SliceMap } from './container'\n\n/// Slice is a value of slice type.\nexport class Slice<T = any, N extends string = string> {\n  /// The type of the slice.\n  readonly type: SliceType<T, N>\n\n  /// @internal\n  #watchers: Array<(value: T) => unknown> = []\n\n  /// @internal\n  #value: T\n\n  /// @internal\n  #emit = () => {\n    this.#watchers.forEach((watcher) => watcher(this.#value))\n  }\n\n  /// @internal\n  constructor(container: SliceMap, value: T, type: SliceType<T, N>) {\n    this.type = type\n    this.#value = value\n    container.set(type.id, this)\n  }\n\n  /// Add a watcher for changes in the slice.\n  /// Returns a function to remove the watcher.\n  on(watcher: (value: T) => unknown) {\n    this.#watchers.push(watcher)\n    return () => {\n      this.#watchers = this.#watchers.filter((w) => w !== watcher)\n    }\n  }\n\n  /// Add a one-time watcher for changes in the slice.\n  /// The watcher will be removed after it is called.\n  /// Returns a function to remove the watcher.\n  once(watcher: (value: T) => unknown) {\n    const off = this.on((value) => {\n      watcher(value)\n      off()\n    })\n    return off\n  }\n\n  /// Remove a watcher.\n  off(watcher: (value: T) => unknown) {\n    this.#watchers = this.#watchers.filter((w) => w !== watcher)\n  }\n\n  /// Remove all watchers.\n  offAll() {\n    this.#watchers = []\n  }\n\n  /// Set the value of the slice.\n  set = (value: T) => {\n    this.#value = value\n    this.#emit()\n  }\n\n  /// Get the value of the slice.\n  get = () => this.#value\n\n  /// Update the value of the slice with a callback.\n  update = (updater: (prev: T) => T) => {\n    this.#value = updater(this.#value)\n    this.#emit()\n  }\n}\n\n/// Slice type can be used to create slices in different containers.\nexport class SliceType<T = any, N extends string = string> {\n  /// The unique id of the slice type.\n  readonly id: symbol\n  /// The name of the slice type.\n  readonly name: N\n  /// @internal\n  readonly _typeInfo: () => T\n  /// @internal\n  readonly _defaultValue: T\n\n  /// Create a slice type with a default value and a name.\n  /// The name should be unique in the container.\n  constructor(value: T, name: N) {\n    this.id = Symbol(`Context-${name}`)\n    this.name = name\n    this._defaultValue = value\n    this._typeInfo = (): T => {\n      throw ctxCallOutOfScope()\n    }\n  }\n\n  /// Create a slice with a container.\n  /// You can also pass a value to override the default value.\n  create(container: SliceMap, value: T = this._defaultValue): Slice<T, N> {\n    return new Slice(container, value, this)\n  }\n}\n\n/// Create a slice type with a default value and a name.\n/// This is equivalent to `new SliceType(value, name)`.\nexport const createSlice = <T = any, N extends string = string>(\n  value: T,\n  name: N\n) => new SliceType(value, name)\n","import type { Container, SliceType } from '../context'\nimport type { Clock, TimerStatus, TimerType } from '../timer'\nimport type { Meta } from './meta'\n\nexport interface Telemetry {\n  metadata: Meta\n  injectedSlices: { name: string; value: unknown }[]\n  consumedSlices: { name: string; value: unknown }[]\n  recordedTimers: { name: string; duration: number; status: TimerStatus }[]\n  waitTimers: { name: string; duration: number; status: TimerStatus }[]\n}\n\n/// The inspector object that is used to inspect the runtime environment of a ctx.\nexport class Inspector {\n  /// @internal\n  readonly #meta: Meta\n\n  /// @internal\n  readonly #container: Container\n\n  /// @internal\n  readonly #clock: Clock\n\n  /// @internal\n  readonly #injectedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #consumedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #recordedTimers: Map<\n    TimerType,\n    { duration: number; start: number }\n  > = new Map()\n\n  /// @internal\n  readonly #waitTimers: Map<TimerType, { duration: number }> = new Map()\n\n  /// Create an inspector with container, clock and metadata.\n  constructor(container: Container, clock: Clock, meta: Meta) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n  }\n\n  /// Read the runtime telemetry as an object of the ctx.\n  read = (): Telemetry => {\n    return {\n      metadata: this.#meta,\n      injectedSlices: [...this.#injectedSlices].map((slice) => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      consumedSlices: [...this.#consumedSlices].map((slice) => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      recordedTimers: [...this.#recordedTimers].map(\n        ([timer, { duration }]) => ({\n          name: timer.name,\n          duration,\n          status: this.#getTimer(timer),\n        })\n      ),\n      waitTimers: [...this.#waitTimers].map(([timer, { duration }]) => ({\n        name: timer.name,\n        duration,\n        status: this.#getTimer(timer),\n      })),\n    }\n  }\n\n  /// @internal\n  readonly onRecord = (timerType: TimerType) => {\n    this.#recordedTimers.set(timerType, { start: Date.now(), duration: 0 })\n  }\n\n  /// @internal\n  readonly onClear = (timerType: TimerType) => {\n    this.#recordedTimers.delete(timerType)\n  }\n\n  /// @internal\n  readonly onDone = (timerType: TimerType) => {\n    const timer = this.#recordedTimers.get(timerType)\n    if (!timer) return\n    timer.duration = Date.now() - timer.start\n  }\n\n  /// @internal\n  readonly onWait = (timerType: TimerType, promise: Promise<void>) => {\n    const start = Date.now()\n    promise.finally(() => {\n      this.#waitTimers.set(timerType, { duration: Date.now() - start })\n    })\n  }\n\n  /// @internal\n  readonly onInject = (sliceType: SliceType | string) => {\n    this.#injectedSlices.add(sliceType)\n  }\n\n  /// @internal\n  readonly onRemove = (sliceType: SliceType | string) => {\n    this.#injectedSlices.delete(sliceType)\n  }\n\n  /// @internal\n  readonly onUse = (sliceType: SliceType | string) => {\n    this.#consumedSlices.add(sliceType)\n  }\n\n  /// @internal\n  #getSlice = (sliceType: SliceType | string) => {\n    return this.#container.get(sliceType).get()\n  }\n\n  /// @internal\n  #getTimer = (timerType: TimerType) => {\n    return this.#clock.get(timerType).status\n  }\n}\n","import type { Container, Slice, SliceType } from '../context'\nimport type { Clock, TimerType } from '../timer'\nimport { Inspector } from '../inspector'\nimport type { Meta } from '../inspector'\n\n/// The ctx object that can be accessed in plugin and action.\nexport class Ctx {\n  /// @internal\n  readonly #container: Container\n  /// @internal\n  readonly #clock: Clock\n  /// @internal\n  readonly #meta?: Meta\n  /// @internal\n  readonly #inspector?: Inspector\n\n  /// Create a ctx object with container and clock.\n  constructor(container: Container, clock: Clock, meta?: Meta) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n    if (meta) this.#inspector = new Inspector(container, clock, meta)\n  }\n\n  /// Get metadata of the ctx.\n  get meta() {\n    return this.#meta\n  }\n\n  /// Get the inspector of the ctx.\n  get inspector() {\n    return this.#inspector\n  }\n\n  /// Produce a new ctx with metadata.\n  /// The new ctx will link to the same container and clock with the current ctx.\n  /// If the metadata is empty, it will return the current ctx.\n  readonly produce = (meta?: Meta) => {\n    if (meta && Object.keys(meta).length)\n      return new Ctx(this.#container, this.#clock, { ...meta })\n\n    return this\n  }\n\n  /// Add a slice into the ctx.\n  readonly inject = <T>(sliceType: SliceType<T>, value?: T) => {\n    const slice = sliceType.create(this.#container.sliceMap)\n    if (value != null) slice.set(value)\n\n    this.#inspector?.onInject(sliceType)\n\n    return this\n  }\n\n  /// Remove a slice from the ctx.\n  readonly remove = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ) => {\n    this.#container.remove(sliceType)\n    this.#inspector?.onRemove(sliceType)\n    return this\n  }\n\n  /// Add a timer into the ctx.\n  readonly record = (timerType: TimerType) => {\n    timerType.create(this.#clock.store)\n    this.#inspector?.onRecord(timerType)\n    return this\n  }\n\n  /// Remove a timer from the ctx.\n  readonly clearTimer = (timerType: TimerType) => {\n    this.#clock.remove(timerType)\n    this.#inspector?.onClear(timerType)\n    return this\n  }\n\n  /// Check if the ctx has a slice.\n  readonly isInjected = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ) => this.#container.has(sliceType)\n\n  /// Check if the ctx has a timer.\n  readonly isRecorded = (timerType: TimerType) => this.#clock.has(timerType)\n\n  /// Get a slice from the ctx.\n  readonly use = <T, N extends string = string>(\n    sliceType: SliceType<T, N> | N\n  ): Slice<T, N> => {\n    this.#inspector?.onUse(sliceType)\n    return this.#container.get(sliceType)\n  }\n\n  /// Get a slice value from the ctx.\n  readonly get = <T, N extends string>(sliceType: SliceType<T, N> | N) =>\n    this.use(sliceType).get()\n\n  /// Get a slice value from the ctx.\n  readonly set = <T, N extends string>(\n    sliceType: SliceType<T, N> | N,\n    value: T\n  ) => this.use(sliceType).set(value)\n\n  /// Update a slice value from the ctx by a callback.\n  readonly update = <T, N extends string>(\n    sliceType: SliceType<T, N> | N,\n    updater: (prev: T) => T\n  ) => this.use(sliceType).update(updater)\n\n  /// Get a timer from the ctx.\n  readonly timer = (timer: TimerType) => this.#clock.get(timer)\n\n  /// Resolve a timer from the ctx.\n  readonly done = (timer: TimerType) => {\n    this.timer(timer).done()\n    this.#inspector?.onDone(timer)\n  }\n\n  /// Start a timer from the ctx.\n  readonly wait = (timer: TimerType) => {\n    const promise = this.timer(timer).start()\n    this.#inspector?.onWait(timer, promise)\n    return promise\n  }\n\n  /// Start a list of timers from the ctx, the list is stored in a slice in the ctx.\n  /// This is equivalent to\n  ///\n  /// ```typescript\n  /// Promise.all(ctx.get(slice).map(x => ctx.wait(x))).\n  /// ```\n  readonly waitTimers = async (slice: SliceType<TimerType[]>) => {\n    await Promise.all(this.get(slice).map((x) => this.wait(x)))\n  }\n}\n","import { timerNotFound } from '@milkdown/exception'\n\nimport type { Timer, TimerType } from './timer'\n\n/// @internal\nexport type TimerMap = Map<symbol, Timer>\n\n/// Container is a map of timers.\nexport class Clock {\n  /// @internal\n  readonly store: TimerMap = new Map()\n\n  /// Get a timer from the clock by timer type.\n  get = (timer: TimerType) => {\n    const meta = this.store.get(timer.id)\n    if (!meta) throw timerNotFound(timer.name)\n    return meta\n  }\n\n  /// Remove a timer from the clock by timer type.\n  remove = (timer: TimerType) => {\n    this.store.delete(timer.id)\n  }\n\n  // Check if the clock has a timer by timer type.\n  has = (timer: TimerType) => {\n    return this.store.has(timer.id)\n  }\n}\n","import type { TimerMap } from './clock'\n\nexport type TimerStatus = 'pending' | 'resolved' | 'rejected'\n\n/// Timer is a promise that can be resolved by calling done.\nexport class Timer {\n  /// The type of the timer.\n  readonly type: TimerType\n\n  /// @internal\n  #promise: Promise<void> | null = null\n  /// @internal\n  #listener: EventListener | null = null\n  /// @internal\n  readonly #eventUniqId: symbol\n  /// @internal\n  #status: TimerStatus = 'pending'\n\n  /// @internal\n  constructor(clock: TimerMap, type: TimerType) {\n    this.#eventUniqId = Symbol(type.name)\n    this.type = type\n    clock.set(type.id, this)\n  }\n\n  /// The status of the timer.\n  /// Can be `pending`, `resolved` or `rejected`.\n  get status() {\n    return this.#status\n  }\n\n  /// Start the timer, which will return a promise.\n  /// If the timer is already started, it will return the same promise.\n  /// If the timer is not resolved in the timeout, it will reject the promise.\n  start = () => {\n    this.#promise ??= new Promise((resolve, reject) => {\n      this.#listener = (e: Event) => {\n        if (!(e instanceof CustomEvent)) return\n\n        if (e.detail.id === this.#eventUniqId) {\n          this.#status = 'resolved'\n          this.#removeListener()\n          e.stopImmediatePropagation()\n          resolve()\n        }\n      }\n\n      this.#waitTimeout(() => {\n        if (this.#status === 'pending') this.#status = 'rejected'\n\n        this.#removeListener()\n        reject(new Error(`Timing ${this.type.name} timeout.`))\n      })\n\n      this.#status = 'pending'\n      addEventListener(this.type.name, this.#listener)\n    })\n\n    return this.#promise\n  }\n\n  /// Resolve the timer.\n  done = () => {\n    const event = new CustomEvent(this.type.name, {\n      detail: { id: this.#eventUniqId },\n    })\n    dispatchEvent(event)\n  }\n\n  /// @internal\n  #removeListener = () => {\n    if (this.#listener) removeEventListener(this.type.name, this.#listener)\n  }\n\n  /// @internal\n  #waitTimeout = (ifTimeout: () => void) => {\n    setTimeout(() => {\n      ifTimeout()\n    }, this.type.timeout)\n  }\n}\n\n/// Timer type can be used to create timers in different clocks.\nexport class TimerType {\n  /// The unique id of the timer type.\n  readonly id: symbol\n  /// The name of the timer type.\n  readonly name: string\n  /// The timeout of the timer type.\n  readonly timeout: number\n\n  /// Create a timer type with a name and a timeout.\n  /// The name should be unique in the clock.\n  constructor(name: string, timeout = 3000) {\n    this.id = Symbol(`Timer-${name}`)\n    this.name = name\n    this.timeout = timeout\n  }\n\n  /// Create a timer with a clock.\n  create = (clock: TimerMap): Timer => {\n    return new Timer(clock, this)\n  }\n}\n\n/// Create a timer type with a name and a timeout.\n/// This is equivalent to `new TimerType(name, timeout)`.\nexport const createTimer = (name: string, timeout = 3000) =>\n  new TimerType(name, timeout)\n"],"names":["Container","slice","context","x","name","contextNotFound","Slice","container","value","type","__privateAdd","_watchers","_value","_emit","__privateSet","__privateGet","watcher","updater","w","off","SliceType","ctxCallOutOfScope","createSlice","Inspector","clock","meta","_meta","_container","_clock","_injectedSlices","_consumedSlices","_recordedTimers","_waitTimers","_getSlice","_getTimer","timer","duration","timerType","promise","start","sliceType","_Ctx","_inspector","_a","Ctx","Clock","timerNotFound","Timer","_promise","_listener","_eventUniqId","_status","_removeListener","_waitTimeout","resolve","reject","e","event","ifTimeout","TimerType","timeout","createTimer"],"mappings":"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"}