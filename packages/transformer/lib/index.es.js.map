{"version":3,"file":"index.es.js","sources":["../src/utility/stack.ts","../src/parser/stack-element.ts","../src/parser/state.ts","../src/serializer/stack-element.ts","../src/serializer/state.ts"],"sourcesContent":["import { stackOverFlow } from '@milkdown/exception'\n\n/// The element of the stack, which holds an array of nodes.\nexport abstract class StackElement<Node> {\n  /// A method that can `push` a node into the element.\n  abstract push(node: Node, ...rest: Node[]): void\n}\n\n/// The stack that is used to store the elements.\n///\n/// > Generally, you don't need to use this class directly.\n///\n/// When using the stack, users can call `stack.open` to push a new element into the stack.\n/// And use `stack.push` to push a node into the top element.\n/// Then use `stack.close` to close the top element and pop it.\n///\n/// For example: `stack.open(A).push(B).push(C).close()` will generate a structure like `A(B, C)`.\nexport class Stack<Node, Element extends StackElement<Node>> {\n  protected elements: Element[] = []\n\n  /// Get the size of the stack.\n  size = (): number => {\n    return this.elements.length\n  }\n\n  /// Get the top element of the stack.\n  top = (): Element | undefined => {\n    return this.elements.at(-1)\n  }\n\n  /// Push a node into the top element.\n  push = (node: Node): void => {\n    this.top()?.push(node)\n  }\n\n  /// Push a new element.\n  open = (node: Element): void => {\n    this.elements.push(node)\n  }\n\n  /// Close the top element and pop it.\n  close = (): Element => {\n    const el = this.elements.pop()\n    if (!el)\n      throw stackOverFlow()\n\n    return el\n  }\n}\n","import type { Attrs, Node, NodeType } from '@milkdown/prose/model'\nimport { StackElement } from '../utility'\n\nexport class ParserStackElement extends StackElement<Node> {\n  constructor(public type: NodeType, public content: Node[], public attrs?: Attrs) {\n    super()\n  }\n\n  push(node: Node, ...rest: Node[]) {\n    this.content.push(node, ...rest)\n  }\n\n  pop(): Node | undefined {\n    return this.content.pop()\n  }\n\n  static create(type: NodeType, content: Node[], attrs?: Attrs) {\n    return new ParserStackElement(type, content, attrs)\n  }\n}\n","import type { Attrs, MarkType, Node, NodeType, Schema } from '@milkdown/prose/model'\nimport { createNodeInParserFail, parserMatchError, stackOverFlow } from '@milkdown/exception'\nimport { Mark } from '@milkdown/prose/model'\nimport type { MarkSchema, MarkdownNode, NodeSchema, RemarkParser } from '../utility'\nimport { Stack } from '../utility'\n\nimport { ParserStackElement } from './stack-element'\nimport type { Parser } from './types'\n\n/// A state machine for parser. Transform remark AST into prosemirror state.\nexport class ParserState extends Stack<Node, ParserStackElement> {\n  /// The schema in current editor.\n  readonly schema: Schema\n\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n\n  /// Create a parser from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const parser = ParserState.create(schema, remark)\n  /// const prosemirrorNode = parser(SomeMarkdownText)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Parser => {\n    const state = new this(schema)\n    return (text) => {\n      state.run(remark, text)\n      return state.toDoc()\n    }\n  }\n\n  /// @internal\n  protected constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #hasText = (node: Node): node is Node & { text: string } => node.isText\n\n  /// @internal\n  #maybeMerge = (a: Node, b: Node): Node | undefined => {\n    if (this.#hasText(a) && this.#hasText(b) && Mark.sameSet(a.marks, b.marks))\n      return this.schema.text(a.text + b.text, a.marks)\n\n    return undefined\n  }\n\n  /// @internal\n  #matchTarget = (node: MarkdownNode): NodeType | MarkType => {\n    const result = Object.values({ ...this.schema.nodes, ...this.schema.marks })\n      .find((x): x is (NodeType | MarkType) => {\n        const spec = x.spec as NodeSchema | MarkSchema\n        return spec.parseMarkdown.match(node)\n      })\n\n    if (!result)\n      throw parserMatchError(node)\n\n    return result\n  }\n\n  /// @internal\n  #runNode = (node: MarkdownNode) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema | MarkSchema\n\n    spec.parseMarkdown.runner(this, node, type as NodeType & MarkType)\n  }\n\n  /// Inject root node for prosemirror state.\n  injectRoot = (node: MarkdownNode, nodeType: NodeType, attrs?: Attrs) => {\n    this.openNode(nodeType, attrs)\n    this.next(node.children)\n\n    return this\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (nodeType: NodeType, attrs?: Attrs) => {\n    this.open(ParserStackElement.create(nodeType, [], attrs))\n    return this\n  }\n\n  /// @internal\n  #closeNodeAndPush = (): Node => {\n    this.#marks = Mark.none\n    const element = this.close()\n\n    return this.#addNodeAndPush(element.type, element.attrs, element.content)\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    this.#closeNodeAndPush()\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (nodeType: NodeType, attrs?: Attrs, content?: Node[]): Node => {\n    const node = nodeType.createAndFill(attrs, content, this.#marks)\n    if (!node)\n      throw createNodeInParserFail(nodeType, attrs, content)\n\n    this.push(node)\n\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (nodeType: NodeType, attrs?: Attrs, content?: Node[]) => {\n    this.#addNodeAndPush(nodeType, attrs, content)\n    return this\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  openMark = (markType: MarkType, attrs?: Attrs) => {\n    const mark = markType.create(attrs)\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this\n  }\n\n  /// Close a opened mark.\n  closeMark = (markType: MarkType) => {\n    this.#marks = markType.removeFromSet(this.#marks)\n    return this\n  }\n\n  /// Add a text node into current node.\n  addText = (text: string) => {\n    const topElement = this.top()\n    if (!topElement)\n      throw stackOverFlow()\n\n    const prevNode = topElement.pop()\n    const currNode = this.schema.text(text, this.#marks)\n\n    if (!prevNode) {\n      topElement.push(currNode)\n      return this\n    }\n\n    const merged = this.#maybeMerge(prevNode, currNode)\n    if (merged) {\n      topElement.push(merged)\n      return this\n    }\n    topElement.push(prevNode, currNode)\n    return this\n  }\n\n  /// @internal\n  build = (): Node => {\n    let doc: Node | undefined\n\n    do\n      doc = this.#closeNodeAndPush()\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in parser spec) to handle it.\n  next = (nodes: MarkdownNode | MarkdownNode[] = []) => {\n    [nodes].flat().forEach(node => this.#runNode(node))\n    return this\n  }\n\n  /// Build the current state into a [prosemirror document](https://prosemirror.net/docs/ref/#model.Document_Structure).\n  toDoc = () => this.build()\n\n  /// Transform a markdown string into prosemirror state.\n  run = (remark: RemarkParser, markdown: string) => {\n    const tree = remark.runSync(remark.parse(markdown), markdown) as MarkdownNode\n    this.next(tree)\n\n    return this\n  }\n}\n","import type { MarkdownNode } from '..'\nimport type { JSONRecord } from '../utility'\nimport { StackElement } from '../utility'\n\nexport class SerializerStackElement extends StackElement<MarkdownNode> {\n  constructor(\n    public type: string,\n    public children?: MarkdownNode[],\n    public value?: string,\n    public props: JSONRecord = {},\n  ) {\n    super()\n  }\n\n  static create = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props: JSONRecord = {},\n  ) => new SerializerStackElement(type, children, value, props)\n\n  push = (node: MarkdownNode, ...rest: MarkdownNode[]) => {\n    if (!this.children)\n      this.children = []\n\n    this.children.push(node, ...rest)\n  }\n\n  pop = (): MarkdownNode | undefined => this.children?.pop()\n}\n","import { serializerMatchError } from '@milkdown/exception'\nimport type { Fragment, MarkType, Node, NodeType, Schema } from '@milkdown/prose/model'\nimport { Mark } from '@milkdown/prose/model'\n\nimport type { JSONRecord, MarkSchema, MarkdownNode, NodeSchema, RemarkParser, Root } from '../utility'\nimport { Stack } from '../utility'\nimport { SerializerStackElement } from './stack-element'\nimport type { Serializer } from './types'\n\nconst isFragment = (x: Node | Fragment): x is Fragment => Object.prototype.hasOwnProperty.call(x, 'size')\n\n/// State for serializer.\n/// Transform prosemirror state into remark AST.\nexport class SerializerState extends Stack<MarkdownNode, SerializerStackElement> {\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n  /// Get the schema of state.\n  readonly schema: Schema\n\n  /// Create a serializer from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const serializer = SerializerState.create(schema, remark)\n  /// const markdown = parser(prosemirrorDoc)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Serializer => {\n    const state = new this(schema)\n    return (content: Node) => {\n      state.run(content)\n      return state.toString(remark)\n    }\n  }\n\n  /// @internal\n  constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #matchTarget = (node: Node | Mark): NodeType | MarkType => {\n    const result = Object.values({ ...this.schema.nodes, ...this.schema.marks })\n      .find((x): x is (NodeType | MarkType) => {\n        const spec = x.spec as NodeSchema | MarkSchema\n        return spec.toMarkdown.match(node as Node & Mark)\n      })\n\n    if (!result)\n      throw serializerMatchError(node.type)\n\n    return result\n  }\n\n  /// @internal\n  #runProseNode = (node: Node) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema\n    return spec.toMarkdown.runner(this, node)\n  }\n\n  /// @internal\n  #runProseMark = (mark: Mark, node: Node) => {\n    const type = this.#matchTarget(mark)\n    const spec = type.spec as MarkSchema\n    return spec.toMarkdown.runner(this, mark, node)\n  }\n\n  /// @internal\n  #runNode = (node: Node) => {\n    const { marks } = node\n    const getPriority = (x: Mark) => x.type.spec.priority ?? 50\n    const tmp = [...marks].sort((a, b) => getPriority(a) - getPriority(b))\n    const unPreventNext = tmp.every(mark => !this.#runProseMark(mark, node))\n    if (unPreventNext)\n      this.#runProseNode(node)\n\n    marks.forEach(mark => this.#closeMark(mark))\n  }\n\n  /// @internal\n  #searchType = (child: MarkdownNode, type: string): MarkdownNode => {\n    if (child.type === type)\n      return child\n\n    if (child.children?.length !== 1)\n      return child\n\n    const searchNode = (node: MarkdownNode): MarkdownNode | null => {\n      if (node.type === type)\n        return node\n\n      if (node.children?.length !== 1)\n        return null\n\n      const [firstChild] = node.children\n      if (!firstChild)\n        return null\n\n      return searchNode(firstChild)\n    }\n\n    const target = searchNode(child)\n\n    if (!target)\n      return child\n\n    const tmp = target.children ? [...target.children] : undefined\n    const node = { ...child, children: tmp }\n    node.children = tmp\n    target.children = [node]\n\n    return target\n  }\n\n  /// @internal\n  #maybeMergeChildren = (node: MarkdownNode): MarkdownNode => {\n    const { children } = node\n    if (!children)\n      return node\n\n    node.children = children.reduce((nextChildren, child, index) => {\n      if (index === 0)\n        return [child]\n\n      const last = nextChildren.at(-1)\n      if (last && last.isMark && child.isMark) {\n        child = this.#searchType(child, last.type)\n        const { children: currChildren, ...currRest } = child\n        const { children: prevChildren, ...prevRest } = last\n        if (\n          child.type === last.type\n          && currChildren\n          && prevChildren\n          && JSON.stringify(currRest) === JSON.stringify(prevRest)\n        ) {\n          const next = {\n            ...prevRest,\n            children: [...prevChildren, ...currChildren],\n          }\n          return nextChildren\n            .slice(0, -1)\n            .concat(this.#maybeMergeChildren(next))\n        }\n      }\n      return nextChildren.concat(child)\n    }, [] as MarkdownNode[])\n\n    return node\n  }\n\n  /// @internal\n  #createMarkdownNode = (element: SerializerStackElement) => {\n    const node: MarkdownNode = {\n      ...element.props,\n      type: element.type,\n    }\n\n    if (element.children)\n      node.children = element.children\n\n    if (element.value)\n      node.value = element.value\n\n    return node\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (type: string, value?: string, props?: JSONRecord) => {\n    this.open(SerializerStackElement.create(type, undefined, value, props))\n    return this\n  }\n\n  #moveSpaces = (element: SerializerStackElement, onPush: () => MarkdownNode) => {\n    let startSpaces = ''\n    let endSpaces = ''\n    const children = element.children\n    let first = -1\n    let last = -1\n    const findIndex = (node: MarkdownNode[]) => {\n      if (!node)\n        return\n      node.forEach((child, index) => {\n        if (child.type === 'text' && child.value) {\n          if (first < 0)\n            first = index\n\n          last = index\n        }\n      })\n    }\n\n    if (children) {\n      findIndex(children)\n      const lastChild = children?.[last] as MarkdownNode & { value: string } | undefined\n      const firstChild = children?.[first] as MarkdownNode & { value: string } | undefined\n      if (lastChild && lastChild.value.endsWith(' ')) {\n        endSpaces = lastChild.value.match(/ +$/)![0]\n        lastChild.value = lastChild.value.trimEnd()\n      }\n      if (firstChild && firstChild.value.startsWith(' ')) {\n        startSpaces = firstChild.value.match(/^ +/)![0]\n        firstChild.value = firstChild.value.trimStart()\n      }\n    }\n\n    if (startSpaces.length)\n      this.#addNodeAndPush('text', undefined, startSpaces)\n\n    const result = onPush()\n\n    if (endSpaces.length)\n      this.#addNodeAndPush('text', undefined, endSpaces)\n\n    return result\n  }\n\n  /// @internal\n  #closeNodeAndPush = (trim: boolean = false): MarkdownNode => {\n    const element = this.close()\n\n    const onPush = () => this.#addNodeAndPush(element.type, element.children, element.value, element.props)\n\n    if (trim)\n      return this.#moveSpaces(element, onPush)\n\n    return onPush()\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    this.#closeNodeAndPush()\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord): MarkdownNode => {\n    const element = SerializerStackElement.create(type, children, value, props)\n    const node: MarkdownNode = this.#maybeMergeChildren(this.#createMarkdownNode(element))\n    this.push(node)\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord) => {\n    this.#addNodeAndPush(type, children, value, props)\n    return this\n  }\n\n  /// @internal\n  #openMark = (mark: Mark, type: string, value?: string, props?: JSONRecord) => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (isIn)\n      return this\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this.openNode(type, value, { ...props, isMark: true })\n  }\n\n  /// @internal\n  #closeMark = (mark: Mark): void => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (!isIn)\n      return\n\n    this.#marks = mark.type.removeFromSet(this.#marks)\n    this.#closeNodeAndPush(true)\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  /// The mark will be closed automatically.\n  withMark = (mark: Mark, type: string, value?: string, props?: JSONRecord) => {\n    this.#openMark(mark, type, value, props)\n    return this\n  }\n\n  /// Close a opened mark.\n  /// In most cases you don't need this because\n  /// marks will be closed automatically.\n  closeMark = (mark: Mark) => {\n    this.#closeMark(mark)\n    return this\n  }\n\n  /// @internal\n  build = (): MarkdownNode => {\n    let doc: MarkdownNode | null = null\n    do\n      doc = this.#closeNodeAndPush()\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in serializer spec) to handle it.\n  next = (nodes: Node | Fragment) => {\n    if (isFragment(nodes)) {\n      nodes.forEach((node) => {\n        this.#runNode(node)\n      })\n      return this\n    }\n    this.#runNode(nodes)\n    return this\n  }\n\n  /// Use a remark parser to serialize current AST stored.\n  override toString = (remark: RemarkParser): string => remark.stringify(this.build() as Root)\n\n  /// Transform a prosemirror node tree into remark AST.\n  run = (tree: Node) => {\n    this.next(tree)\n\n    return this\n  }\n}\n"],"names":["StackElement","Stack","node","_a","el","stackOverFlow","ParserStackElement","type","content","attrs","rest","_ParserState","schema","__privateAdd","_marks","_hasText","_maybeMerge","_matchTarget","_runNode","_closeNodeAndPush","_addNodeAndPush","__privateSet","Mark","a","b","__privateGet","result","x","parserMatchError","nodeType","element","createNodeInParserFail","markType","mark","text","topElement","prevNode","currNode","merged","doc","nodes","remark","markdown","tree","state","ParserState","_SerializerStackElement","children","value","props","SerializerStackElement","isFragment","_SerializerState","_runProseNode","_runProseMark","_searchType","_maybeMergeChildren","_createMarkdownNode","_moveSpaces","_openMark","_closeMark","serializerMatchError","marks","getPriority","child","searchNode","firstChild","target","tmp","nextChildren","index","last","currChildren","currRest","prevChildren","prevRest","next","onPush","startSpaces","endSpaces","first","findIndex","lastChild","trim","SerializerState"],"mappings":"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"}