{"version":3,"file":"index.es.js","sources":["../src/utility/stack.ts","../src/parser/stack-element.ts","../src/parser/state.ts","../src/serializer/stack-element.ts","../src/serializer/state.ts"],"sourcesContent":["import { stackOverFlow } from '@milkdown/exception'\n\n/// The element of the stack, which holds an array of nodes.\nexport abstract class StackElement<Node> {\n  /// A method that can `push` a node into the element.\n  abstract push(node: Node, ...rest: Node[]): void\n}\n\n/// The stack that is used to store the elements.\n///\n/// > Generally, you don't need to use this class directly.\n///\n/// When using the stack, users can call `stack.open` to push a new element into the stack.\n/// And use `stack.push` to push a node into the top element.\n/// Then use `stack.close` to close the top element and pop it.\n///\n/// For example: `stack.open(A).push(B).push(C).close()` will generate a structure like `A(B, C)`.\nexport class Stack<Node, Element extends StackElement<Node>> {\n  protected elements: Element[] = []\n\n  /// Get the size of the stack.\n  size = (): number => {\n    return this.elements.length\n  }\n\n  /// Get the top element of the stack.\n  top = (): Element | undefined => {\n    return this.elements.at(-1)\n  }\n\n  /// Push a node into the top element.\n  push = (node: Node): void => {\n    this.top()?.push(node)\n  }\n\n  /// Push a new element.\n  open = (node: Element): void => {\n    this.elements.push(node)\n  }\n\n  /// Close the top element and pop it.\n  close = (): Element => {\n    const el = this.elements.pop()\n    if (!el) throw stackOverFlow()\n\n    return el\n  }\n}\n","import type { Attrs, Node, NodeType } from '@milkdown/prose/model'\nimport { StackElement } from '../utility'\n\nexport class ParserStackElement extends StackElement<Node> {\n  constructor(\n    public type: NodeType,\n    public content: Node[],\n    public attrs?: Attrs\n  ) {\n    super()\n  }\n\n  push(node: Node, ...rest: Node[]) {\n    this.content.push(node, ...rest)\n  }\n\n  pop(): Node | undefined {\n    return this.content.pop()\n  }\n\n  static create(type: NodeType, content: Node[], attrs?: Attrs) {\n    return new ParserStackElement(type, content, attrs)\n  }\n}\n","import type {\n  Attrs,\n  MarkType,\n  Node,\n  NodeType,\n  Schema,\n} from '@milkdown/prose/model'\nimport {\n  createNodeInParserFail,\n  parserMatchError,\n  stackOverFlow,\n} from '@milkdown/exception'\nimport { Mark } from '@milkdown/prose/model'\nimport type {\n  MarkSchema,\n  MarkdownNode,\n  NodeSchema,\n  RemarkParser,\n} from '../utility'\nimport { Stack } from '../utility'\n\nimport { ParserStackElement } from './stack-element'\nimport type { Parser } from './types'\n\n/// A state machine for parser. Transform remark AST into prosemirror state.\nexport class ParserState extends Stack<Node, ParserStackElement> {\n  /// The schema in current editor.\n  readonly schema: Schema\n\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n\n  /// Create a parser from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const parser = ParserState.create(schema, remark)\n  /// const prosemirrorNode = parser(SomeMarkdownText)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Parser => {\n    const state = new this(schema)\n    return (text) => {\n      state.run(remark, text)\n      return state.toDoc()\n    }\n  }\n\n  /// @internal\n  protected constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #hasText = (node: Node): node is Node & { text: string } => node.isText\n\n  /// @internal\n  #maybeMerge = (a: Node, b: Node): Node | undefined => {\n    if (this.#hasText(a) && this.#hasText(b) && Mark.sameSet(a.marks, b.marks))\n      return this.schema.text(a.text + b.text, a.marks)\n\n    return undefined\n  }\n\n  /// @internal\n  #matchTarget = (node: MarkdownNode): NodeType | MarkType => {\n    const result = Object.values({\n      ...this.schema.nodes,\n      ...this.schema.marks,\n    }).find((x): x is NodeType | MarkType => {\n      const spec = x.spec as NodeSchema | MarkSchema\n      return spec.parseMarkdown.match(node)\n    })\n\n    if (!result) throw parserMatchError(node)\n\n    return result\n  }\n\n  /// @internal\n  #runNode = (node: MarkdownNode) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema | MarkSchema\n\n    spec.parseMarkdown.runner(this, node, type as NodeType & MarkType)\n  }\n\n  /// Inject root node for prosemirror state.\n  injectRoot = (node: MarkdownNode, nodeType: NodeType, attrs?: Attrs) => {\n    this.openNode(nodeType, attrs)\n    this.next(node.children)\n\n    return this\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (nodeType: NodeType, attrs?: Attrs) => {\n    this.open(ParserStackElement.create(nodeType, [], attrs))\n    return this\n  }\n\n  /// @internal\n  #closeNodeAndPush = (): Node => {\n    this.#marks = Mark.none\n    const element = this.close()\n\n    return this.#addNodeAndPush(element.type, element.attrs, element.content)\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    this.#closeNodeAndPush()\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (\n    nodeType: NodeType,\n    attrs?: Attrs,\n    content?: Node[]\n  ): Node => {\n    const node = nodeType.createAndFill(attrs, content, this.#marks)\n    if (!node) throw createNodeInParserFail(nodeType, attrs, content)\n\n    this.push(node)\n\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (nodeType: NodeType, attrs?: Attrs, content?: Node[]) => {\n    this.#addNodeAndPush(nodeType, attrs, content)\n    return this\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  openMark = (markType: MarkType, attrs?: Attrs) => {\n    const mark = markType.create(attrs)\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this\n  }\n\n  /// Close a opened mark.\n  closeMark = (markType: MarkType) => {\n    this.#marks = markType.removeFromSet(this.#marks)\n    return this\n  }\n\n  /// Add a text node into current node.\n  addText = (text: string) => {\n    const topElement = this.top()\n    if (!topElement) throw stackOverFlow()\n\n    const prevNode = topElement.pop()\n    const currNode = this.schema.text(text, this.#marks)\n\n    if (!prevNode) {\n      topElement.push(currNode)\n      return this\n    }\n\n    const merged = this.#maybeMerge(prevNode, currNode)\n    if (merged) {\n      topElement.push(merged)\n      return this\n    }\n    topElement.push(prevNode, currNode)\n    return this\n  }\n\n  /// @internal\n  build = (): Node => {\n    let doc: Node | undefined\n\n    do doc = this.#closeNodeAndPush()\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in parser spec) to handle it.\n  next = (nodes: MarkdownNode | MarkdownNode[] = []) => {\n    ;[nodes].flat().forEach((node) => this.#runNode(node))\n    return this\n  }\n\n  /// Build the current state into a [prosemirror document](https://prosemirror.net/docs/ref/#model.Document_Structure).\n  toDoc = () => this.build()\n\n  /// Transform a markdown string into prosemirror state.\n  run = (remark: RemarkParser, markdown: string) => {\n    const tree = remark.runSync(\n      remark.parse(markdown),\n      markdown\n    ) as MarkdownNode\n    this.next(tree)\n\n    return this\n  }\n}\n","import type { MarkdownNode } from '..'\nimport type { JSONRecord } from '../utility'\nimport { StackElement } from '../utility'\n\nexport class SerializerStackElement extends StackElement<MarkdownNode> {\n  constructor(\n    public type: string,\n    public children?: MarkdownNode[],\n    public value?: string,\n    public props: JSONRecord = {}\n  ) {\n    super()\n  }\n\n  static create = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props: JSONRecord = {}\n  ) => new SerializerStackElement(type, children, value, props)\n\n  push = (node: MarkdownNode, ...rest: MarkdownNode[]) => {\n    if (!this.children) this.children = []\n\n    this.children.push(node, ...rest)\n  }\n\n  pop = (): MarkdownNode | undefined => this.children?.pop()\n}\n","import { serializerMatchError } from '@milkdown/exception'\nimport type {\n  Fragment,\n  MarkType,\n  Node,\n  NodeType,\n  Schema,\n} from '@milkdown/prose/model'\nimport { Mark } from '@milkdown/prose/model'\n\nimport type {\n  JSONRecord,\n  MarkSchema,\n  MarkdownNode,\n  NodeSchema,\n  RemarkParser,\n  Root,\n} from '../utility'\nimport { Stack } from '../utility'\nimport { SerializerStackElement } from './stack-element'\nimport type { Serializer } from './types'\n\nconst isFragment = (x: Node | Fragment): x is Fragment =>\n  Object.prototype.hasOwnProperty.call(x, 'size')\n\n/// State for serializer.\n/// Transform prosemirror state into remark AST.\nexport class SerializerState extends Stack<\n  MarkdownNode,\n  SerializerStackElement\n> {\n  /// @internal\n  #marks: readonly Mark[] = Mark.none\n  /// Get the schema of state.\n  readonly schema: Schema\n\n  /// Create a serializer from schema and remark instance.\n  ///\n  /// ```typescript\n  /// const serializer = SerializerState.create(schema, remark)\n  /// const markdown = parser(prosemirrorDoc)\n  /// ```\n  static create = (schema: Schema, remark: RemarkParser): Serializer => {\n    const state = new this(schema)\n    return (content: Node) => {\n      state.run(content)\n      return state.toString(remark)\n    }\n  }\n\n  /// @internal\n  constructor(schema: Schema) {\n    super()\n    this.schema = schema\n  }\n\n  /// @internal\n  #matchTarget = (node: Node | Mark): NodeType | MarkType => {\n    const result = Object.values({\n      ...this.schema.nodes,\n      ...this.schema.marks,\n    }).find((x): x is NodeType | MarkType => {\n      const spec = x.spec as NodeSchema | MarkSchema\n      return spec.toMarkdown.match(node as Node & Mark)\n    })\n\n    if (!result) throw serializerMatchError(node.type)\n\n    return result\n  }\n\n  /// @internal\n  #runProseNode = (node: Node) => {\n    const type = this.#matchTarget(node)\n    const spec = type.spec as NodeSchema\n    return spec.toMarkdown.runner(this, node)\n  }\n\n  /// @internal\n  #runProseMark = (mark: Mark, node: Node) => {\n    const type = this.#matchTarget(mark)\n    const spec = type.spec as MarkSchema\n    return spec.toMarkdown.runner(this, mark, node)\n  }\n\n  /// @internal\n  #runNode = (node: Node) => {\n    const { marks } = node\n    const getPriority = (x: Mark) => x.type.spec.priority ?? 50\n    const tmp = [...marks].sort((a, b) => getPriority(a) - getPriority(b))\n    const unPreventNext = tmp.every((mark) => !this.#runProseMark(mark, node))\n    if (unPreventNext) this.#runProseNode(node)\n\n    marks.forEach((mark) => this.#closeMark(mark))\n  }\n\n  /// @internal\n  #searchType = (child: MarkdownNode, type: string): MarkdownNode => {\n    if (child.type === type) return child\n\n    if (child.children?.length !== 1) return child\n\n    const searchNode = (node: MarkdownNode): MarkdownNode | null => {\n      if (node.type === type) return node\n\n      if (node.children?.length !== 1) return null\n\n      const [firstChild] = node.children\n      if (!firstChild) return null\n\n      return searchNode(firstChild)\n    }\n\n    const target = searchNode(child)\n\n    if (!target) return child\n\n    const tmp = target.children ? [...target.children] : undefined\n    const node = { ...child, children: tmp }\n    node.children = tmp\n    target.children = [node]\n\n    return target\n  }\n\n  /// @internal\n  #maybeMergeChildren = (node: MarkdownNode): MarkdownNode => {\n    const { children } = node\n    if (!children) return node\n\n    node.children = children.reduce((nextChildren, child, index) => {\n      if (index === 0) return [child]\n\n      const last = nextChildren.at(-1)\n      if (last && last.isMark && child.isMark) {\n        child = this.#searchType(child, last.type)\n        const { children: currChildren, ...currRest } = child\n        const { children: prevChildren, ...prevRest } = last\n        if (\n          child.type === last.type &&\n          currChildren &&\n          prevChildren &&\n          JSON.stringify(currRest) === JSON.stringify(prevRest)\n        ) {\n          const next = {\n            ...prevRest,\n            children: [...prevChildren, ...currChildren],\n          }\n          return nextChildren\n            .slice(0, -1)\n            .concat(this.#maybeMergeChildren(next))\n        }\n      }\n      return nextChildren.concat(child)\n    }, [] as MarkdownNode[])\n\n    return node\n  }\n\n  /// @internal\n  #createMarkdownNode = (element: SerializerStackElement) => {\n    const node: MarkdownNode = {\n      ...element.props,\n      type: element.type,\n    }\n\n    if (element.children) node.children = element.children\n\n    if (element.value) node.value = element.value\n\n    return node\n  }\n\n  /// Open a new node, the next operations will\n  /// add nodes into that new node until `closeNode` is called.\n  openNode = (type: string, value?: string, props?: JSONRecord) => {\n    this.open(SerializerStackElement.create(type, undefined, value, props))\n    return this\n  }\n\n  #moveSpaces = (\n    element: SerializerStackElement,\n    onPush: () => MarkdownNode\n  ) => {\n    let startSpaces = ''\n    let endSpaces = ''\n    const children = element.children\n    let first = -1\n    let last = -1\n    const findIndex = (node: MarkdownNode[]) => {\n      if (!node) return\n      node.forEach((child, index) => {\n        if (child.type === 'text' && child.value) {\n          if (first < 0) first = index\n\n          last = index\n        }\n      })\n    }\n\n    if (children) {\n      findIndex(children)\n      const lastChild = children?.[last] as\n        | (MarkdownNode & { value: string })\n        | undefined\n      const firstChild = children?.[first] as\n        | (MarkdownNode & { value: string })\n        | undefined\n      if (lastChild && lastChild.value.endsWith(' ')) {\n        endSpaces = lastChild.value.match(/ +$/)![0]\n        lastChild.value = lastChild.value.trimEnd()\n      }\n      if (firstChild && firstChild.value.startsWith(' ')) {\n        startSpaces = firstChild.value.match(/^ +/)![0]\n        firstChild.value = firstChild.value.trimStart()\n      }\n    }\n\n    if (startSpaces.length) this.#addNodeAndPush('text', undefined, startSpaces)\n\n    const result = onPush()\n\n    if (endSpaces.length) this.#addNodeAndPush('text', undefined, endSpaces)\n\n    return result\n  }\n\n  /// @internal\n  #closeNodeAndPush = (trim: boolean = false): MarkdownNode => {\n    const element = this.close()\n\n    const onPush = () =>\n      this.#addNodeAndPush(\n        element.type,\n        element.children,\n        element.value,\n        element.props\n      )\n\n    if (trim) return this.#moveSpaces(element, onPush)\n\n    return onPush()\n  }\n\n  /// Close the current node and push it into the parent node.\n  closeNode = () => {\n    this.#closeNodeAndPush()\n    return this\n  }\n\n  /// @internal\n  #addNodeAndPush = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props?: JSONRecord\n  ): MarkdownNode => {\n    const element = SerializerStackElement.create(type, children, value, props)\n    const node: MarkdownNode = this.#maybeMergeChildren(\n      this.#createMarkdownNode(element)\n    )\n    this.push(node)\n    return node\n  }\n\n  /// Add a node into current node.\n  addNode = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props?: JSONRecord\n  ) => {\n    this.#addNodeAndPush(type, children, value, props)\n    return this\n  }\n\n  /// @internal\n  #openMark = (\n    mark: Mark,\n    type: string,\n    value?: string,\n    props?: JSONRecord\n  ) => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (isIn) return this\n\n    this.#marks = mark.addToSet(this.#marks)\n    return this.openNode(type, value, { ...props, isMark: true })\n  }\n\n  /// @internal\n  #closeMark = (mark: Mark): void => {\n    const isIn = mark.isInSet(this.#marks)\n\n    if (!isIn) return\n\n    this.#marks = mark.type.removeFromSet(this.#marks)\n    this.#closeNodeAndPush(true)\n  }\n\n  /// Open a new mark, the next nodes added will have that mark.\n  /// The mark will be closed automatically.\n  withMark = (mark: Mark, type: string, value?: string, props?: JSONRecord) => {\n    this.#openMark(mark, type, value, props)\n    return this\n  }\n\n  /// Close a opened mark.\n  /// In most cases you don't need this because\n  /// marks will be closed automatically.\n  closeMark = (mark: Mark) => {\n    this.#closeMark(mark)\n    return this\n  }\n\n  /// @internal\n  build = (): MarkdownNode => {\n    let doc: MarkdownNode | null = null\n    do doc = this.#closeNodeAndPush()\n    while (this.size())\n\n    return doc\n  }\n\n  /// Give the node or node list back to the state and\n  /// the state will find a proper runner (by `match` method in serializer spec) to handle it.\n  next = (nodes: Node | Fragment) => {\n    if (isFragment(nodes)) {\n      nodes.forEach((node) => {\n        this.#runNode(node)\n      })\n      return this\n    }\n    this.#runNode(nodes)\n    return this\n  }\n\n  /// Use a remark parser to serialize current AST stored.\n  override toString = (remark: RemarkParser): string =>\n    remark.stringify(this.build() as Root)\n\n  /// Transform a prosemirror node tree into remark AST.\n  run = (tree: Node) => {\n    this.next(tree)\n\n    return this\n  }\n}\n"],"names":["StackElement","Stack","node","_a","el","stackOverFlow","ParserStackElement","type","content","attrs","rest","_ParserState","schema","__privateAdd","_marks","_hasText","_maybeMerge","_matchTarget","_runNode","_closeNodeAndPush","_addNodeAndPush","__privateSet","Mark","a","b","__privateGet","result","x","parserMatchError","nodeType","element","createNodeInParserFail","markType","mark","text","topElement","prevNode","currNode","merged","doc","nodes","remark","markdown","tree","state","ParserState","_SerializerStackElement","children","value","props","SerializerStackElement","isFragment","_SerializerState","_runProseNode","_runProseMark","_searchType","_maybeMergeChildren","_createMarkdownNode","_moveSpaces","_openMark","_closeMark","serializerMatchError","marks","getPriority","child","searchNode","firstChild","target","tmp","nextChildren","index","last","currChildren","currRest","prevChildren","prevRest","next","onPush","startSpaces","endSpaces","first","findIndex","lastChild","trim","SerializerState"],"mappings":";;;;;;;AAGO,MAAeA,EAAmB;AAGzC;AAWO,MAAMC,EAAgD;AAAA,EAAtD,cAAA;AACL,SAAU,WAAsB,CAAC,GAGjC,KAAA,OAAO,MACE,KAAK,SAAS,QAIvB,KAAA,MAAM,MACG,KAAK,SAAS,GAAG,EAAE,GAI5B,KAAA,OAAO,CAACC,MAAqB;;AACtB,OAAAC,IAAA,KAAA,IAAA,MAAA,QAAAA,EAAO,KAAKD;AAAA,IACnB,GAGA,KAAA,OAAO,CAACA,MAAwB;AACzB,WAAA,SAAS,KAAKA,CAAI;AAAA,IACzB,GAGA,KAAA,QAAQ,MAAe;AACf,YAAAE,IAAK,KAAK,SAAS,IAAI;AACzB,UAAA,CAACA,EAAI,OAAMC,EAAc;AAEtB,aAAAD;AAAA,IACT;AAAA,EAAA;AACF;AC5CO,MAAME,UAA2BN,EAAmB;AAAA,EACzD,YACSO,GACAC,GACAC,GACP;AACM,UAAA,GAJC,KAAA,OAAAF,GACA,KAAA,UAAAC,GACA,KAAA,QAAAC;AAAA,EAAA;AAAA,EAKT,KAAKP,MAAeQ,GAAc;AAChC,SAAK,QAAQ,KAAKR,GAAM,GAAGQ,CAAI;AAAA,EAAA;AAAA,EAGjC,MAAwB;AACf,WAAA,KAAK,QAAQ,IAAI;AAAA,EAAA;AAAA,EAG1B,OAAO,OAAOH,GAAgBC,GAAiBC,GAAe;AAC5D,WAAO,IAAIH,EAAmBC,GAAMC,GAASC,CAAK;AAAA,EAAA;AAEtD;;ACEO,MAAME,IAAN,MAAMA,UAAoBV,EAAgC;AAAA;AAAA,EAsBrD,YAAYW,GAAgB;AAC9B,UAAA;AAlBR,IAAAC,EAAA,MAAAC;AAuBA,IAAAD,EAAA,MAAAE;AAGA,IAAAF,EAAA,MAAAG;AAQA,IAAAH,EAAA,MAAAI;AAeA,IAAAJ,EAAA,MAAAK;AAuBA,IAAAL,EAAA,MAAAM;AAcA,IAAAN,EAAA,MAAAO;AAtFA,IAAAC,EAAA,MAAAP,GAA0BQ,EAAK,OAuBpBD,EAAA,MAAAN,GAAA,CAACb,MAAgDA,EAAK,SAGnDmB,EAAA,MAAAL,GAAA,CAACO,GAASC,MAA8B;AACpD,UAAIC,EAAA,MAAKV,GAAL,WAAcQ,MAAME,EAAA,MAAKV,GAAL,WAAcS,MAAMF,EAAK,QAAQC,EAAE,OAAOC,EAAE,KAAK;AAChE,eAAA,KAAK,OAAO,KAAKD,EAAE,OAAOC,EAAE,MAAMD,EAAE,KAAK;AAAA,IAGpD,IAGAF,EAAA,MAAAJ,GAAe,CAACf,MAA4C;AACpD,YAAAwB,IAAS,OAAO,OAAO;AAAA,QAC3B,GAAG,KAAK,OAAO;AAAA,QACf,GAAG,KAAK,OAAO;AAAA,MAAA,CAChB,EAAE,KAAK,CAACC,MACMA,EAAE,KACH,cAAc,MAAMzB,CAAI,CACrC;AAED,UAAI,CAACwB,EAAc,OAAAE,EAAiB1B,CAAI;AAEjC,aAAAwB;AAAA,IACT,IAGAL,EAAA,MAAAH,GAAW,CAAChB,MAAuB;AAC3B,YAAAK,IAAOkB,EAAA,MAAKR,GAAL,WAAkBf;AAG/B,MAFaK,EAAK,KAEb,cAAc,OAAO,MAAML,GAAMK,CAA2B;AAAA,IACnE,IAGa,KAAA,aAAA,CAACL,GAAoB2B,GAAoBpB,OAC/C,KAAA,SAASoB,GAAUpB,CAAK,GACxB,KAAA,KAAKP,EAAK,QAAQ,GAEhB,OAKE,KAAA,WAAA,CAAC2B,GAAoBpB,OAC9B,KAAK,KAAKH,EAAmB,OAAOuB,GAAU,CAAA,GAAIpB,CAAK,CAAC,GACjD,OAITY,EAAA,MAAAF,GAAoB,MAAY;AAC9B,MAAAE,EAAA,MAAKP,GAASQ,EAAK;AACb,YAAAQ,IAAU,KAAK,MAAM;AAE3B,aAAOL,EAAA,MAAKL,GAAL,WAAqBU,EAAQ,MAAMA,EAAQ,OAAOA,EAAQ;AAAA,IACnE,IAGA,KAAA,YAAY,OACVL,EAAA,MAAKN,GAAL,YACO,OAISE,EAAA,MAAAD,GAAA,CAChBS,GACApB,GACAD,MACS;AACT,YAAMN,IAAO2B,EAAS,cAAcpB,GAAOD,GAASiB,EAAA,MAAKX,EAAM;AAC/D,UAAI,CAACZ,EAAM,OAAM6B,EAAuBF,GAAUpB,GAAOD,CAAO;AAEhE,kBAAK,KAAKN,CAAI,GAEPA;AAAA,IACT,IAGU,KAAA,UAAA,CAAC2B,GAAoBpB,GAAeD,OACvCiB,EAAA,MAAAL,GAAA,WAAgBS,GAAUpB,GAAOD,IAC/B,OAIE,KAAA,WAAA,CAACwB,GAAoBvB,MAAkB;AAC1C,YAAAwB,IAAOD,EAAS,OAAOvB,CAAK;AAElC,aAAAY,EAAA,MAAKP,GAASmB,EAAK,SAASR,EAAA,MAAKX,EAAM,IAChC;AAAA,IACT,GAGA,KAAA,YAAY,CAACkB,OACXX,EAAA,MAAKP,GAASkB,EAAS,cAAcP,EAAA,MAAKX,EAAM,IACzC,OAIT,KAAA,UAAU,CAACoB,MAAiB;AACpB,YAAAC,IAAa,KAAK,IAAI;AACxB,UAAA,CAACA,EAAY,OAAM9B,EAAc;AAE/B,YAAA+B,IAAWD,EAAW,IAAI,GAC1BE,IAAW,KAAK,OAAO,KAAKH,GAAMT,EAAA,MAAKX,EAAM;AAEnD,UAAI,CAACsB;AACH,eAAAD,EAAW,KAAKE,CAAQ,GACjB;AAGT,YAAMC,IAASb,EAAA,MAAKT,GAAL,WAAiBoB,GAAUC;AAC1C,aAAIC,KACFH,EAAW,KAAKG,CAAM,GACf,SAEEH,EAAA,KAAKC,GAAUC,CAAQ,GAC3B;AAAA,IACT,GAGA,KAAA,QAAQ,MAAY;AACd,UAAAE;AAEJ;AAAG,QAAAA,IAAMd,EAAA,MAAKN,GAAL;AAAA,aACF,KAAK,KAAK;AAEV,aAAAoB;AAAA,IACT,GAIO,KAAA,OAAA,CAACC,IAAuC,QAC3C,CAAAA,CAAK,EAAE,KAAA,EAAO,QAAQ,CAACtC,MAASuB,EAAA,MAAKP,GAAL,WAAchB,EAAK,GAC9C,OAID,KAAA,QAAA,MAAM,KAAK,MAAM,GAGnB,KAAA,MAAA,CAACuC,GAAsBC,MAAqB;AAChD,YAAMC,IAAOF,EAAO;AAAA,QAClBA,EAAO,MAAMC,CAAQ;AAAA,QACrBA;AAAA,MACF;AACA,kBAAK,KAAKC,CAAI,GAEP;AAAA,IACT,GAvJE,KAAK,SAAS/B;AAAA,EAAA;AAwJlB;AA3KEE,IAAA,eAuBAC,IAAA,eAGAC,IAAA,eAQAC,IAAA,eAeAC,IAAA,eAuBAC,IAAA,eAcAC,IAAA,eA9EOT,EAAA,SAAS,CAACC,GAAgB6B,MAAiC;AAC1D,QAAAG,IAAQ,IAAIjC,EAAKC,CAAM;AAC7B,SAAO,CAACsB,OACAU,EAAA,IAAIH,GAAQP,CAAI,GACfU,EAAM,MAAM;AAEvB;AAnBK,IAAMC,IAANlC;ACrBA,MAAMmC,IAAN,MAAMA,UAA+B9C,EAA2B;AAAA,EACrE,YACSO,GACAwC,GACAC,GACAC,IAAoB,CAAA,GAC3B;AACM,UAAA,GALC,KAAA,OAAA1C,GACA,KAAA,WAAAwC,GACA,KAAA,QAAAC,GACA,KAAA,QAAAC,GAYF,KAAA,OAAA,CAAC/C,MAAuBQ,MAAyB;AACtD,MAAK,KAAK,aAAU,KAAK,WAAW,CAAC,IAErC,KAAK,SAAS,KAAKR,GAAM,GAAGQ,CAAI;AAAA,IAClC,GAEM,KAAA,MAAA,MAAA;;AAAgC,cAAAP,IAAA,KAAK,aAAL,gBAAAA,EAAe;AAAA;AAAA,EAAI;AAC3D;AAdE2C,EAAO,SAAS,CACdvC,GACAwC,GACAC,GACAC,IAAoB,CAAC,MAClB,IAAIH,EAAuBvC,GAAMwC,GAAUC,GAAOC,CAAK;AAfvD,IAAMC,IAANJ;ACkBP,MAAMK,KAAa,CAACxB,MAClB,OAAO,UAAU,eAAe,KAAKA,GAAG,MAAM;;AAIzC,MAAMyB,IAAN,MAAMA,UAAwBnD,EAGnC;AAAA;AAAA,EAqBA,YAAYW,GAAgB;AACpB,UAAA;AApBR,IAAAC,EAAA,MAAAC;AAyBA,IAAAD,EAAA,MAAAI;AAeA,IAAAJ,EAAA,MAAAwC;AAOA,IAAAxC,EAAA,MAAAyC;AAOA,IAAAzC,EAAA,MAAAK;AAWA,IAAAL,EAAA,MAAA0C;AA6BA,IAAA1C,EAAA,MAAA2C;AAkCA,IAAA3C,EAAA,MAAA4C;AAoBA,IAAA5C,EAAA,MAAA6C;AAgDA,IAAA7C,EAAA,MAAAM;AAuBA,IAAAN,EAAA,MAAAO;AA0BA,IAAAP,EAAA,MAAA8C;AAeA,IAAA9C,EAAA,MAAA+C;AApQA,IAAAvC,EAAA,MAAAP,GAA0BQ,EAAK,OAyB/BD,EAAA,MAAAJ,GAAe,CAACf,MAA2C;AACnD,YAAAwB,IAAS,OAAO,OAAO;AAAA,QAC3B,GAAG,KAAK,OAAO;AAAA,QACf,GAAG,KAAK,OAAO;AAAA,MAAA,CAChB,EAAE,KAAK,CAACC,MACMA,EAAE,KACH,WAAW,MAAMzB,CAAmB,CACjD;AAED,UAAI,CAACwB,EAAc,OAAAmC,EAAqB3D,EAAK,IAAI;AAE1C,aAAAwB;AAAA,IACT,IAGAL,EAAA,MAAAgC,GAAgB,CAACnD,MACFuB,EAAA,MAAKR,GAAL,WAAkBf,GACb,KACN,WAAW,OAAO,MAAMA,CAAI,IAI1BmB,EAAA,MAAAiC,GAAA,CAACrB,GAAY/B,MACduB,EAAA,MAAKR,GAAL,WAAkBgB,GACb,KACN,WAAW,OAAO,MAAMA,GAAM/B,CAAI,IAIhDmB,EAAA,MAAAH,GAAW,CAAChB,MAAe;AACnB,YAAA,EAAE,OAAA4D,MAAU5D,GACZ6D,IAAc,CAACpC,MAAYA,EAAE,KAAK,KAAK,YAAY;AAGrD,MAFQ,CAAC,GAAGmC,CAAK,EAAE,KAAK,CAACvC,GAAGC,MAAMuC,EAAYxC,CAAC,IAAIwC,EAAYvC,CAAC,CAAC,EAC3C,MAAM,CAACS,MAAS,CAACR,EAAA,MAAK6B,GAAL,WAAmBrB,GAAM/B,EAAK,KACjDuB,EAAA,MAAA4B,GAAA,WAAcnD,IAEtC4D,EAAM,QAAQ,CAAC7B,MAASR,EAAA,MAAKmC,GAAL,WAAgB3B,EAAK;AAAA,IAC/C,IAGcZ,EAAA,MAAAkC,GAAA,CAACS,GAAqBzD,MAA+B;;AAGjE,UAFIyD,EAAM,SAASzD,OAEfJ,IAAA6D,EAAM,aAAN,gBAAA7D,EAAgB,YAAW,EAAU,QAAA6D;AAEnC,YAAAC,IAAa,CAAC/D,MAA4C;;AAC1DA,YAAAA,EAAK,SAASK,EAAaL,QAAAA;AAE/B,cAAIA,IAAAA,EAAK,aAALA,gBAAAA,EAAe,YAAW,EAAU,QAAA;AAElC,cAAA,CAACgE,CAAU,IAAIhE,EAAK;AACtB,eAACgE,IAEED,EAAWC,CAAU,IAFJ;AAAA,MAG1B,GAEMC,IAASF,EAAWD,CAAK;AAE3B,UAAA,CAACG,EAAe,QAAAH;AAEpB,YAAMI,IAAMD,EAAO,WAAW,CAAC,GAAGA,EAAO,QAAQ,IAAI,QAC/CjE,IAAO,EAAE,GAAG8D,GAAO,UAAUI,EAAI;AACvC,aAAAlE,EAAK,WAAWkE,GACTD,EAAA,WAAW,CAACjE,CAAI,GAEhBiE;AAAA,IACT,IAGA9C,EAAA,MAAAmC,GAAsB,CAACtD,MAAqC;AACpD,YAAA,EAAE,UAAA6C,MAAa7C;AACjB,aAAC6C,MAEL7C,EAAK,WAAW6C,EAAS,OAAO,CAACsB,GAAcL,GAAOM,MAAU;AAC9D,YAAIA,MAAU,EAAU,QAAA,CAACN,CAAK;AAExB,cAAAO,IAAOF,EAAa,GAAG,EAAE;AAC/B,YAAIE,KAAQA,EAAK,UAAUP,EAAM,QAAQ;AACvC,UAAAA,IAAQvC,EAAA,MAAK8B,GAAL,WAAiBS,GAAOO,EAAK;AACrC,gBAAM,EAAE,UAAUC,GAAc,GAAGC,EAAa,IAAAT,GAC1C,EAAE,UAAUU,GAAc,GAAGC,EAAa,IAAAJ;AAChD,cACEP,EAAM,SAASO,EAAK,QACpBC,KACAE,KACA,KAAK,UAAUD,CAAQ,MAAM,KAAK,UAAUE,CAAQ,GACpD;AACA,kBAAMC,IAAO;AAAA,cACX,GAAGD;AAAA,cACH,UAAU,CAAC,GAAGD,GAAc,GAAGF,CAAY;AAAA,YAC7C;AACO,mBAAAH,EACJ,MAAM,GAAG,EAAE,EACX,OAAO5C,EAAA,MAAK+B,GAAL,WAAyBoB,EAAK;AAAA,UAAA;AAAA,QAC1C;AAEK,eAAAP,EAAa,OAAOL,CAAK;AAAA,MAClC,GAAG,EAAoB,IAEhB9D;AAAA,IACT,IAGAmB,EAAA,MAAAoC,GAAsB,CAAC3B,MAAoC;AACzD,YAAM5B,IAAqB;AAAA,QACzB,GAAG4B,EAAQ;AAAA,QACX,MAAMA,EAAQ;AAAA,MAChB;AAEA,aAAIA,EAAQ,aAAe5B,EAAA,WAAW4B,EAAQ,WAE1CA,EAAQ,UAAY5B,EAAA,QAAQ4B,EAAQ,QAEjC5B;AAAA,IACT,IAIW,KAAA,WAAA,CAACK,GAAcyC,GAAgBC,OACxC,KAAK,KAAKC,EAAuB,OAAO3C,GAAM,QAAWyC,GAAOC,CAAK,CAAC,GAC/D,OAGK5B,EAAA,MAAAqC,GAAA,CACZ5B,GACA+C,MACG;AACH,UAAIC,IAAc,IACdC,IAAY;AAChB,YAAMhC,IAAWjB,EAAQ;AACzB,UAAIkD,IAAQ,IACRT,IAAO;AACL,YAAAU,IAAY,CAAC/E,MAAyB;AAC1C,QAAKA,KACAA,EAAA,QAAQ,CAAC8D,GAAOM,MAAU;AAC7B,UAAIN,EAAM,SAAS,UAAUA,EAAM,UAC7BgB,IAAQ,MAAWA,IAAAV,IAEhBC,IAAAD;AAAA,QACT,CACD;AAAA,MACH;AAEA,UAAIvB,GAAU;AACZ,QAAAkC,EAAUlC,CAAQ;AACZ,cAAAmC,IAAYnC,KAAA,gBAAAA,EAAWwB,IAGvBL,IAAanB,KAAA,gBAAAA,EAAWiC;AAG9B,QAAIE,KAAaA,EAAU,MAAM,SAAS,GAAG,MAC3CH,IAAYG,EAAU,MAAM,MAAM,KAAK,EAAG,CAAC,GACjCA,EAAA,QAAQA,EAAU,MAAM,QAAQ,IAExChB,KAAcA,EAAW,MAAM,WAAW,GAAG,MAC/CY,IAAcZ,EAAW,MAAM,MAAM,KAAK,EAAG,CAAC,GACnCA,EAAA,QAAQA,EAAW,MAAM,UAAU;AAAA,MAChD;AAGF,MAAIY,EAAY,UAAQrD,EAAA,MAAKL,GAAL,WAAqB,QAAQ,QAAW0D;AAEhE,YAAMpD,IAASmD,EAAO;AAEtB,aAAIE,EAAU,UAAQtD,EAAA,MAAKL,GAAL,WAAqB,QAAQ,QAAW2D,IAEvDrD;AAAA,IACT,IAGoBL,EAAA,MAAAF,GAAA,CAACgE,IAAgB,OAAwB;AACrD,YAAArD,IAAU,KAAK,MAAM,GAErB+C,IAAS,MACbpD,EAAA,MAAKL,GAAL,WACEU,EAAQ,MACRA,EAAQ,UACRA,EAAQ,OACRA,EAAQ;AAGZ,aAAIqD,IAAa1D,EAAA,MAAKiC,GAAL,WAAiB5B,GAAS+C,KAEpCA,EAAO;AAAA,IAChB,IAGA,KAAA,YAAY,OACVpD,EAAA,MAAKN,GAAL,YACO,OAITE,EAAA,MAAAD,GAAkB,CAChBb,GACAwC,GACAC,GACAC,MACiB;AACjB,YAAMnB,IAAUoB,EAAuB,OAAO3C,GAAMwC,GAAUC,GAAOC,CAAK,GACpE/C,IAAqBuB,EAAA,MAAK+B,GAAL,WACzB/B,EAAA,MAAKgC,GAAL,WAAyB3B;AAE3B,kBAAK,KAAK5B,CAAI,GACPA;AAAA,IACT,IAGA,KAAA,UAAU,CACRK,GACAwC,GACAC,GACAC,OAEAxB,EAAA,MAAKL,GAAL,WAAqBb,GAAMwC,GAAUC,GAAOC,IACrC,OAIT5B,EAAA,MAAAsC,GAAY,CACV1B,GACA1B,GACAyC,GACAC,MAEahB,EAAK,QAAQR,EAAA,MAAKX,EAAM,IAEpB,QAEjBO,EAAA,MAAKP,GAASmB,EAAK,SAASR,EAAA,MAAKX,EAAM,IAChC,KAAK,SAASP,GAAMyC,GAAO,EAAE,GAAGC,GAAO,QAAQ,IAAM,KAI9D5B,EAAA,MAAAuC,GAAa,CAAC3B,MAAqB;AAGjC,MAFaA,EAAK,QAAQR,EAAA,MAAKX,EAAM,MAIrCO,EAAA,MAAKP,GAASmB,EAAK,KAAK,cAAcR,EAAA,MAAKX,EAAM,IACjDW,EAAA,MAAKN,GAAL,WAAuB;AAAA,IACzB,IAIA,KAAA,WAAW,CAACc,GAAY1B,GAAcyC,GAAgBC,OACpDxB,EAAA,MAAKkC,GAAL,WAAe1B,GAAM1B,GAAMyC,GAAOC,IAC3B,OAMT,KAAA,YAAY,CAAChB,OACXR,EAAA,MAAKmC,GAAL,WAAgB3B,IACT,OAIT,KAAA,QAAQ,MAAoB;AAC1B,UAAIM,IAA2B;AAC/B;AAAG,QAAAA,IAAMd,EAAA,MAAKN,GAAL;AAAA,aACF,KAAK,KAAK;AAEV,aAAAoB;AAAA,IACT,GAIA,KAAA,OAAO,CAACC,MACFW,GAAWX,CAAK,KACZA,EAAA,QAAQ,CAACtC,MAAS;AACtB,MAAAuB,EAAA,MAAKP,GAAL,WAAchB;AAAA,IAAI,CACnB,GACM,SAETuB,EAAA,MAAKP,GAAL,WAAcsB,IACP,OAIT,KAAS,WAAW,CAACC,MACnBA,EAAO,UAAU,KAAK,OAAe,GAGvC,KAAA,MAAM,CAACE,OACL,KAAK,KAAKA,CAAI,GAEP,OArSP,KAAK,SAAS/B;AAAA,EAAA;AAuSlB;AA5TEE,IAAA,eAyBAG,IAAA,eAeAoC,IAAA,eAOAC,IAAA,eAOApC,IAAA,eAWAqC,IAAA,eA6BAC,IAAA,eAkCAC,IAAA,eAoBAC,IAAA,eAgDAvC,IAAA,eAuBAC,IAAA,eA0BAuC,IAAA,eAeAC,IAAA,eA1POR,EAAA,SAAS,CAACxC,GAAgB6B,MAAqC;AAC9D,QAAAG,IAAQ,IAAIQ,EAAKxC,CAAM;AAC7B,SAAO,CAACJ,OACNoC,EAAM,IAAIpC,CAAO,GACVoC,EAAM,SAASH,CAAM;AAEhC;AArBK,IAAM2C,IAANhC;"}