{"version":3,"file":"index.es.js","sources":["../src/__internal__/utils.ts","../src/__internal__/remark-handlers.ts","../src/internal-plugin/atoms.ts","../src/internal-plugin/config.ts","../src/internal-plugin/init.ts","../src/internal-plugin/schema.ts","../src/internal-plugin/commands.ts","../src/internal-plugin/parser.ts","../src/internal-plugin/serializer.ts","../src/internal-plugin/editor-state.ts","../src/internal-plugin/editor-view.ts","../src/editor/editor.ts"],"sourcesContent":["import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(\n  plugin: T,\n  meta: Partial<Meta> & Pick<Meta, 'displayName'>\n): T {\n  plugin.meta = {\n    package: '@milkdown/core',\n    group: 'System',\n    ...meta,\n  }\n\n  return plugin\n}\n","import type { Options } from 'remark-stringify'\n\nexport const remarkHandlers: Required<Options>['handlers'] = {\n  strong: (node, _, state, info) => {\n    const marker = node.marker || state.options.strong || '*'\n    const exit = state.enter('strong')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker + marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      })\n    )\n    value += tracker.move(marker + marker)\n    exit()\n    return value\n  },\n  emphasis: (node, _, state, info) => {\n    const marker = node.marker || state.options.emphasis || '*'\n    const exit = state.enter('emphasis')\n    const tracker = state.createTracker(info)\n    let value = tracker.move(marker)\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: marker,\n        ...tracker.current(),\n      })\n    )\n    value += tracker.move(marker)\n    exit()\n    return value\n  },\n}\n","import { createSlice } from '@milkdown/ctx'\nimport type { EditorState, Plugin } from '@milkdown/prose/state'\nimport type {\n  EditorView,\n  MarkViewConstructor,\n  NodeViewConstructor,\n} from '@milkdown/prose/view'\nimport type { SliceType, TimerType } from '@milkdown/ctx'\nimport type { InputRule } from '@milkdown/prose/inputrules'\nimport type { RemarkParser, RemarkPlugin } from '@milkdown/transformer'\nimport remarkParse from 'remark-parse'\nimport type { Options } from 'remark-stringify'\nimport remarkStringify from 'remark-stringify'\nimport { unified } from 'unified'\nimport type { Editor } from '../editor'\nimport { remarkHandlers } from '../__internal__'\n\n/// A slice which contains the editor view instance.\nexport const editorViewCtx = createSlice({} as EditorView, 'editorView')\n\n/// A slice which contains the editor state.\nexport const editorStateCtx = createSlice({} as EditorState, 'editorState')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ConfigReady]`.\nexport const initTimerCtx = createSlice([] as TimerType[], 'initTimer')\n\n/// A slice which stores the editor instance.\nexport const editorCtx = createSlice({} as Editor, 'editor')\n\n/// A slice which stores the input rules.\nexport const inputRulesCtx = createSlice([] as InputRule[], 'inputRules')\n\n/// A slice which stores the prosemirror plugins.\nexport const prosePluginsCtx = createSlice([] as Plugin[], 'prosePlugins')\n\n/// A slice which stores the remark plugins.\nexport const remarkPluginsCtx = createSlice(\n  [] as RemarkPlugin[],\n  'remarkPlugins'\n)\n\ntype NodeView = [nodeId: string, view: NodeViewConstructor]\n\n/// A slice which stores the prosemirror node views.\nexport const nodeViewCtx = createSlice([] as NodeView[], 'nodeView')\n\ntype MarkView = [nodeId: string, view: MarkViewConstructor]\n\n/// A slice which stores the prosemirror mark views.\nexport const markViewCtx = createSlice([] as MarkView[], 'markView')\n\n/// A slice which stores the remark instance.\nexport const remarkCtx: SliceType<RemarkParser, 'remark'> = createSlice(\n  unified().use(remarkParse).use(remarkStringify),\n  'remark'\n)\n\n/// A slice which stores the remark stringify options.\nexport const remarkStringifyOptionsCtx = createSlice(\n  {\n    handlers: remarkHandlers,\n  } as Options,\n  'remarkStringifyOptions'\n)\n","import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport { createTimer } from '@milkdown/ctx'\nimport { withMeta } from '../__internal__'\n\n/// @internal\nexport type Config = (ctx: Ctx) => void | Promise<void>\n\n/// The timer which will be resolved when the config plugin is ready.\nexport const ConfigReady = createTimer('ConfigReady')\n\n/// The config plugin.\n/// This plugin will load all user configs.\nexport function config(configure: Config): MilkdownPlugin {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx.record(ConfigReady)\n\n    return async () => {\n      await configure(ctx)\n      ctx.done(ConfigReady)\n\n      return () => {\n        ctx.clearTimer(ConfigReady)\n      }\n    }\n  }\n\n  withMeta(plugin, {\n    displayName: 'Config',\n  })\n\n  return plugin\n}\n","import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { createTimer } from '@milkdown/ctx'\nimport remarkParse from 'remark-parse'\nimport remarkStringify from 'remark-stringify'\nimport { unified } from 'unified'\n\nimport type { Editor } from '../editor'\nimport { remarkHandlers, withMeta } from '../__internal__'\nimport { ConfigReady } from './config'\nimport {\n  editorCtx,\n  initTimerCtx,\n  inputRulesCtx,\n  markViewCtx,\n  nodeViewCtx,\n  prosePluginsCtx,\n  remarkCtx,\n  remarkPluginsCtx,\n  remarkStringifyOptionsCtx,\n} from './atoms'\n\n/// The timer which will be resolved when the init plugin is ready.\nexport const InitReady = createTimer('InitReady')\n\n/// The init plugin.\n/// This plugin prepare slices that needed by other plugins. And create a remark instance.\n///\n/// This plugin will wait for the config plugin.\nexport function init(editor: Editor): MilkdownPlugin {\n  const plugin: MilkdownPlugin = (ctx) => {\n    ctx\n      .inject(editorCtx, editor)\n      .inject(prosePluginsCtx, [])\n      .inject(remarkPluginsCtx, [])\n      .inject(inputRulesCtx, [])\n      .inject(nodeViewCtx, [])\n      .inject(markViewCtx, [])\n      .inject(remarkStringifyOptionsCtx, {\n        handlers: remarkHandlers,\n      })\n      .inject(remarkCtx, unified().use(remarkParse).use(remarkStringify))\n      .inject(initTimerCtx, [ConfigReady])\n      .record(InitReady)\n\n    return async () => {\n      await ctx.waitTimers(initTimerCtx)\n      const options = ctx.get(remarkStringifyOptionsCtx)\n      ctx.set(\n        remarkCtx,\n        unified().use(remarkParse).use(remarkStringify, options)\n      )\n\n      ctx.done(InitReady)\n\n      return () => {\n        ctx\n          .remove(editorCtx)\n          .remove(prosePluginsCtx)\n          .remove(remarkPluginsCtx)\n          .remove(inputRulesCtx)\n          .remove(nodeViewCtx)\n          .remove(markViewCtx)\n          .remove(remarkStringifyOptionsCtx)\n          .remove(remarkCtx)\n          .remove(initTimerCtx)\n          .clearTimer(InitReady)\n      }\n    }\n  }\n  withMeta(plugin, {\n    displayName: 'Init',\n  })\n\n  return plugin\n}\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Schema } from '@milkdown/prose/model'\nimport type {\n  MarkSchema,\n  NodeSchema,\n  RemarkParser,\n} from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { InitReady } from './init'\nimport { remarkCtx, remarkPluginsCtx } from './atoms'\n\n/// The timer which will be resolved when the schema plugin is ready.\nexport const SchemaReady = createTimer('SchemaReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[InitReady]`.\nexport const schemaTimerCtx = createSlice([] as TimerType[], 'schemaTimer')\n\n/// A slice which contains the schema.\nexport const schemaCtx = createSlice({} as Schema, 'schema')\n\n/// A slice which stores the nodes spec.\nexport const nodesCtx = createSlice([] as Array<[string, NodeSchema]>, 'nodes')\n\n/// A slice which stores the marks spec.\nexport const marksCtx = createSlice([] as Array<[string, MarkSchema]>, 'marks')\n\nfunction extendPriority<T extends NodeSchema | MarkSchema>(x: T): T {\n  return {\n    ...x,\n    parseDOM: x.parseDOM?.map((rule) => ({ priority: x.priority, ...rule })),\n  }\n}\n\n/// The schema plugin.\n/// This plugin will load all nodes spec and marks spec and create a schema.\n///\n/// This plugin will wait for the init plugin.\nexport const schema: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(schemaCtx, {} as Schema)\n    .inject(nodesCtx, [])\n    .inject(marksCtx, [])\n    .inject(schemaTimerCtx, [InitReady])\n    .record(SchemaReady)\n\n  return async () => {\n    await ctx.waitTimers(schemaTimerCtx)\n\n    const remark = ctx.get(remarkCtx)\n    const remarkPlugins = ctx.get(remarkPluginsCtx)\n\n    const processor = remarkPlugins.reduce(\n      (acc: RemarkParser, plug) =>\n        acc.use(plug.plugin, plug.options) as unknown as RemarkParser,\n      remark\n    )\n    ctx.set(remarkCtx, processor)\n\n    const nodes = Object.fromEntries(\n      ctx.get(nodesCtx).map(([key, x]) => [key, extendPriority(x)])\n    )\n    const marks = Object.fromEntries(\n      ctx.get(marksCtx).map(([key, x]) => [key, extendPriority(x)])\n    )\n    const schema = new Schema({ nodes, marks })\n\n    ctx.set(schemaCtx, schema)\n\n    ctx.done(SchemaReady)\n\n    return () => {\n      ctx\n        .remove(schemaCtx)\n        .remove(nodesCtx)\n        .remove(marksCtx)\n        .remove(schemaTimerCtx)\n        .clearTimer(SchemaReady)\n    }\n  }\n}\n\nwithMeta(schema, {\n  displayName: 'Schema',\n})\n","import type { Ctx, MilkdownPlugin, SliceType } from '@milkdown/ctx'\nimport { Container, createSlice, createTimer } from '@milkdown/ctx'\nimport { callCommandBeforeEditorView } from '@milkdown/exception'\nimport type { Command } from '@milkdown/prose/state'\n\nimport { withMeta } from '../__internal__'\nimport { SchemaReady } from './schema'\nimport { editorViewCtx } from './atoms'\n\n/// @internal\nexport type Cmd<T = undefined> = (payload?: T) => Command\n\n/// @internal\nexport type CmdKey<T = undefined> = SliceType<Cmd<T>>\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\n/// The command manager.\n/// This manager will manage all commands in editor.\n/// Generally, you don't need to use this manager directly.\n/// You can use the `$command` and `$commandAsync` in `@milkdown/utils` to create and call a command.\nexport class CommandManager {\n  /// @internal\n  #container = new Container()\n\n  /// @internal\n  #ctx: Ctx | null = null\n\n  /// @internal\n  setCtx = (ctx: Ctx) => {\n    this.#ctx = ctx\n  }\n\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Register a command into the manager.\n  create<T>(meta: CmdKey<T>, value: Cmd<T>) {\n    const slice = meta.create(this.#container.sliceMap)\n    slice.set(value)\n    return slice\n  }\n\n  /// Get a command from the manager.\n  get<T extends CmdKey<any>>(slice: string): Cmd<InferParams<T>>\n  get<T>(slice: CmdKey<T>): Cmd<T>\n  get(slice: string | CmdKey<any>): Cmd<any>\n  get(slice: string | CmdKey<any>): Cmd<any> {\n    return this.#container.get(slice).get()\n  }\n\n  /// Remove a command from the manager.\n  remove<T extends CmdKey<any>>(slice: string): void\n  remove<T>(slice: CmdKey<T>): void\n  remove(slice: string | CmdKey<any>): void\n  remove(slice: string | CmdKey<any>): void {\n    return this.#container.remove(slice)\n  }\n\n  /// Call a registered command.\n  call<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): boolean\n  call<T>(slice: CmdKey<T>, payload?: T): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean\n  call(slice: string | CmdKey<any>, payload?: any): boolean {\n    if (this.#ctx == null) throw callCommandBeforeEditorView()\n\n    const cmd = this.get(slice)\n    const command = cmd(payload)\n    const view = this.#ctx.get(editorViewCtx)\n    return command(view.state, view.dispatch, view)\n  }\n}\n\n/// Create a command key, which is a slice type that contains a command.\nexport function createCmdKey<T = undefined>(key = 'cmdKey'): CmdKey<T> {\n  return createSlice((() => () => false) as Cmd<T>, key)\n}\n\n/// A slice which contains the command manager.\nexport const commandsCtx = createSlice(new CommandManager(), 'commands')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const commandsTimerCtx = createSlice([SchemaReady], 'commandsTimer')\n\n/// The timer which will be resolved when the commands plugin is ready.\nexport const CommandsReady = createTimer('CommandsReady')\n\n/// The commands plugin.\n/// This plugin will create a command manager.\n///\n/// This plugin will wait for the schema plugin.\nexport const commands: MilkdownPlugin = (ctx) => {\n  const cmd = new CommandManager()\n  cmd.setCtx(ctx)\n  ctx\n    .inject(commandsCtx, cmd)\n    .inject(commandsTimerCtx, [SchemaReady])\n    .record(CommandsReady)\n  return async () => {\n    await ctx.waitTimers(commandsTimerCtx)\n\n    ctx.done(CommandsReady)\n\n    return () => {\n      ctx.remove(commandsCtx).remove(commandsTimerCtx).clearTimer(CommandsReady)\n    }\n  }\n}\n\nwithMeta(commands, {\n  displayName: 'Commands',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport type { Parser } from '@milkdown/transformer'\nimport { ParserState } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './atoms'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the parser plugin is ready.\nexport const ParserReady = createTimer('ParserReady')\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Parser\n\n/// A slice which contains the parser.\nexport const parserCtx = createSlice(outOfScope, 'parser')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const parserTimerCtx = createSlice([] as TimerType[], 'parserTimer')\n\n/// The parser plugin.\n/// This plugin will create a parser.\n///\n/// This plugin will wait for the schema plugin.\nexport const parser: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(parserCtx, outOfScope)\n    .inject(parserTimerCtx, [SchemaReady])\n    .record(ParserReady)\n\n  return async () => {\n    await ctx.waitTimers(parserTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(parserCtx, ParserState.create(schema, remark))\n    ctx.done(ParserReady)\n    return () => {\n      ctx.remove(parserCtx).remove(parserTimerCtx).clearTimer(ParserReady)\n    }\n  }\n}\n\nwithMeta(parser, {\n  displayName: 'Parser',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type { Serializer } from '@milkdown/transformer'\nimport { SerializerState } from '@milkdown/transformer'\n\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport { withMeta } from '../__internal__'\nimport { remarkCtx } from './atoms'\nimport { SchemaReady, schemaCtx } from './schema'\n\n/// The timer which will be resolved when the serializer plugin is ready.\nexport const SerializerReady = createTimer('SerializerReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[SchemaReady]`.\nexport const serializerTimerCtx = createSlice(\n  [] as TimerType[],\n  'serializerTimer'\n)\n\nconst outOfScope = (() => {\n  throw ctxCallOutOfScope()\n}) as Serializer\n\n/// A slice which contains the serializer.\nexport const serializerCtx = createSlice<Serializer, 'serializer'>(\n  outOfScope,\n  'serializer'\n)\n\n/// The serializer plugin.\n/// This plugin will create a serializer.\n///\n/// This plugin will wait for the schema plugin.\nexport const serializer: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(serializerCtx, outOfScope)\n    .inject(serializerTimerCtx, [SchemaReady])\n    .record(SerializerReady)\n\n  return async () => {\n    await ctx.waitTimers(serializerTimerCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    ctx.set(serializerCtx, SerializerState.create(schema, remark))\n    ctx.done(SerializerReady)\n\n    return () => {\n      ctx\n        .remove(serializerCtx)\n        .remove(serializerTimerCtx)\n        .clearTimer(SerializerReady)\n    }\n  }\n}\n\nwithMeta(serializer, {\n  displayName: 'Serializer',\n})\n","import type { MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { docTypeError } from '@milkdown/exception'\nimport { customInputRules as createInputRules } from '@milkdown/prose'\nimport {\n  baseKeymap,\n  chainCommands,\n  deleteSelection,\n  joinBackward,\n  selectNodeBackward,\n} from '@milkdown/prose/commands'\nimport { undoInputRule } from '@milkdown/prose/inputrules'\nimport { keymap as createKeymap } from '@milkdown/prose/keymap'\nimport type { Schema } from '@milkdown/prose/model'\nimport { DOMParser, Node } from '@milkdown/prose/model'\nimport type { Command } from '@milkdown/prose/state'\nimport { EditorState, Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { JSONRecord, Parser } from '@milkdown/transformer'\n\nimport { withMeta } from '../__internal__'\nimport { ParserReady, parserCtx } from './parser'\nimport { schemaCtx } from './schema'\nimport { SerializerReady } from './serializer'\nimport { CommandsReady } from './commands'\nimport { editorStateCtx, inputRulesCtx, prosePluginsCtx } from './atoms'\n\n/// @internal\nexport type DefaultValue =\n  | string\n  | { type: 'html'; dom: HTMLElement }\n  | { type: 'json'; value: JSONRecord }\ntype StateOptions = Parameters<typeof EditorState.create>[0]\ntype StateOptionsOverride = (prev: StateOptions) => StateOptions\n\n/// A slice which contains the default value of the editor.\n/// Can be markdown string, html string or json.\nexport const defaultValueCtx = createSlice('' as DefaultValue, 'defaultValue')\n\n/// A slice which contains the options which is used to create the editor state.\nexport const editorStateOptionsCtx = createSlice<StateOptionsOverride>(\n  (x) => x,\n  'stateOptions'\n)\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[ParserReady, SerializerReady, CommandsReady]`.\nexport const editorStateTimerCtx = createSlice(\n  [] as TimerType[],\n  'editorStateTimer'\n)\n\n/// The timer which will be resolved when the editor state plugin is ready.\nexport const EditorStateReady = createTimer('EditorStateReady')\n\n/// @internal\nexport function getDoc(\n  defaultValue: DefaultValue,\n  parser: Parser,\n  schema: Schema\n) {\n  if (typeof defaultValue === 'string') return parser(defaultValue)\n\n  if (defaultValue.type === 'html')\n    return DOMParser.fromSchema(schema).parse(defaultValue.dom)\n\n  if (defaultValue.type === 'json')\n    return Node.fromJSON(schema, defaultValue.value)\n\n  throw docTypeError(defaultValue)\n}\n\nconst key = new PluginKey('MILKDOWN_STATE_TRACKER')\n\nfunction overrideBaseKeymap(keymap: Record<string, Command>) {\n  const handleBackspace = chainCommands(\n    undoInputRule,\n    deleteSelection,\n    joinBackward,\n    selectNodeBackward\n  )\n  keymap.Backspace = handleBackspace\n  return keymap\n}\n\n/// The editor state plugin.\n/// This plugin will create a prosemirror editor state.\n///\n/// This plugin will wait for the parser plugin, serializer plugin and commands plugin.\nexport const editorState: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(defaultValueCtx, '')\n    .inject(editorStateCtx, {} as EditorState)\n    .inject(editorStateOptionsCtx, (x) => x)\n    .inject(editorStateTimerCtx, [ParserReady, SerializerReady, CommandsReady])\n    .record(EditorStateReady)\n\n  return async () => {\n    await ctx.waitTimers(editorStateTimerCtx)\n\n    const schema = ctx.get(schemaCtx)\n    const parser = ctx.get(parserCtx)\n    const rules = ctx.get(inputRulesCtx)\n    const optionsOverride = ctx.get(editorStateOptionsCtx)\n    const prosePlugins = ctx.get(prosePluginsCtx)\n    const defaultValue = ctx.get(defaultValueCtx)\n    const doc = getDoc(defaultValue, parser, schema)\n\n    const plugins = [\n      ...prosePlugins,\n      new Plugin({\n        key,\n        state: {\n          init: () => {\n            // do nothing\n          },\n          apply: (_tr, _value, _oldState, newState) => {\n            ctx.set(editorStateCtx, newState)\n          },\n        },\n      }),\n      createInputRules({ rules }),\n      createKeymap(overrideBaseKeymap(baseKeymap)),\n    ]\n\n    ctx.set(prosePluginsCtx, plugins)\n\n    const options = optionsOverride({\n      schema,\n      doc,\n      plugins,\n    })\n\n    const state = EditorState.create(options)\n    ctx.set(editorStateCtx, state)\n    ctx.done(EditorStateReady)\n\n    return () => {\n      ctx\n        .remove(defaultValueCtx)\n        .remove(editorStateCtx)\n        .remove(editorStateOptionsCtx)\n        .remove(editorStateTimerCtx)\n        .clearTimer(EditorStateReady)\n    }\n  }\n}\n\nwithMeta(editorState, {\n  displayName: 'EditorState',\n})\n","import type { Ctx, MilkdownPlugin, TimerType } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { DirectEditorProps } from '@milkdown/prose/view'\nimport { EditorView } from '@milkdown/prose/view'\n\nimport { withMeta } from '../__internal__'\nimport { EditorStateReady } from './editor-state'\nimport { InitReady } from './init'\nimport {\n  editorStateCtx,\n  editorViewCtx,\n  markViewCtx,\n  nodeViewCtx,\n  prosePluginsCtx,\n} from './atoms'\n\ntype EditorOptions = Omit<DirectEditorProps, 'state'>\n\ntype RootType = Node | undefined | null | string\n\n/// The timer which will be resolved when the editor view plugin is ready.\nexport const EditorViewReady = createTimer('EditorViewReady')\n\n/// A slice which stores timers that need to be waited for before starting to run the plugin.\n/// By default, it's `[EditorStateReady]`.\nexport const editorViewTimerCtx = createSlice(\n  [] as TimerType[],\n  'editorViewTimer'\n)\n\n/// A slice which contains the editor view options which will be passed to the editor view.\nexport const editorViewOptionsCtx = createSlice(\n  {} as Partial<EditorOptions>,\n  'editorViewOptions'\n)\n\n/// A slice which contains the value to get the root element.\n/// Can be a selector string, a node or null.\n/// If it's null, the editor will be created in the body.\nexport const rootCtx = createSlice(null as RootType, 'root')\n\n/// A slice which contains the actually root element.\nexport const rootDOMCtx = createSlice(null as unknown as HTMLElement, 'rootDOM')\n\n/// A slice which contains the root element attributes.\n/// You can add attributes to the root element by this slice.\nexport const rootAttrsCtx = createSlice(\n  {} as Record<string, string>,\n  'rootAttrs'\n)\n\nfunction createViewContainer(root: Node, ctx: Ctx) {\n  const container = document.createElement('div')\n  container.className = 'milkdown'\n  root.appendChild(container)\n  ctx.set(rootDOMCtx, container)\n\n  const attrs = ctx.get(rootAttrsCtx)\n  Object.entries(attrs).forEach(([key, value]) =>\n    container.setAttribute(key, value)\n  )\n\n  return container\n}\n\nfunction prepareViewDom(dom: Element) {\n  dom.classList.add('editor')\n  dom.setAttribute('role', 'textbox')\n}\n\nconst key = new PluginKey('MILKDOWN_VIEW_CLEAR')\n\n/// The editor view plugin.\n/// This plugin will create an editor view.\n///\n/// This plugin will wait for the editor state plugin.\nexport const editorView: MilkdownPlugin = (ctx) => {\n  ctx\n    .inject(rootCtx, document.body)\n    .inject(editorViewCtx, {} as EditorView)\n    .inject(editorViewOptionsCtx, {})\n    .inject(rootDOMCtx, null as unknown as HTMLElement)\n    .inject(rootAttrsCtx, {})\n    .inject(editorViewTimerCtx, [EditorStateReady])\n    .record(EditorViewReady)\n\n  return async () => {\n    await ctx.wait(InitReady)\n\n    const root = ctx.get(rootCtx) || document.body\n    const el = typeof root === 'string' ? document.querySelector(root) : root\n\n    ctx.update(prosePluginsCtx, (xs) => [\n      new Plugin({\n        key,\n        view: (editorView) => {\n          const container = el ? createViewContainer(el, ctx) : undefined\n\n          const handleDOM = () => {\n            if (container && el) {\n              const editor = editorView.dom\n              el.replaceChild(container, editor)\n              container.appendChild(editor)\n            }\n          }\n          handleDOM()\n          return {\n            destroy: () => {\n              if (container?.parentNode)\n                container?.parentNode.replaceChild(editorView.dom, container)\n\n              container?.remove()\n            },\n          }\n        },\n      }),\n      ...xs,\n    ])\n\n    await ctx.waitTimers(editorViewTimerCtx)\n\n    const state = ctx.get(editorStateCtx)\n    const options = ctx.get(editorViewOptionsCtx)\n    const nodeViews = Object.fromEntries(ctx.get(nodeViewCtx))\n    const markViews = Object.fromEntries(ctx.get(markViewCtx))\n    const view = new EditorView(el as Node, {\n      state,\n      nodeViews,\n      markViews,\n      ...options,\n    })\n    prepareViewDom(view.dom)\n    ctx.set(editorViewCtx, view)\n    ctx.done(EditorViewReady)\n\n    return () => {\n      view?.destroy()\n      ctx\n        .remove(rootCtx)\n        .remove(editorViewCtx)\n        .remove(editorViewOptionsCtx)\n        .remove(rootDOMCtx)\n        .remove(rootAttrsCtx)\n        .remove(editorViewTimerCtx)\n        .clearTimer(EditorViewReady)\n    }\n  }\n}\n\nwithMeta(editorView, {\n  displayName: 'EditorView',\n})\n","import type { CtxRunner, MilkdownPlugin, Telemetry } from '@milkdown/ctx'\nimport { Clock, Container, Ctx } from '@milkdown/ctx'\n\nimport type { Config } from '../internal-plugin'\nimport {\n  commands,\n  config,\n  editorState,\n  editorView,\n  init,\n  parser,\n  schema,\n  serializer,\n} from '../internal-plugin'\n\n/// The status of the editor.\nexport enum EditorStatus {\n  /// The editor is not initialized.\n  Idle = 'Idle',\n  /// The editor is creating.\n  OnCreate = 'OnCreate',\n  /// The editor has been created and ready to use.\n  Created = 'Created',\n  /// The editor is destroying.\n  OnDestroy = 'OnDestroy',\n  /// The editor has been destroyed.\n  Destroyed = 'Destroyed',\n}\n\n/// Type for the callback called when editor status changed.\nexport type OnStatusChange = (status: EditorStatus) => void\n\ntype EditorPluginStore = Map<\n  MilkdownPlugin,\n  {\n    ctx: Ctx | undefined\n    handler: CtxRunner | undefined\n    cleanup: ReturnType<CtxRunner>\n  }\n>\n\n/// The milkdown editor class.\nexport class Editor {\n  /// Create a new editor instance.\n  static make() {\n    return new Editor()\n  }\n\n  /// @internal\n  #enableInspector = false\n  /// @internal\n  #status = EditorStatus.Idle\n  /// @internal\n  #configureList: Config[] = []\n  /// @internal\n  #onStatusChange: OnStatusChange = () => undefined\n\n  /// @internal\n  readonly #container = new Container()\n  /// @internal\n  readonly #clock = new Clock()\n\n  /// @internal\n  readonly #usrPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #sysPluginStore: EditorPluginStore = new Map()\n\n  /// @internal\n  readonly #ctx = new Ctx(this.#container, this.#clock)\n\n  /// @internal\n  readonly #loadInternal = () => {\n    const configPlugin = config(async (ctx) => {\n      await Promise.all(this.#configureList.map((fn) => fn(ctx)))\n    })\n    const internalPlugins = [\n      schema,\n      parser,\n      serializer,\n      commands,\n      editorState,\n      editorView,\n      init(this),\n      configPlugin,\n    ]\n    this.#prepare(internalPlugins, this.#sysPluginStore)\n  }\n\n  /// @internal\n  readonly #prepare = (plugins: MilkdownPlugin[], store: EditorPluginStore) => {\n    plugins.forEach((plugin) => {\n      const ctx = this.#ctx.produce(\n        this.#enableInspector ? plugin.meta : undefined\n      )\n      const handler = plugin(ctx)\n      store.set(plugin, { ctx, handler, cleanup: undefined })\n    })\n  }\n\n  /// @internal\n  readonly #cleanup = (plugins: MilkdownPlugin[], remove = false) => {\n    return Promise.all(\n      [plugins].flat().map((plugin) => {\n        const loader = this.#usrPluginStore.get(plugin)\n        const cleanup = loader?.cleanup\n        if (remove) this.#usrPluginStore.delete(plugin)\n        else\n          this.#usrPluginStore.set(plugin, {\n            ctx: undefined,\n            handler: undefined,\n            cleanup: undefined,\n          })\n\n        if (typeof cleanup === 'function') return cleanup()\n\n        return cleanup\n      })\n    )\n  }\n\n  /// @internal\n  readonly #cleanupInternal = async () => {\n    await Promise.all(\n      [...this.#sysPluginStore.entries()].map(([_, { cleanup }]) => {\n        if (typeof cleanup === 'function') return cleanup()\n\n        return cleanup\n      })\n    )\n    this.#sysPluginStore.clear()\n  }\n\n  /// @internal\n  readonly #setStatus = (status: EditorStatus) => {\n    this.#status = status\n    this.#onStatusChange(status)\n  }\n\n  /// @internal\n  readonly #loadPluginInStore = (store: EditorPluginStore) => {\n    return [...store.entries()].map(async ([key, loader]) => {\n      const { ctx, handler } = loader\n      if (!handler) return\n\n      const cleanup = await handler()\n\n      store.set(key, { ctx, handler, cleanup })\n    })\n  }\n\n  /// Get the ctx of the editor.\n  get ctx() {\n    return this.#ctx\n  }\n\n  /// Get the status of the editor.\n  get status() {\n    return this.#status\n  }\n\n  /// Enable the inspector for the editor.\n  /// You can also pass `false` to disable the inspector.\n  readonly enableInspector = (enable = true) => {\n    this.#enableInspector = enable\n\n    return this\n  }\n\n  /// Subscribe to the status change event for the editor.\n  /// The new subscription will replace the old one.\n  readonly onStatusChange = (onChange: OnStatusChange) => {\n    this.#onStatusChange = onChange\n    return this\n  }\n\n  /// Add a config for the editor.\n  readonly config = (configure: Config) => {\n    this.#configureList.push(configure)\n    return this\n  }\n\n  /// Remove a config for the editor.\n  readonly removeConfig = (configure: Config) => {\n    this.#configureList = this.#configureList.filter((x) => x !== configure)\n    return this\n  }\n\n  /// Use a plugin or a list of plugins for the editor.\n  readonly use = (plugins: MilkdownPlugin | MilkdownPlugin[]) => {\n    const _plugins = [plugins].flat()\n    _plugins.flat().forEach((plugin) => {\n      this.#usrPluginStore.set(plugin, {\n        ctx: undefined,\n        handler: undefined,\n        cleanup: undefined,\n      })\n    })\n\n    if (this.#status === EditorStatus.Created)\n      this.#prepare(_plugins, this.#usrPluginStore)\n\n    return this\n  }\n\n  /// Remove a plugin or a list of plugins from the editor.\n  readonly remove = async (\n    plugins: MilkdownPlugin | MilkdownPlugin[]\n  ): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code.'\n      )\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.remove(plugins))\n        }, 50)\n      })\n    }\n\n    await this.#cleanup([plugins].flat(), true)\n    return this\n  }\n\n  /// Create the editor with current config and plugins.\n  /// If the editor is already created, it will be recreated.\n  readonly create = async (): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate) return this\n\n    if (this.#status === EditorStatus.Created) await this.destroy()\n\n    this.#setStatus(EditorStatus.OnCreate)\n\n    this.#loadInternal()\n    this.#prepare([...this.#usrPluginStore.keys()], this.#usrPluginStore)\n\n    await Promise.all(\n      [\n        this.#loadPluginInStore(this.#sysPluginStore),\n        this.#loadPluginInStore(this.#usrPluginStore),\n      ].flat()\n    )\n\n    this.#setStatus(EditorStatus.Created)\n    return this\n  }\n\n  /// Destroy the editor.\n  /// If you want to clear all plugins, set `clearPlugins` to `true`.\n  readonly destroy = async (clearPlugins = false): Promise<Editor> => {\n    if (\n      this.#status === EditorStatus.Destroyed ||\n      this.#status === EditorStatus.OnDestroy\n    )\n      return this\n\n    if (this.#status === EditorStatus.OnCreate) {\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(this.destroy(clearPlugins))\n        }, 50)\n      })\n    }\n\n    if (clearPlugins) this.#configureList = []\n\n    this.#setStatus(EditorStatus.OnDestroy)\n    await this.#cleanup([...this.#usrPluginStore.keys()], clearPlugins)\n    await this.#cleanupInternal()\n\n    this.#setStatus(EditorStatus.Destroyed)\n    return this\n  }\n\n  /// Call an action with the ctx of the editor.\n  /// This method should be used after the editor is created.\n  readonly action = <T>(action: (ctx: Ctx) => T) => action(this.#ctx)\n\n  /// Get inspections of plugins in editor.\n  /// Make sure you have enabled inspector by `editor.enableInspector()` before calling this method.\n  readonly inspect = (): Telemetry[] => {\n    if (!this.#enableInspector) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first.'\n      )\n      return []\n    }\n    return [...this.#sysPluginStore.values(), ...this.#usrPluginStore.values()]\n      .map(({ ctx }) => ctx?.inspector?.read())\n      .filter((x): x is Telemetry => Boolean(x))\n  }\n}\n"],"names":["withMeta","plugin","meta","remarkHandlers","node","_","state","info","marker","exit","tracker","value","editorViewCtx","createSlice","editorStateCtx","initTimerCtx","editorCtx","inputRulesCtx","prosePluginsCtx","remarkPluginsCtx","nodeViewCtx","markViewCtx","remarkCtx","unified","remarkParse","remarkStringify","remarkStringifyOptionsCtx","ConfigReady","createTimer","config","configure","ctx","InitReady","init","editor","options","SchemaReady","schemaTimerCtx","schemaCtx","nodesCtx","marksCtx","extendPriority","x","_a","rule","schema","remark","processor","acc","plug","nodes","key","marks","Schema","CommandManager","__privateAdd","_container","_ctx","__privateSet","Container","__privateGet","slice","payload","callCommandBeforeEditorView","command","view","createCmdKey","commandsCtx","commandsTimerCtx","CommandsReady","commands","cmd","ParserReady","outOfScope","ctxCallOutOfScope","parserCtx","parserTimerCtx","parser","ParserState","SerializerReady","serializerTimerCtx","serializerCtx","serializer","SerializerState","defaultValueCtx","editorStateOptionsCtx","editorStateTimerCtx","EditorStateReady","getDoc","defaultValue","DOMParser","Node","docTypeError","PluginKey","overrideBaseKeymap","keymap","handleBackspace","chainCommands","undoInputRule","deleteSelection","joinBackward","selectNodeBackward","editorState","rules","optionsOverride","prosePlugins","doc","plugins","Plugin","_tr","_value","_oldState","newState","createInputRules","createKeymap","baseKeymap","EditorState","EditorViewReady","editorViewTimerCtx","editorViewOptionsCtx","rootCtx","rootDOMCtx","rootAttrsCtx","createViewContainer","root","container","attrs","prepareViewDom","dom","editorView","el","xs","nodeViews","markViews","EditorView","EditorStatus","_Editor","_enableInspector","_status","_configureList","_onStatusChange","_clock","_usrPluginStore","_sysPluginStore","_loadInternal","_prepare","_cleanup","_cleanupInternal","_setStatus","_loadPluginInStore","Clock","Ctx","configPlugin","fn","internalPlugins","store","handler","remove","loader","cleanup","status","enable","onChange","_plugins","resolve","clearPlugins","action","Editor"],"mappings":"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"}